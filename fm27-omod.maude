load fm27-start.maude

-------------------------------------------------------------------------------
*******************************************************************************
***
*** 2 The Signature of Full Maude
***
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXTENDED-SORTS is
  ---- Any modification in this module must be reflected in the metamodule 
  ---- used in eq addInfoConds in module UNIT-BUBBLE-PARSING
  sorts @SortToken@ @ViewToken@ @Sort@ @Kind@ @Type@ @SortList@  
        @TypeList@ @ViewExp@ @ModExp@ .
        
  subsorts @SortToken@ < @Sort@ < @SortList@ < @TypeList@ .
  subsorts @Sort@ @Kind@ < @Type@ < @TypeList@ .
  subsort @ViewToken@ < @ViewExp@ .

  op _`{_`} : @Sort@ @ViewExp@ -> @Sort@ [prec 40] .
  op __ : @SortList@ @SortList@ -> @SortList@ [assoc] .
  op __ : @TypeList@ @TypeList@ -> @TypeList@ [assoc] .
  op `[_`] : @Sort@ -> @Kind@ .

  op _`,_ : @ViewExp@ @ViewExp@ -> @ViewExp@ [assoc] .
  op _`{_`} : @ViewExp@ @ViewExp@ -> @ViewExp@ [prec 40] .
endfm

-------------------------------------------------------------------------------
******************************************************************************
-------------------------------------------------------------------------------

fmod OPERATOR-ATTRIBUTES is
  sorts @Attr@ @AttrList@ @Hook@ @HookList@ @Bubble@ @Token@ @NeTokenList@ .
  subsort @Attr@ < @AttrList@ .
  subsort @Hook@ < @HookList@ .

  op __ : @AttrList@ @AttrList@ -> @AttrList@ [assoc] .
  ops assoc associative : -> @Attr@ .
  ops comm commutative : -> @Attr@ .
  ops idem idempotent : -> @Attr@ .
  ops id:_ identity:_ : @Bubble@ -> @Attr@ .
  ops left`id:_ left`identity:_ : @Bubble@ -> @Attr@ .
  ops right`id:_ right`identity:_ : @Bubble@ -> @Attr@ .
  ops frozen`(_`) poly`(_`) strat`(_`) strategy`(_`) : 
        @NeTokenList@ -> @AttrList@ .
  ops memo memoization : -> @Attr@ .
  ops prec_ precedence_ : @Token@ -> @Attr@ .
  ops gather`(_`) gathering`(_`) : @NeTokenList@ -> @Attr@ .
  ops format`(_`) : @NeTokenList@ -> @Attr@ .
  ops ctor constructor : -> @Attr@ .
  ops frozen ditto iter : -> @Attr@ .
  ops object msg message config : -> @Attr@ .
  op metadata_ : @Token@ -> @Attr@ .
  
  op special`(_`) : @HookList@ -> @Attr@ .
  op __ : @HookList@ @HookList@ -> @HookList@ [assoc] .
  op id-hook_ : @Token@ -> @Hook@ .
  op id-hook_`(_`) : @Token@ @NeTokenList@ -> @Hook@ .
  op op-hook_`(_:_->_`) : @Token@ @Token@ @NeTokenList@ @Token@ -> @Hook@ .
  op op-hook_`(_:`->_`) : @Token@ @Token@ @Token@ -> @Hook@ .
  op op-hook_`(_:_~>_`) : @Token@ @Token@ @NeTokenList@ @Token@ -> @Hook@ .
  op op-hook_`(_:`~>_`) : @Token@ @Token@ @Token@ -> @Hook@ .
  op term-hook_`(_`) : @Token@ @Bubble@ -> @Hook@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXPRS is
  including OPERATOR-ATTRIBUTES .
  including EXTENDED-SORTS .

  sorts @Map@ @MapList@ .
  subsort @Map@ < @MapList@ .
  subsorts @Token@ < @ModExp@ .

  *** module expression
  op _*`(_`) : @ModExp@ @MapList@ -> @ModExp@ .
  op _`{_`} : @ModExp@ @ViewExp@ -> @ModExp@ .
  op TUPLE`[_`] : @Token@ -> @ModExp@ .
  op POWER`[_`] : @Token@ -> @ModExp@ .
  op _+_ : @ModExp@ @ModExp@ -> @ModExp@ [assoc prec 42] .

  *** renaming maps
  op op_to_ : @Token@ @Token@ -> @Map@ .
  op op_:_->_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op op_: ->_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op op_:_~>_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op op_: ~>_to_ : @Token@ @Type@ @Token@ -> @Map@ .
  op op_to_`[_`] : @Token@ @Token@ @AttrList@ -> @Map@ .
  op op_:_->_to_`[_`] : @Token@ @TypeList@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:`->_to_`[_`] : @Token@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:_~>_to_`[_`] : @Token@ @TypeList@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op op_:`~>_to_`[_`] : @Token@ @Type@ @Token@ @AttrList@ -> @Map@ .
  op sort_to_ : @Sort@ @Sort@ -> @Map@ .
  op label_to_ : @Token@ @Token@ -> @Map@ .
  op class_to_ : @Sort@ @Sort@ -> @Map@ .
  op attr_._to_ : @Sort@ @Token@ @Token@ -> @Map@ .
  op msg_to_ : @Token@ @Token@ -> @Map@ .
  op msg_:_->_to_ : @Token@ @TypeList@ @Type@ @Token@ -> @Map@ .
  op msg_:`->_to_ : @Token@ @Type@ @Token@ -> @Map@ .

  op _`,_ : @MapList@ @MapList@ -> @MapList@ [assoc prec 42] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod SIGNATURES is
  inc MOD-EXPRS .

  sorts @SortDecl@ @SubsortRel@ @SubsortDecl@ @OpDecl@ .

  op `(_`) : @Token@ -> @Token@ .

  *** sort declaration
  op sorts_. : @SortList@ -> @SortDecl@ .
  op sort_. : @SortList@ -> @SortDecl@ .

  *** subsort declaration
  op subsort_. : @SubsortRel@ -> @SubsortDecl@ .
  op subsorts_. : @SubsortRel@ -> @SubsortDecl@ .
  op _<_ : @SortList@ @SortList@ -> @SubsortRel@ .
  op _<_ : @SortList@ @SubsortRel@ -> @SubsortRel@ .

  *** operator declaration
  op op_:`->_. : @Token@ @Type@ -> @OpDecl@ .
  op op_:`->_`[_`]. : @Token@ @Type@ @AttrList@ -> @OpDecl@ .
  op op_:_->_. : @Token@ @TypeList@ @Type@ -> @OpDecl@ .
  op op_:_->_`[_`]. : @Token@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .
  op ops_:`->_. : @NeTokenList@ @Type@ -> @OpDecl@ .
  op ops_:`->_`[_`]. : @NeTokenList@ @Type@ @AttrList@ -> @OpDecl@ .
  op ops_:_->_. : @NeTokenList@ @TypeList@ @Type@ -> @OpDecl@ .
  op ops_:_->_`[_`]. : @NeTokenList@ @TypeList@ @Type@ @AttrList@ -> @OpDecl@ .

  op op_:`~>_. : @Token@ @Sort@ -> @OpDecl@ .
  op op_:`~>_`[_`]. : @Token@ @Sort@ @AttrList@ -> @OpDecl@ .
  op op_:_~>_. : @Token@ @TypeList@ @Sort@ -> @OpDecl@ .
  op op_:_~>_`[_`]. : @Token@ @TypeList@ @Sort@ @AttrList@ -> @OpDecl@ .
  op ops_:`~>_. : @NeTokenList@ @Sort@ -> @OpDecl@ .
  op ops_:`~>_`[_`]. : @NeTokenList@ @Sort@ @AttrList@ -> @OpDecl@ .
  op ops_:_~>_. : @NeTokenList@ @TypeList@ @Sort@ -> @OpDecl@ .
  op ops_:_~>_`[_`]. : @NeTokenList@ @TypeList@ @Sort@ @AttrList@ -> @OpDecl@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod F&S-MODS&THS is
  including SIGNATURES .
  including QID-LIST .

  sorts @FDeclList@ @SDeclList@ @Module@ @ImportDecl@ @Parameter@ 
        @List<Parameter>@ @EqDecl@ @RlDecl@ @MbDecl@ @VarDecl@ @VarDeclList@ .

  subsort @VarDecl@ < @VarDeclList@ .
  subsorts @VarDecl@ @ImportDecl@ @SortDecl@ @SubsortDecl@ @OpDecl@ @MbDecl@  
           @EqDecl@ @VarDeclList@ < @FDeclList@ .
  subsorts @RlDecl@ @FDeclList@ < @SDeclList@ .

  *** variable declaration
  op vars_:_. : @NeTokenList@ @Type@ -> @VarDecl@ .
  op var_:_. : @NeTokenList@ @Type@ -> @VarDecl@ .
  
  *** membership axiom declaration
  op mb_:_. : @Bubble@ @Bubble@ -> @MbDecl@ .
  ----op mb[_]:_:_. : @Token@ @Bubble@ @Bubble@ -> @MbDecl@ .
  op cmb_:_if_. : @Bubble@ @Sort@ @Bubble@ -> @MbDecl@ . 
  op cmb[_]:_:_if_. : @Token@ @Bubble@ @Sort@ @Bubble@ -> @MbDecl@ . 

  *** equation declaration
  op eq_=_. : @Bubble@ @Bubble@ -> @EqDecl@ .
  op ceq_=_if_. : @Bubble@ @Bubble@ @Bubble@ -> @EqDecl@ .
  op cq_=_if_. : @Bubble@ @Bubble@ @Bubble@ -> @EqDecl@ .

  *** rule declaration
  *** op rl`[_`]:_=>_. : @Token@ @Bubble@ @Bubble@ -> @RlDecl@ .
  op rl_=>_. : @Bubble@ @Bubble@ -> @RlDecl@ .
  *** op crl`[_`]:_=>_if_. : @Token@ @Bubble@ @Bubble@ @Bubble@ -> @RlDecl@ .  
  op crl_=>_if_. : @Bubble@ @Bubble@ @Bubble@ -> @RlDecl@ .  

  *** importation declaration
  ops including_. inc_. : @ModExp@ -> @ImportDecl@ .
  ops extending_. ex_. : @ModExp@ -> @ImportDecl@ .
  ops protecting_. pr_. : @ModExp@ -> @ImportDecl@ .

  sorts @Interface@ .
  subsort @Parameter@ < @List<Parameter>@ .
  subsorts @Token@ < @Interface@ .

  *** parameterized module interface
  op _::_ : @Token@ @ModExp@ -> @Parameter@ [prec 40 gather (e &)] .
  op _::_ : @Token@ @Interface@ -> @Parameter@ [prec 40 gather (e &)] .

  op _`,_ : @List<Parameter>@ @List<Parameter>@ -> @List<Parameter>@ [assoc] .

  op _`{_`} : @ModExp@ @List<Parameter>@ -> @Interface@ .

  *** declaration list
  op __ : @VarDeclList@ @VarDeclList@ -> @VarDeclList@ [assoc] .
  op __ : @SDeclList@ @SDeclList@ -> @SDeclList@ [assoc] .
  op __ : @FDeclList@ @FDeclList@ -> @FDeclList@ [assoc] .

  *** functional and system module and theory
  op fmod_is_endfm : @Interface@ @FDeclList@ -> @Module@ .
  op obj_is_jbo : @Interface@ @FDeclList@ -> @Module@ .
  op obj_is_endo : @Interface@ @FDeclList@ -> @Module@ .
  op mod_is_endm : @Interface@ @SDeclList@ -> @Module@ .
  op fth_is_endfth : @Interface@ @FDeclList@ -> @Module@ .
  op th_is_endth : @Interface@ @SDeclList@ -> @Module@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod O-MODS&THS is
  including F&S-MODS&THS .

  sorts @ClassDecl@ @AttrDecl@ @AttrDeclList@ @SubclassDecl@ @MsgDecl@
        @ODeclList@ .
  subsorts @SDeclList@ @MsgDecl@ @SubclassDecl@ @ClassDecl@ < @ODeclList@ .
  subsort @AttrDecl@ < @AttrDeclList@ .

  op __ : @ODeclList@ @ODeclList@ -> @ODeclList@ [assoc] .

  *** object-oriented module and theory
  op omod_is_endom : @Interface@ @ODeclList@ -> @Module@ .
  op oth_is_endoth : @Interface@ @ODeclList@ -> @Module@ .

  *** class declaration
  op class_|_. : @Sort@ @AttrDeclList@ -> @ClassDecl@ .
  op class_|`. : @Sort@ -> @ClassDecl@ .
  op class_. : @Sort@ -> @ClassDecl@ .
  op _`,_ : @AttrDeclList@ @AttrDeclList@ -> @AttrDeclList@ [assoc] .
  op _:_ : @Token@ @Sort@ -> @AttrDecl@ [prec 40] .

  *** subclass declaration
  op subclass_. : @SubsortRel@ -> @SubclassDecl@ .
  op subclasses_. : @SubsortRel@ -> @SubclassDecl@ .

  *** message declaration
  op msg_:_->_. : @Token@ @SortList@ @Sort@ -> @MsgDecl@ .
  op msgs_:_->_. : @NeTokenList@ @SortList@ @Sort@ -> @MsgDecl@ .
  op msg_:`->_. : @Token@ @Sort@ -> @MsgDecl@ .
  op msgs_:`->_. : @NeTokenList@ @Sort@ -> @MsgDecl@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEWS is
  including O-MODS&THS .

  sorts @ViewDecl@ @ViewDeclList@ @View@ .
  subsorts @VarDecl@ < @ViewDecl@ < @ViewDeclList@ .
  subsort @VarDeclList@ < @ViewDeclList@ .

  *** view maps
  op op_to`term_. : @Bubble@ @Bubble@ -> @ViewDecl@ .
  op op_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op op_:_->_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:`->_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:_~>_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op op_:`~>_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .
  op sort_to_. : @Sort@ @Sort@ -> @ViewDecl@ .
  op class_to_. : @Sort@ @Sort@ -> @ViewDecl@ .
  op attr_._to_. : @Sort@ @Token@ @Token@ -> @ViewDecl@ .
  op msg_to_. : @Token@ @Token@ -> @ViewDecl@ .
  op msg_:_->_to_. : @Token@ @TypeList@ @Type@ @Token@ -> @ViewDecl@ .
  op msg_:`->_to_. : @Token@ @Type@ @Token@ -> @ViewDecl@ .

  *** view
  op view_from_to_is_endv : @Interface@ @ModExp@ @ModExp@ @ViewDeclList@ -> @View@ .
  op view_from_to_is endv : @Interface@ @ModExp@ @ModExp@ -> @View@ .
  op __ : @ViewDeclList@ @ViewDeclList@ -> @ViewDeclList@ [assoc] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod COMMANDS is
  including MOD-EXPRS .

  sorts @Command@ .

  *** down function
  op down_:_ : @ModExp@ @Command@ -> @Command@ .

  *** parse commands
  op parse_. : @Bubble@ -> @Command@ .

  *** reduce commands
  op red_. : @Bubble@ -> @Command@ .
  op reduce_. : @Bubble@ -> @Command@ .

  *** rewrite commands
  op rew_. : @Bubble@ -> @Command@ .
  op rewrite_. : @Bubble@ -> @Command@ .

  *** frewrite commands
  op frew_. : @Bubble@ -> @Command@ .
  op frewrite_. : @Bubble@ -> @Command@ .

  *** search commands
  op search_=>1_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_=>*_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_=>+_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_=>!_. : @Bubble@ @Bubble@ -> @Command@ .

  *** search commands
  op search_~>1_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_~>*_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_~>+_. : @Bubble@ @Bubble@ -> @Command@ .
  op search_~>!_. : @Bubble@ @Bubble@ -> @Command@ .

  *** matching commands
  op match_<=?_. : @Bubble@ @Bubble@ -> @Command@ .
  op xmatch_<=?_. : @Bubble@ @Bubble@ -> @Command@ .

  *** unifying command
  op unify_. : @Bubble@ -> @Command@ .

  *** unifying command
  op id-unify_. : @Bubble@ -> @Command@ .

  *** unifying command
  op variant`unify_. : @Bubble@ -> @Command@ .

  *** unifying command
  op asymmetric`variant`unify_. : @Bubble@ -> @Command@ .

  *** unifying command
  op get`variants_. : @Bubble@ -> @Command@ .

  *** select command
  op select_. : @ModExp@ -> @Command@ .

  *** show commands
  op show`module`. : -> @Command@ .
  op show`module_. : @ModExp@ -> @Command@ .
  op show`all`. : -> @Command@ .
  op show`all_. : @ModExp@ -> @Command@ .
  op show`vars`. : -> @Command@ .
  op show`vars_. : @ModExp@ -> @Command@ .
  op show`sorts`. : -> @Command@ .
  op show`sorts_. : @ModExp@ -> @Command@ .
  op show`ops`. : -> @Command@ .
  op show`ops_. : @ModExp@ -> @Command@ .
  op show`mbs`. : -> @Command@ .
  op show`mbs_. : @ModExp@ -> @Command@ .
  op show`eqs`. : -> @Command@ .
  op show`eqs_. : @ModExp@ -> @Command@ .
  op show`rls`. : -> @Command@ .
  op show`rls_. : @ModExp@ -> @Command@ .
  op show`view_. : @ViewExp@ -> @Command@ .
  op show`modules`. : -> @Command@ .
  op show`views`. : -> @Command@ .

  *** set commands
  op set`protect_on`. : @ModExp@ -> @Command@ .
  op set`protect_off`. : @ModExp@ -> @Command@ .
  op set`include_on`. : @ModExp@ -> @Command@ .
  op set`include_off`. : @ModExp@ -> @Command@ .
  op set`extend_on`. : @ModExp@ -> @Command@ .
  op set`extend_off`. : @ModExp@ -> @Command@ .

  *** miscellaneous
  op load_. : @Bubble@ -> @Command@ .
  ops remove`identity`attributes`. rm`ids`. : -> @Command@ .
  ops remove`identity`attributes_. rm`ids_. : @ModExp@ -> @Command@ .
  op remove`assoc`attributes`. : -> @Command@ .
  op remove`assoc`attributes_. : @ModExp@ -> @Command@ .
  op ax`coherence`completion`. : -> @Command@ .
  op ax`coherence`completion_. : @ModExp@ -> @Command@ .
  op help`. : -> @Command@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FULL-MAUDE-SIGN is
  including VIEWS .
  including COMMANDS .

  sort @Input@ .
  subsorts @Command@ @Module@ @View@ < @Input@ .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------


*******
******* ERROR HANDLING, by Peter Olveczky
*******

*** The following module defines a function which prints up to n characters 
*** of a bubble, followed by the usual arrow <---*HERE* which points to the
*** erroneous token:

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PRINT-SYNTAX-ERROR is
---  protecting META-LEVEL + PRE-VARIANT .
  protecting META-LEVEL .
  protecting INT .

  var  QIL : QidList .
  var  Q : Qid .
  var  N : Nat .
  vars RP RP' : ResultPair .
  var  RP? : [ResultPair?] .

  op printN : Nat QidList -> QidList .  *** first N qid's in a qidList
  eq printN(N, nil) = nil .
  eq printN(0, QIL) = nil .
  eq printN(s N, Q QIL) = Q printN(N, QIL) . 

  op removeFront : Nat QidList -> QidList .  *** removes first N qid's
  eq removeFront(N, nil) = nil .
  eq removeFront(0, QIL) = QIL .
  eq removeFront(s N, Q QIL) = removeFront(N, QIL) .

  op printSyntaxError : [ResultPair?] QidList -> QidList .
  eq printSyntaxError(noParse(N), QIL) 
    = '\r 'Parse 'error 'in '\o '\s printN(N + 1, QIL) '\r '<---*HERE* '\o .
  eq printSyntaxError(ambiguity(RP, RP'), QIL) 
    = '\r 'Ambiguous 'parsing 'for '\o '\s QIL '\o .
  eq printSyntaxError(RP?, QIL) = QIL [owise] . 

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------
*** 
*** The Abstract Data Type \texttt{Module}
*** 
-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** In this section we present the abstract data type \texttt{Module}, which 
*** can be seen as an extension of the predefined sort \texttt{Module} in 
*** several ways. There are constructors for functional, system, and object-
*** oriented modules and theories, which can be parameterized and can import 
*** module expressions. There can also be parameterized sorts in Full Maude 
*** modules, and therefore, the constructors for the different declarations 
*** that can appear in a module have to be appropriately extended.

*** The section is structured as follows. After introducing some modules
*** defining some functions on the predefined sorts \texttt{Bool} and
*** \texttt{QidList} in Section~\ref{BOOL-QID-LIST}, we present in
*** Sections~\ref{EXT-SORT} and~\ref{EXT-DECL} the data types for extended
*** sorts and extended declarations. In Section~\ref{mod-exp-mod-id} we 
*** introduce module expressions and module names, and in 
*** Section~\ref{unitADT} the abstract data type \texttt{Module} itself.

*** 
*** Extension \texttt{QID-LIST}
***

*** The conversion of lists of quoted identifiers into single quoted 
*** identifiers by concatenating them is heavily used in the coming modules.
*** This is the task of the \texttt{} function, which is
*** introduced in the following module \texttt{EXT-QID-LIST} extending the 
*** predefined module \texttt{QID-LIST}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-QID-LIST is
  pr QID-LIST .

  op qidList2Qid : QidList -> Qid .

  vars QI QI' QI'' : Qid .
  var  QIL : QidList .
  vars St St' : String .
  var  N : Nat .
  var  F : FindResult .

  eq qidList2Qid(('\s QIL)) = qid(" " + string(qidList2Qid(QIL))) .
  eq qidList2Qid((QI QIL)) 
    = qid(string(QI) + " " + string(qidList2Qid(QIL))) 
    [owise] .
  eq qidList2Qid(nil) = qid("") .

  op trimQidList : QidList -> QidList .
  eq trimQidList(' QIL) = trimQidList(QIL) .
  eq trimQidList(QI QIL) = QI trimQidList(QIL) [owise] .
  eq trimQidList(nil) = nil .

  op qidList2string : QidList -> String .
  eq qidList2string('`( QIL) = "(" + " " + qidList2string(QIL) .
  eq qidList2string('`) QIL) = ")" + " " + qidList2string(QIL) .
  eq qidList2string('`{ QIL) = "{" + " " + qidList2string(QIL) .
  eq qidList2string('`} QIL) = "}" + " " + qidList2string(QIL) .
  eq qidList2string('`[ QIL) = "[" + " " + qidList2string(QIL) .
  eq qidList2string('`] QIL) = "]" + " " + qidList2string(QIL) .
  eq qidList2string('`, QIL) = "," + " " + qidList2string(QIL) .
  eq qidList2string(QI QIL) = string(QI) + " " + qidList2string(QIL) [owise] .
  eq qidList2string(nil) = "" .

  op string2qidList : String -> QidList .
  op string2qidListAux : String -> QidList .
  
  eq string2qidList(St) = trimQidList(string2qidListAux(St)) .
  
  eq string2qidListAux("") = nil .
  ceq string2qidListAux(St)
    = if F == notFound
      then qid(substr(St, findNonSpace(St), length(St))) 
      else qid(substr(St, findNonSpace(St), F)) 
           if substr(St, findNonSpace(St) + F, 1) =/= " "
           then qid(substr(St, findNonSpace(St) + F, 1))
           else nil
           fi 
           string2qidListAux(substr(St, findNonSpace(St) + F + 1, length(St)))
      fi
    if F := myfind(substr(St, findNonSpace(St), length(St)), " (){}[],", 0)
    [owise] .
  
  op findNonSpace : String -> Nat .
  op findNonSpace : String Nat -> Nat .
  ---- returns the length of the string if not found
  eq findNonSpace(St) = findNonSpace(St, 0) .

  eq findNonSpace(St, N)  
    = if N < length(St)
      then if substr(St, N, 1) == " " 
           then findNonSpace(St, N + 1)  
           else N
           fi 
      else length(St)
      fi .
      
  op myfind : String String Nat -> FindResult .
  eq myfind(St, St', N)
    = if N < length(St) 
      then if find(St', substr(St, N, 1), 0) =/= notFound
           then N
           else myfind(St, St', N + 1)
           fi
      else notFound 
      fi .
  
  op replace : QidList Qid Qid -> QidList .
  eq replace(QI QIL, QI', QI'') 
    = if QI == QI' 
      then QI'' replace(QIL, QI', QI'')
      else QI replace(QIL, QI', QI'')
      fi .
  eq replace(nil, QI, QI') = nil .
endfm

fmod HELP is
  pr EXT-QID-LIST .
  op fm-help : -> QidList .
  eq fm-help 
    = string2qidList("Additional commands available:") '\n
      '\t string2qidList("(load <meta-module> .)") '\n
      '\t '\t string2qidList("Takes as argument a term of sort Module,") '\s string2qidList("i.e.,") '\s string2qidList("a metaterm.") '\n
      '\t '`( 'remove 'identity 'attributes '\s '`[ '<module-expr.> '`] '\s  '. '`) '\s  '| '\s '`( 'rm 'ids '\s '`[ '<module-expr.> '`] '\s  '. '`) '\n
      '\t '\t string2qidList("Shows the module with the id attributes removed using a variant-based transformation.") '\n
      '\t string2qidList("(remove assoc attributes") '\s string2qidList("[<module-expr.>]") '\s string2qidList(".)") '\n
      '\t '\t string2qidList("Shows the module with the assoc (if not with comm) attributes removed using a variant-based transformation.") '\n
      '\t string2qidList("(ax coherence completion") '\s string2qidList("[<module-expr.>]") '\s string2qidList(".)") '\n
      '\t '\t string2qidList("Shows the module resulting from completing for coherence for the different combinations of axioms.") '\n .
endfm


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** 3.2 View Expressions and Extended Sorts

*** To allow the use of parameterized sorts, or sorts qualified by the view
*** expression with which the parameterized module in which the given sorts
*** appear is instantiated, we add the sort Sort of ``extended sorts'' as a
*** supersort of the predefined sort Sort.  View expressions and extended 
*** sorts are introduced in the following modules.

*** 3.2.1 View Expressions

*** A view expression is given by a single quoted identifier, by a sequence of
*** view expressions (at the user level, separated by commas), or by the
*** composition of view expressions. In the current version, the composition
*** of view expressions is only used internally; we plan to make it available
*** to the user with syntax \verb~_;_~ in the future. View expressions are
*** used in the instantiation of parameterized modules and in parameterized
*** sorts.  We plan to support parameterized views in the future as well. We 
*** use operators \verb~_|_~ and \verb~_;;_~ to represent, respectively, 
*** sequences and composition of view expressions.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW-EXPR is
  pr META-MODULE .

  sort ViewExp .
  subsorts Sort < ViewExp < ModuleExpression NeParameterList .

  op mtViewExp : -> ViewExp .
  op _{_} : Sort ParameterList -> ViewExp [ctor prec 37].
  op _;;_ : ViewExp ViewExp -> ViewExp 
       [assoc id: mtViewExp] .                       *** view composition  _;_
      
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Since the Core Maude engine does not know about view expressions, or, as
*** we shall see, about extended sorts, extended module expressions, extended
*** modules, and other declarations that we introduce, to be able to use them
*** with built-in functions such as \texttt{sameComponent},
*** \texttt{leastSort}, \texttt{metaReduce}, etc., we shall have to convert
*** them into terms which only use the built-in constructors.  Thus, for
*** example, view expressions in sort \texttt{ViewExp} will be converted
*** into quoted identifiers of sort \texttt{Qid} by means of function
*** \texttt{parameter2Qid}, or, similarly, elements of sorts \texttt{Sort},
*** \texttt{SortList}, and \texttt{SortSet} are transformed into elements
*** of sorts \texttt{Qid}, \texttt{QidList}, and  \texttt{QidSet},
*** respectively, with functions \texttt{eSortToQid} defined  on the 
*** appropriate sorts.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW-EXPR-TO-QID is
  pr VIEW-EXPR .
  pr EXT-QID-LIST .

  op viewExp2Qid : ViewExp -> Qid .
  op parameterList2Qid : ParameterList -> Qid .
  op viewExp2QidList : ViewExp -> QidList .
  op parameterList2QidList : ParameterList -> QidList .

  op eMetaPrettyPrint : ViewExp -> QidList .
  ceq eMetaPrettyPrint(VE) = viewExp2QidList(VE) if not VE :: TypeList .

  var  V : Sort .
  var  QI : Qid .
  var  QIL : QidList .
  var  P : ViewExp .
  var  PL : NeParameterList .
  vars VE VE' : ViewExp .

  eq parameterList2QidList(P) = viewExp2QidList(P) .
  ceq parameterList2QidList((P, PL))
    = (if QI == '`) then QIL QI '\s else QIL QI fi) 
      '`, parameterList2QidList(PL)
    if QIL QI := viewExp2QidList(P).

  eq viewExp2QidList(V{PL})
    = (viewExp2QidList(V) '`{ parameterList2QidList(PL) '`}) .
  ceq viewExp2QidList(VE ;; VE')
    = (viewExp2QidList(VE) '; viewExp2QidList(VE')) 
    if VE =/= mtViewExp /\ VE' =/= mtViewExp .
  eq viewExp2QidList(V) = V .
 
  eq parameterList2Qid(P) = viewExp2Qid(P) .
  eq parameterList2Qid((P, PL))
    = qid(string(viewExp2Qid(P)) + ", " + string(parameterList2Qid(PL))) .

  eq viewExp2Qid(VE) = qidList2Qid(viewExp2QidList(VE)) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parameterized Sorts
***

*** In addition to the \texttt{Sort} sort, in the following module
*** \texttt{EXT-SORT} we also define sorts \texttt{SortList} and 
*** \texttt{SortSet}.

*** The operator \texttt{eSort} is declared to be a constructor for extended 
*** sorts.

*** As for lists and sTS of quoted identifiers, we declare \verb~__~ and
*** \verb~_;_~ as constructors for sorts \texttt{SortList} and 
*** \texttt{SortList}, and \texttt{SortSet}, respectively.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-SORT is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr EXT-BOOL .
  pr VIEW-EXPR-TO-QID .
  pr EXT-QID-LIST .
  pr TERMSET .

*** We define operations extending the built-in functions \texttt{sameKind}
*** and \texttt{leastSort}, respectively, to lists of sorts and
*** to lists of extended terms. The function \texttt{sameKind} takes
*** a module and two lists of extended sorts as arguments, and returns
*** \texttt{true} if the $i$-th elements of both lists are in the same
*** connected component of sorts. This function will be used, for example, to
*** check whether two operators are in the same family of subsort overloaded
*** operators. \texttt{leastSort} returns a list of sorts where the $i$-th
*** element of the list is the least sort, computed by the homonymous built-in
*** function, of the $i$-th term in the list of terms given as argument.
*** Moreover, we define a function \verb~_in_~ to check whether an
*** extended sort is in a given set of extended sorts.  Note that before
*** calling the built-in function \texttt{sameComponent}, extended sorts of
*** sort \texttt{Sort} have to be `desugared' into sorts of sort
*** \texttt{Sort} as defined in the predefined \texttt{META-LEVEL} module.
*** This conversion is done by the \texttt{eTypeToType} function. Basically, 
*** user-defined sorts are converted into quoted identifiers by concatenating 
*** the list of identifiers composing the name of the sort. For example, sorts 
*** \texttt{'Nat} and \texttt{'List['Nat]} are converted, respectively, into 
*** \texttt{'Nat} and \texttt{'List`[Nat`]}. Error 
*** sorts~\cite{ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99} are left 
*** as such.

  vars Tp Tp' Tp'' Tp''' : Type .
  vars TpL TpL' : TypeList .
  var  M : Module .

  op sameKind : Module TypeList TypeList -> Bool [ditto] .
  eq sameKind(M, (Tp Tp' TpL), (Tp'' Tp''' TpL'))
    = sameKind(M, Tp, Tp'') 
      and-then sameKind(M, Tp' TpL, Tp''' TpL') .
  eq sameKind(M, nil, nil) = true .
  eq sameKind(M, TpL, TpL') = false [owise] .

  eq sameKind(M, cc(S:Sort ; SS:SortSet), Tp) 
    = sameKind(M, S:Sort, Tp) .
  eq sameKind(M, Tp, cc(S:Sort ; SS:SortSet)) 
    = sameKind(M, Tp, S:Sort) .
  eq sameKind(M, cc(S:Sort ; SS:SortSet), cc(S':Sort ; SS':SortSet)) 
    = sameKind(M, S:Sort, S':Sort) .

  op sameKindAll : Module Type TypeList -> Bool .
  eq sameKindAll(M, Tp, Tp' TpL) = sameKind(M, Tp, Tp') and-then sameKindAll(M, Tp, TpL) .
  eq sameKindAll(M, Tp, nil) = true .

  op eLeastSort : Module TermList ~> TypeList .
  eq eLeastSort(M, (T:Term, TL:TermList)) 
    = (leastSort(M, T:Term) eLeastSort(M, TL:TermList)) .
  eq eLeastSort(M, empty) = nil .
  eq eLeastSort(M, qidError(QIL)) = qidError(QIL) .

  op eLeastSort : Module TermSet ~> TypeSet .
  eq eLeastSort(M, (T:Term | TS:TermSet)) 
    = (leastSort(M, T:Term) ; eLeastSort(M, TS:TermSet)) .
  eq eLeastSort(M, emptyTermSet) = none .
  eq eLeastSort(M, qidError(QIL)) = qidError(QIL) .

  op qidError : QidList -> [Sort] .
  op stringError : QidList -> [String] .
  eq string(qidError(QIL)) = stringError(QIL) .
  eq qid(stringError(QIL)) = qidError(QIL) .
  eq stringError(QIL) + St:String = stringError(QIL) .

  op getMsg : [Sort] -> QidList .
  eq getMsg(qidError(QIL:QidList)) = QIL:QidList .

  op kind : TypeList -> Type .

  eq kind(S:Sort TL:TypeList) 
    = qid("[" + string(S:Sort) + "]") kind(TL:TypeList) .
  eq kind(K:Kind TL:TypeList) = K:Kind kind(TL:TypeList) .
  eq kind(nil) = nil .

  op kind : SortSet -> Type .
  eq kind(S:Sort ; SS:SortSet) = qid("[" + string(S:Sort) + "]") .

  op cc : SortSet -> Type .

  op getSort : Kind -> Sort .
  eq getSort(K:Kind) 
    = if findOut(string(K:Kind), "`,", "{", "}", 0) == notFound
      then qid(substr(string(K:Kind), 
                      2, 
                      sd(length(string(K:Kind)), 4)))
      else qid(substr(string(K:Kind), 
                      2, 
                      sd(findOut(string(K:Kind), "`,", "{", "}", 0), 2)))
      fi .

  op getSorts : Kind -> SortSet .
  eq getSorts(K:Kind) 
    = if findOut(string(K:Kind), "`,", "{", "}", 0) == notFound
      then qid(substr(string(K:Kind), 
                      2, 
                      sd(length(string(K:Kind)), 4)))
      else qid(substr(string(K:Kind), 
                      2, 
                      sd(findOut(string(K:Kind), "`,", "{", "}", 0), 2)))
           ;
           getSorts(qid("[" + substr(string(K:Kind), 
                                     sd(findOut(string(K:Kind), "`,", "{", "}", 0), 1),
                                     length(string(K:Kind)))))
      fi .

----  op qid2Sort : Sort -> Sort .
----  eq qid2Sort(S:Sort) = getName{S:Sort} { getPars(S:Sort) } .

  ---- name of a sort (the name of S{P1, ..., Pn} is S)
  op getName : Sort -> Qid .
  eq getName(S:Sort) 
    = if findOpening(string(S:Sort), "{", "}", sd(length(string(S:Sort)), 2))
           == notFound
      then S:Sort
      else qid(substr(string(S:Sort), 
                      0, 
                      findOpening(string(S:Sort), 
                        "{", "}", 
                        sd(length(string(S:Sort)), 2))))
      fi .

  ---- parameters of a sort (the parameters of S{P1, ..., Pn} are P1 ... Pn)
  op getPars : Sort -> ParameterList [memo] .
  op getParsAux : String Nat Nat -> ParameterList .

  eq getPars(S:Sort) 
    = if findOpening(string(S:Sort), "{", "}", sd(length(string(S:Sort)), 2))
           == notFound
      then empty
      else getParsAux(string(S:Sort), 
             findOpening(string(S:Sort), 
               "{", "}", sd(length(string(S:Sort)), 2)) + 1,
             length(string(S:Sort)))
      fi .

  var  St Pattern OpenPar ClosingPar : String .
  vars L R N OpenPars ClosingPars : Nat .

  eq getParsAux(St, L, R)
    = if findOut(St, ",", "{", "}", L) == notFound
      then qid(substr(St, L, sd(findClosing(St, "{", "}", L), L)))
      else (qid(substr(St, L, sd(findOut(St, ",", "{", "}", L), L))),
            getParsAux(St, findOut(St, ",", "{", "}", L) + 1, R))
      fi .

  ---- finds a pattern out of balanced parentheses 
  ---- findOut("S{P1, P2{P21, P22}, P3}", ",", "{", "}", 6) returns 18, not 12
  op findOut : String String String String Nat -> FindResult .
  op findOut : String String String String Nat Nat -> FindResult .

  eq findOut(St, Pattern, OpenPar, ClosingPar, N)
    = findOut(St, Pattern, OpenPar, ClosingPar, 0, N) .

  eq findOut(St, Pattern, OpenPar, ClosingPar, OpenPars, N)
    = if N >= length(St)
      then notFound
      else if OpenPars == 0 and-then substr(St, N, length(Pattern)) == Pattern
           then N
           else if substr(St, N, length(OpenPar)) == OpenPar
                then findOut(St, Pattern, OpenPar, ClosingPar, 
                       OpenPars + 1, N + 1)
                else if substr(St, N, length(ClosingPar)) == ClosingPar
                     then findOut(St, Pattern, OpenPar, ClosingPar, 
                            sd(OpenPars, 1), N + 1)
                     else findOut(St, Pattern, OpenPar, ClosingPar, 
                            OpenPars, N + 1)
                     fi
                fi
           fi
      fi .

  ---- finds the first closing unbalanced parenthesis 
  ---- findOut("P1, P2{P21, P22}, P3}", "{", "}", 6) returns 21, not 16
  op findClosing : String String String Nat -> FindResult .
  op findClosing : String String String Nat Nat -> FindResult .

  eq findClosing(St, OpenPar, ClosingPar, N)
    = findClosing(St, OpenPar, ClosingPar, 0, N) .

  eq findClosing(St, OpenPar, ClosingPar, OpenPars, N)
    = if N >= length(St)
      then notFound
      else if OpenPars == 0 
              and-then substr(St, N, length(ClosingPar)) == ClosingPar
           then N
           else if substr(St, N, length(OpenPar)) == OpenPar
                then findClosing(St, OpenPar, ClosingPar, 
                       OpenPars + 1, N + 1)
                else if substr(St, N, length(ClosingPar)) == ClosingPar
                     then findClosing(St, OpenPar, ClosingPar, 
                            sd(OpenPars, 1), N + 1)
                     else findClosing(St, OpenPar, ClosingPar, 
                            OpenPars, N + 1)
                     fi
                fi
           fi
      fi .

  ---- finds the last opening unbalanced parenthesis 
  ---- findOpening("S{P1, P2{P21, P22}, P3}", "{", "}", 21) returns 1, not 8
  op findOpening : String String String Nat -> FindResult .
  op findOpening : String String String Nat Nat -> FindResult .

  eq findOpening(St, OpenPar, ClosingPar, N)
    = findOpening(St, OpenPar, ClosingPar, 0, N) .

  eq findOpening(St, OpenPar, ClosingPar, ClosingPars, N)
    = if N == 0
      then notFound
      else if ClosingPars == 0 
              and-then substr(St, N, length(ClosingPar)) == OpenPar
           then N
           else if substr(St, N, length(OpenPar)) == ClosingPar
                then findOpening(St, OpenPar, ClosingPar, 
                       ClosingPars + 1, sd(N, 1))
                else if substr(St, N, length(ClosingPar)) == OpenPar
                     then findOpening(St, OpenPar, ClosingPar, 
                            sd(ClosingPars, 1), sd(N, 1))
                     else findOpening(St, OpenPar, ClosingPar, 
                            ClosingPars, sd(N, 1))
                     fi
                fi
           fi
      fi .

  op makeSort : Sort ParameterList -> Sort .
  op makeSort : Sort ParameterList ParameterList ParameterList -> Sort .
  op makeSort2 : Sort ParameterList -> Sort .
  op makePars : ParameterList -> String .

  vars S P : Sort .
  vars PL PL' PL'' PL3 : ParameterList .
  var  VE : ViewExp .
  var  QIL : QidList .
  var  K : Kind .

  eq makeSort(S, PL) 
    = if PL == empty 
      then S 
      else makeSort(S, PL, empty, empty) 
      fi .
  
  ----eq makeSort(S, P, PL, PL') = makeSort(S, empty, (PL, P), PL') .
  eq makeSort(S, (P, PL), PL', PL'') = makeSort(S, PL, (PL', P), PL'') .
  eq makeSort(S, (P{PL}, PL'), PL'', PL3) 
    = makeSort(S, PL', (PL'', makeSort(P, PL)), PL3) .
  ----eq makeSort(S, (P ;; VE), PL, PL') 
  ----  = makeSort(S, empty, (PL, P), (PL', VE)) 
  ----  [owise] .
  eq makeSort(S, ((P ;; VE), PL), PL', PL'') 
    = makeSort(S, PL, (PL', P), (PL'', VE)) 
    [owise] .
  eq makeSort(S, empty, PL, PL') 
    = if PL' == empty 
      then makeSort2(S, PL) 
      else makeSort(makeSort2(S, PL), PL') 
      fi .

  eq makeSort2(S, empty) = S:Sort .
  eq makeSort2(S, P) = qid(string(S) + "{" + string(P) + "}") .
  eq makeSort2(S, (P, PL)) 
    = qid(string(S) + "{" + string(P) + makePars(PL)) 
    [owise] .

  eq makePars((P, PL)) = "," + string(P) + makePars(PL) .
  eq makePars(P) = "," + string(P) + "}" .
  eq makePars(empty) = "}" .
  
  op list2set : TypeList -> TypeSet .
  eq list2set(Tp TpL) = Tp ; list2set(TpL) .
  eq list2set(nil) = none .
  
  op type2qid : Type -> Qid .
  eq type2qid(S) 
    = if getPars(S) == empty
      then S
      else qid(string(getName(S)) + "{" + string(qidList2Qid(parameterList2QidList(getPars(S)))) + "}")
      fi .
  eq type2qid(K) = qid("[" + string(type2qid(getSort(K))) + "]") .
  
  op size : TypeList -> Nat .
  eq size(Tp TpL) = 1 + size(TpL) .
  eq size((nil).TypeList) = 0 .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod DEFAULT-VALUE{X :: TRIV} is
  sort Default{X} .
  subsort X$Elt < Default{X} .
  op null : -> Default{X} .
endfm

view Term from TRIV to META-TERM is
  sort Elt to Term .
endv

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Extended Declarations
***

*** In this section we discuss modules \texttt{EXT-DECL} and \texttt{O-O-DECL}
*** which introduce, respectively, the declarations extending the sorts and
*** constructors for declarations of the predefined data type \texttt{Module}
*** in the \texttt{META-LEVEL} module to allow the use of extended sorts in
*** them, and the declarations appearing in object-oriented units, namely 
*** class declarations, subclass relation declarations, and message 
*** declarations.

***
*** Declarations of Functional and System Modules
***

*** In the following module \texttt{EXT-DECL}, we introduce the declarations
*** extending those in \texttt{META-LEVEL} to allow the use of extended sorts
*** in declarations of sorts, subsort relations, operators, variables, and 
*** membership axioms.

*** \begin{comment}
*** \footnote{In the future, the declarations for operators,
*** membership axioms, equations, and rules will be extended to allow
*** the use of extended sorts in sort tests, that is, terms of the
*** form \mbox{\verb~T : S~} and \mbox{\verb~T :: S~}.}
*** \end{comment}

*** The extension is accomplished by adding new supersorts for each of the
*** sorts in \texttt{META-LEVEL} involved, and by adding new constructors for 
*** these new sorts.

*** We start introducing the declarations for the supersorts and their 
*** corresponding constructors. The \texttt{EXT-DECL} module also contains the
*** declarations for sTS of such declarations.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod INT-LIST is 
  pr META-MODULE .
  pr INT .
  sort IntList .
  subsort Int NatList < IntList .
  op __ : IntList IntList -> IntList [ctor ditto] .

  op numberError : QidList -> [Nat] .

  vars N M : Nat .

  op from_to_list : Nat Nat ~> NatList .
  ceq from N to M list 
    = if N == M 
      then N 
      else N from N + 1 to M list 
      fi 
    if N <= M .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-DECL is
  pr EXT-SORT .
  pr INT-LIST .

  var  QI : Qid .
  vars QIL QIL' : QidList .
  var  At : Attr .
  var  AtS : AttrSet .
  var  OPD OPD' : OpDecl .
  var  OPDS : OpDeclSet .
  vars LHS RHS T T' : Term .
  var  S : Sort .
  var  Cond : Condition .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  MbS : MembAxSet .
  var  M : Module .

  op variant : -> Attr [ctor] .

*** subsort declarations error
  op subsortDeclError : QidList -> [SubsortDeclSet] [ctor format (r o)] .
  eq subsortDeclError(QIL) subsortDeclError(QIL') 
    = subsortDeclError(QIL QIL') .

*** extended attribute declarations 
  op strat : IntList -> Attr [ditto] .   *** to handle on-demand strategies
  op ditto : -> Attr [ctor] .
  
  op _in_ : Attr AttrSet -> Bool .
  eq At in At AtS = true .
  eq At in AtS = false [owise] .

*** extended operation declarations
  op opDeclError : QidList -> [OpDeclSet] [ctor format (r o)] .
  eq opDeclError(QIL) opDeclError(QIL') = opDeclError(QIL QIL') .

*** extended membership axioms 
  op membAxError : QidList -> [MembAxSet] [ctor format (r o)] .
  eq membAxError(QIL) membAxError(QIL') = membAxError(QIL QIL') .

*** extended equations
  op equationError : QidList -> [EquationSet] [ctor format (r o)] .
  eq equationError(QIL) equationError(QIL') = equationError(QIL QIL') .

*** extended rules
  op ruleError : QidList -> [RuleSet] [ctor format (r o)] .
  eq ruleError(QIL) ruleError(QIL') = ruleError(QIL QIL') .

*** The function \verb~_in_~ checks whether a given operator
*** declaration is in a set of operator declarations.

  op _in_ : OpDecl OpDeclSet -> Bool .

  eq OPD in (OPD OPDS) = true .
  eq OPD in OPDS = false [owise] .

  ops lhs rhs : Rule -> Term .
  op cond : Rule -> Condition .
  op atts : Rule -> AttrSet .
  op label : Rule -> [Qid] .
  eq lhs(rl LHS => RHS [AtS] .) = LHS .
  eq lhs(crl LHS => RHS if Cond [AtS] .) = LHS .
  eq rhs(rl LHS => RHS [AtS] .) = RHS .
  eq rhs(crl LHS => RHS if Cond [AtS] .) = RHS .
  eq cond(rl LHS => RHS [AtS] .) = nil .
  eq cond(crl LHS => RHS if Cond [AtS] .) = Cond .
  eq atts(rl LHS => RHS [AtS] .) = AtS .
  eq atts(crl LHS => RHS if Cond [AtS] .) = AtS .
  eq label(rl LHS => RHS [label(QI) AtS] .) = QI .
  eq label(crl LHS => RHS if Cond [label(QI) AtS] .) = QI .
  
  ops lhs rhs : Equation -> Term .
  op cond : Equation -> Condition .
  op atts : Equation -> AttrSet .
  op label : Equation -> [Qid] .
  eq lhs(eq LHS = RHS [AtS] .) = LHS .
  eq lhs(ceq LHS = RHS if Cond [AtS] .) = LHS .
  eq rhs(eq LHS = RHS [AtS] .) = RHS .
  eq rhs(ceq LHS = RHS if Cond [AtS] .) = RHS .
  eq cond(eq LHS = RHS [AtS] .) = nil .
  eq cond(ceq LHS = RHS if Cond [AtS] .) = Cond .
  eq atts(eq LHS = RHS [AtS] .) = AtS .
  eq atts(ceq LHS = RHS if Cond [AtS] .) = AtS .
  eq label(eq LHS = RHS [label(QI) AtS] .) = QI .
  eq label(ceq LHS = RHS if Cond [label(QI) AtS] .) = QI .
  
  op cond : MembAx -> Condition .
  op atts : MembAx -> AttrSet .
  eq cond(mb T : S [AtS] .) = nil .
  eq cond(cmb T : S if Cond [AtS] .) = Cond .
  eq atts(mb T : S [AtS] .) = AtS .
  eq atts(cmb T : S if Cond [AtS] .) = AtS .

  op rulify : EquationSet -> RuleSet .
  ---- takes a set of equations and turn them into rules
  eq rulify(eq LHS = RHS [AtS] . EqS) = (rl LHS => RHS [AtS] .) rulify(EqS) . 
  eq rulify(ceq LHS = RHS if Cond [AtS] . EqS) = (crl LHS => RHS if Cond [AtS] .) rulify(EqS) . 
  eq rulify((none).EquationSet) = none .
endfm

**** The module EXT-TERM extends META-LEVEL with definitions of several 
**** operations that manipulate terms: definitions for positions and operations
**** to get the subterm of a given term at a given position, to replace the
**** subterm of a term at a given position by another term, to get all the
**** nonvariable positions in a term, to apply a substitution to a term, and to
**** get a copy of a term in which all the variables in it have been renamed.

fmod EXT-TERM is
---  pr META-LEVEL + PRE-VARIANT .
  pr META-LEVEL .
  pr EXT-BOOL .
  pr EXT-DECL .

  vars T T' : Term .
  vars F X : Qid .
  var  TL : TermList .
  var  N : Nat .
  vars NL NL' : NatList .
  vars V V' W : Variable .
  var  Subst : Substitution .
  vars C Ct : Constant .
  var  NTL : NeTermList .
  var  M : Module .
  var  Tp : Type .
  vars TpL TpL' : TypeList .
  vars AtS AtS' : AttrSet .
  var  ODS : OpDeclSet .
  var  Cd : Condition .
  var  S : Sort .

  **** vars returns the set of variables in a term
  op vars : Term -> QidSet .
  op vars : TermList -> QidSet .

  eq vars(V) = V .
  eq vars(C) = none .
  eq vars(F[TL]) = vars(TL) .
  eq vars(empty) = none .
  eq vars((T, TL)) = vars(T) ; vars(TL) .

  **** varlist returns the list of variables in a term
  op varlist : Term -> QidList .
  op varlist : TermList -> QidList .

  eq varlist(V) = V .
  eq varlist(C) = nil .
  eq varlist(F[TL]) = varlist(TL) .
  eq varlist(empty) = nil .
  eq varlist((T, TL)) = varlist(T) varlist(TL) .

  **** occurs? checks whether a variable name occurs in a term or not.
  op occurs? : Variable Term -> Bool .
  op occurs? : Variable TermList -> Bool .
  eq occurs?(V, V') = V == V' .
  eq occurs?(V, C) = false .
  eq occurs?(V, F[TL]) = occurs?(V, TL) .
  eq occurs?(V, (T, TL)) = occurs?(V, T) or-else  occurs?(V, TL) .

  **** occurrences checks whether a variable name occurs in a term or not.
  op occurrences : Variable Term -> Nat .
  op occurrences : Variable TermList -> Nat .
  eq occurrences(V, V') = if V == V' then 1 else 0 fi .
  eq occurrences(V, C) = 0 .
  eq occurrences(V, F[TL]) = occurrences(V, TL) .
  eq occurrences(V, (T, TL)) = occurrences(V, T) + occurrences(V, TL) .

  op frozen : Module Term Nat -> Bool .
  op frozen : Module OpDeclSet Qid TypeList Nat -> Bool .
  eq frozen(M, F[TL], N) 
    = frozen(M, getOps(M), F, eLeastSort(M, TL), N) .
    
  ceq frozen(M, op F : TpL -> Tp [AtS] . ODS, F, TpL', N)
    = true
    if sameKind(M, TpL, TpL') 
       /\ not ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL') .
  ceq frozen(M, op F : TpL -> Tp [AtS] . ODS, F, TpL', N)
    = true
    if sameKind(M, TpL, TpL') 
       /\ ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL') 
       /\ frozen(NL N NL') AtS' := AtS .
  eq frozen(M, ODS, F, TpL, N) = false [owise] .

  ---- ctor check whether the operator at the top is a constructor
  ---- in any of its overloadings 
  op ctor : Module OpDeclSet Term -> Bool .
  op ctor : Module OpDeclSet Qid TypeList -> Bool .

  eq ctor(M, ODS, Ct) = ctor(M, ODS, Ct, nil) .
  eq ctor(M, ODS, F[TL]) = ctor(M, ODS, F, eLeastSort(M, TL)) .
  eq ctor(M, ODS, T) = false [owise] .

  ceq ctor(M, op F : TpL -> Tp [AtS] . ODS, F, TpL')
    = ctor in AtS or-else ctor(M, ODS, F, TpL') 
    if sameKind(M, TpL, TpL') .
  eq ctor(M, ODS, F, TpL) = false [owise] .

**** The function \texttt{substitute} takes a term $t$ and a substitution 
**** $\sigma$ and returns the term $t\sigma$. 

  op substitute : Module Term Substitution -> Term .
  op substitute : Module TermList Substitution -> TermList .

  eq substitute(M, T, none) = T .
  eq substitute(M, V, ((W <- T) ; Subst)) 
    = if getName(V) == getName(W) and-then sameKind(M, getType(V), getType(W)) 
      then T 
      else substitute(M, V, Subst) 
      fi .
  eq substitute(M, C, ((W <- T); Subst)) = C .
  eq substitute(M, F[TL], Subst) = F[substitute(M, TL, Subst)] .
  eq substitute(M, (T, TL), Subst)
    = (substitute(M, T, Subst), substitute(M, TL, Subst)) .

  op substitute : Module EqCondition Substitution -> EqCondition .
  eq substitute(M, T = T' /\ Cd, Subst) 
    = substitute(M, T, Subst) = substitute(M, T', Subst) /\ substitute(M, Cd, Subst) .
  eq substitute(M, T := T' /\ Cd, Subst) 
    = substitute(M, T, Subst) := substitute(M, T', Subst) /\ substitute(M, Cd, Subst) .
  eq substitute(M, T : S /\ Cd, Subst) 
    = substitute(M, T, Subst) : S /\ substitute(M, Cd, Subst) .
  eq substitute(M, (nil).EqCondition, Subst) = nil .
endfm

***(
red substitute('f['X:Foo, 'g['Y:Foo, 'Z:Foo]], ('Y:Foo <- 'h['W:Foo])) .
red rename('f['X:Foo, 'g['Y:Foo, 'Z:Foo]]) .
red allNonVarPos(
      substitute('f['X:Foo, 'g['Y:Foo, 'Z:Foo]], ('Y:Foo <- 'h['W:Foo]))) .
)

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Declarations for Object-Oriented Modules
***

*** In the \texttt{O-O-DECL} module we introduce the sorts and constructors
*** for declarations of classes, subclass relations, and messages in 
*** object-oriented units.

*** Note that we follow the same naming conventions for classes as for
*** extended sorts (see Section~\ref{parameterized-modules}), and therefore
*** we use the sort \texttt{Sort} for class identifiers, and
*** \texttt{TypeList} and \texttt{SortSet} for lists and sTS of class
*** identifiers, respectively.  We use the operator \verb~attr_:_~ as a
*** constructor for declarations of attributes. Since the operator name
*** \texttt{\_\,:\_\,} is used for sort  tests in the \texttt{META-LEVEL}
*** module, we use \texttt{attr\_\,:\_\,} as  constructor for declarations of
*** attributes to satisfy the preregularity  condition.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod O-O-DECL is
  pr EXT-SORT .

  vars QIL QIL' : QidList .

  sorts AttrDecl AttrDeclSet . 
  subsort AttrDecl < AttrDeclSet .
  op attr_:_ : Qid Sort -> AttrDecl .
  op none : -> AttrDeclSet .
  op _`,_ : AttrDeclSet AttrDeclSet -> AttrDeclSet [assoc comm id: none] .

  eq AD:AttrDecl, AD:AttrDecl = AD:AttrDecl .

  sorts ClassDecl ClassDeclSet . 
  subsort ClassDecl < ClassDeclSet .
  op class_|_. : Sort AttrDeclSet -> ClassDecl .
  op none : -> ClassDeclSet .
  op __ : ClassDeclSet ClassDeclSet -> ClassDeclSet [assoc comm id: none] .

  op classDeclError : QidList -> [ClassDeclSet] [ctor format (r o)] .
  eq classDeclError(QIL) classDeclError(QIL') = classDeclError(QIL QIL') .

  eq CD:ClassDecl CD:ClassDecl = CD:ClassDecl .

  sorts SubclassDecl SubclassDeclSet . 
  subsort SubclassDecl < SubclassDeclSet .
  op subclass_<_. : Sort Sort -> SubclassDecl .
  op none : -> SubclassDeclSet .
  op __ : SubclassDeclSet SubclassDeclSet -> SubclassDeclSet 
     [assoc comm id: none] .

  eq SCD:SubclassDecl SCD:SubclassDecl = SCD:SubclassDecl .

  op subclassDeclError : QidList -> [SubclassDeclSet] [ctor format (r o)] .
  eq subclassDeclError(QIL) subclassDeclError(QIL') 
    = subclassDeclError(QIL QIL') .

  sorts MsgDecl MsgDeclSet . 
  subsort MsgDecl < MsgDeclSet .
  op msg_:_->_. : Qid TypeList Sort -> MsgDecl .
  op none : -> MsgDeclSet .
  op __ : MsgDeclSet MsgDeclSet -> MsgDeclSet [assoc comm id: none] .

  eq MD:MsgDecl MD:MsgDecl = MD:MsgDecl .

  op msgDeclError : QidList -> [MsgDeclSet] [ctor format (r o)] .
  eq msgDeclError(QIL) msgDeclError(QIL') = msgDeclError(QIL QIL') .

*** The function \texttt{classSet} returns the set of class identifiers in
*** the set of class declarations given as argument.

  op classSet : ClassDeclSet -> SortSet .

  eq classSet((class S:Sort | ADS:AttrDeclSet .) CDS:ClassDeclSet) 
    = (S:Sort ; classSet(CDS:ClassDeclSet)) .
  eq classSet(none) = none .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Renaming Maps
***

*** We introduce the different types of renaming maps in the module
*** \texttt{FMAP} below. A sort is introduced for each of these types of maps,
*** with the appropriate constructors for each sort (see
*** Section~\ref{module-expressions}). All these sorts are declared to be
*** subsorts of the sort \texttt{Map}. A sort for sTS of 
*** maps (\texttt{RenamingSet}) is then declared as supersort of \texttt{Map} 
*** with constructors \texttt{none} and \verb~_,_~.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod FMAP is
  inc META-MODULE .
  pr EXT-SORT .

  *** renamings
  op class_to_ : Sort Sort -> Renaming .
  op attr_._to_ : Qid Sort Qid -> Renaming .
  op msg_to_ : Qid Qid -> Renaming .
  op msg_:_->_to_ : Qid TypeList Sort Qid -> Renaming .
  op op_to term_ : Term Term -> Renaming .

  op none : -> RenamingSet .
  eq (MAP, MAP) = MAP .
  eq (MAPS, none) = MAPS .

----  eq attr A . qidError(QIL) to A' = none .

*** Given a set of maps, the function \texttt{sortMaps} returns the
*** subset of sort maps in it.

  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars S S' A A' : Sort .
  var  QIL : QidList .

  op sortMaps : RenamingSet -> RenamingSet .

  eq sortMaps(sort S to S') = sort S to S' .
  eq sortMaps(((sort S to S'), MAPS))
    = ((sort S to S'), sortMaps(MAPS)) .
  eq sortMaps(MAP) = none [owise] .
  eq sortMaps((MAP, MAPS)) = sortMaps(MAPS) [owise] .
  eq sortMaps(none) = none .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Expressions and Module Names
***

*** The abstract syntax for writing specifications in Maude can be seen as
*** given by module expressions, where the notion of module expression is
*** understood as an expression that defines a new module out of previously
*** defined modules by combining and/or modifying them according to a specific
*** set of operations.  All module expressions will be evaluated generating
*** modules with such module expressions as names. In the case of parameterized
*** modules, each of the parameters in an interface will be used as the name
*** of a new module created as a renamed copy of the parameter theory.

***
*** Module Expressions
***

*** The \texttt{TUPLE} and \texttt{POWER} are declared to be new types of 
*** \texttt{ModuleExpression}s. 

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXPR is
  inc META-MODULE .
  pr FMAP .

  op TUPLE`[_`] : NzNat -> ModuleExpression .
  op POWER`[_`] : NzNat -> ModuleExpression .

  eq ME:ModuleExpression * ( none ) = ME:ModuleExpression .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Names
***

*** As we shall see in the coming sections, the evaluation of module
*** expressions may produce the creation of new modules, whose \emph{names}
*** are given by the module expressions themselves. If there is already a
*** module in the database with the module expression being evaluated as name,
*** the evaluation of such module expression does not produce any change in
*** the database. However, the evaluation of a module expression may involve 
*** the evaluation of some other module expressions contained in the modules 
*** involved, which in turn may generate new modules.

*** Given a parameterized module $\texttt{N\{L}_1\texttt{\ ::\ T}_1
*** \texttt{\ ,\ }\ldots\texttt{\ ,\ L}_n\texttt{\ ::\ T}_n\texttt{\}}$, with
*** $\texttt{L}_1\ldots\texttt{L}_n$ labels and
*** $\texttt{T}_1\ldots\texttt{T}_n$ theory identifiers, we say that
*** \texttt{N} is the name of the module and that
*** $\texttt{\{L}_1\texttt{\ ::\ T}_1\texttt{\ ,\ }
*** \ldots\texttt{\ ,\ L}_n\texttt{\ ::\ T}_n\texttt{\}}$ 
*** is its \emph{interface}.
*** As we shall see in Sections~\ref{instantiation} and~\ref{unit-processing},
*** for each parameter $\texttt{L}_i\texttt{\ ::\ T}_i$ in the interface of a
*** module, a new module is generated with such a parameter expression as its
*** name, and a declaration importing it in the parameterized module is added.
***  We regard the relationship between the body of a parameterized module and
*** the parameters in its interface, not as an inclusion, but as mediated by 
*** a module constructor that generates renamed copies of the parameters, 
*** which are then included. Therefore, the sort \texttt{ViewExp} is 
*** declared as a subsort of \texttt{Header}, that is, terms of sort 
*** \texttt{ViewExp} are considered to be module names. The constructor 
*** operator for the sort \texttt{ViewExp} is \verb~par_::_~.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-NAME is
  inc MOD-EXPR .
  pr EXT-BOOL .
  op parameterError : QidList -> [ParameterDecl] .

  sort ModuleName .
  subsorts ModuleExpression < ModuleName < Header .
  op _{_}  : ModuleExpression ParameterDeclList -> Header .
  op pd : ParameterDecl -> ModuleName .
  op nullHeader : -> Header .

  op getName : Header -> ModuleExpression .
  op getParDecls : Header -> ParameterDeclList .

  vars QI QI' : Qid .
  var  ME : ModuleExpression .
  vars PDL PDL' : ParameterDeclList .
  var  PL : NeParameterList .
  var  MN : ModuleName .

  eq getName(ME{PDL}) = ME .
  eq getName(MN) = MN .
  eq getParDecls(ME{PDL}) = PDL .
  eq getParDecls(MN) = nil .

  op including_. : ModuleName -> Import [ctor] .
  op extending_. : ModuleName -> Import [ctor] .
  op protecting_. : ModuleName -> Import [ctor] .

  op fth_is_sorts_.____endfth : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet -> FTheory [ctor gather (& & & & & & &)
     format (d d d n++i ni d d ni ni ni ni n--i d)] .
  op th_is_sorts_._____endth : Header ImportList SortSet SubsortDeclSet
    OpDeclSet MembAxSet EquationSet RuleSet -> STheory
    [ctor gather (& & & & & & & &)
     format (d d d n++i ni d d ni ni ni ni ni n--i d)] .

*** The function \texttt{labelInParameterDeclList} checks whether the quoted
*** identifier given as first argument is used as a label in the list of 
*** parameters given as second argument.

  op labelInParameterDeclList : Sort ParameterDeclList -> Bool .
  eq labelInParameterDeclList(QI, (PDL, (QI :: ME), PDL')) = true .
  eq labelInParameterDeclList(QI, PDL) = false [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Since the Core Maude engine assumes that module names are identifiers and
*** does not know about term-structured module names (such as parameterized
*** module interfaces or module expressions), for evaluation purposes we need
*** to transform them into quoted identifiers. The functions
*** \texttt{header2Qid} and \texttt{header2QidList} in the module
*** \texttt{MOD-NAME-TO-QID} below accomplish this transformation. In any
*** language extensions, new equations for the function
*** \texttt{header2QidList} should be added for each new module expression
*** constructor introduced. In Sections~\ref{renaming} and~\ref{instantiation} 
*** we shall see how the corresponding equalities are added for renaming and 
*** instantiation expressions, and in Section~\ref{extension} for other new 
*** module expressions in extensions of Full Maude.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-NAME-TO-QID is
  pr MOD-NAME .
  pr EXT-QID-LIST .

  op header2Qid : Header -> Qid .
  op header2QidList : Header -> QidList .
  op parameterDecl2Qid : ParameterDecl -> Qid .
  op parameterDecl2QidList : ParameterDecl -> QidList .
  op parameterDeclList2Qid : ParameterDeclList -> Qid .
  op parameterDeclList2QidList : ParameterDeclList -> QidList .

  vars QI X : Qid .
  var  QIL : QidList .
  vars ME ME' : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  PD : ParameterDecl .

  eq header2Qid(QI) = QI .
  eq header2Qid(nullHeader) = ' .
  eq header2Qid(pd(X :: ME)) = qidList2Qid(header2QidList(pd(X :: ME))) .
  eq header2QidList(pd(X :: ME)) = X ':: header2QidList(ME) .

  eq header2QidList(QI) = QI .
  eq header2QidList(nullHeader) = ' .

  eq header2Qid((ME { PDL })) = qidList2Qid(header2QidList((ME { PDL }))) .
  ceq header2QidList((ME { PDL })) 
    = (if QI == '\s then QIL else QIL QI fi 
       '`{ parameterDecl2QidList(PDL) '`} '\s) 
    if QIL QI := header2QidList(ME) .
 
  eq parameterDecl2Qid(X :: ME) = qidList2Qid(X ':: header2Qid(ME)) .

  eq parameterDeclList2Qid(PDL)
    = qidList2Qid(parameterDeclList2QidList(PDL)) .

  eq parameterDeclList2QidList(X :: ME) = X ':: header2QidList(ME) .
  eq parameterDeclList2QidList((X :: ME, PDL))
    = parameterDeclList2QidList(X :: ME) '`, parameterDeclList2QidList(PDL)
    [owise] .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Modules
***

*** We handle six different types of units: functional, system, and
*** object-oriented modules, and functional, system, and object-oriented
*** theories.  Modules and theories of any kind are considered to be elements
*** in specific subsorts of the sort \texttt{Module}. A constructor
*** \texttt{error} is also included to represent incorrect units.
*** \texttt{error} has a list of quoted identifiers as argument, which is
*** used to report the error. Besides considering functional and system
*** theories and object-oriented theories and modules, the declarations 
*** presented in the following module extend the declarations for sort 
*** \texttt{Module} in the \texttt{META-LEVEL} module in three different ways:

*** \begin{itemize}
*** \item the name of a module can be any term of sort \texttt{Header},
*** \item parameterized modules are handled, for which a list of
***       parameters is added to the constructors of modules,
*** \item the importation declaration is extended to module names, and
*** \item parameterized sorts are supported.  
*** \end{itemize}

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod UNIT is
  pr EXT-DECL .
  pr O-O-DECL .
  pr MOD-NAME-TO-QID .
---  inc META-LEVEL + PRE-VARIANT .
  inc META-LEVEL .

  op moduleName : Import -> ModuleName .
  eq moduleName(protecting MN .) = MN .
  eq moduleName(protecting ME{PL} .) = ME .
  eq moduleName(extending MN .) = MN .
  eq moduleName(extending ME{PL} .) = ME .
  eq moduleName(including MN .) = MN .
  eq moduleName(including ME{PL} .) = ME .

  op importError : QidList -> [ImportList] [ctor format (r o)] .
  eq importError(QIL) importError(QIL') = importError(QIL QIL') .

  sorts OModule OTheory .
  subsorts SModule < OModule < Module .
  subsorts STheory < OTheory < Module .

  op noModule : -> Module .   *** Module
  op unitError : QidList -> [Module] [ctor format (r o)] .
  op getMsg : [Module] -> QidList .
  eq getMsg(unitError(QIL)) = QIL .

  op omod_is_sorts_.________endom : Header ImportList
        SortSet SubsortDeclSet ClassDeclSet SubclassDeclSet OpDeclSet 
        MsgDeclSet MembAxSet EquationSet RuleSet -> OModule 
        [ctor 
         gather (& & & & & & & & & & &)
         format (r! o r! n++io ni d d ni ni ni ni ni ni ni ni n--ir! o)] .
  op oth_is_sorts_.________endoth : Header ImportList
        SortSet SubsortDeclSet ClassDeclSet SubclassDeclSet OpDeclSet 
        MsgDeclSet MembAxSet EquationSet RuleSet -> OTheory
        [ctor 
         gather (& & & & & & & & & & &)
         format (r! o r! n++io ni d d ni ni ni ni ni ni ni ni n--ir! o)] .

*** In addition to the constructor operators, the following functions are
*** introduced in the \texttt{UNIT} module:
*** \begin{itemize}
*** \item A function \verb~_in_~ to check whether a given importation
***       declaration is in a set of importation declarations or not.

  op _in_ : Import ImportList -> Bool .

*** \item Selector functions for the different components of a Module.

  op getName : Module -> Header .
  op getPars : Module -> ParameterDeclList .
  op getClasses : Module -> ClassDeclSet .
  op getSubclasses : Module -> SubclassDeclSet .
  op getMsgs : Module -> MsgDeclSet .

*** \item Functions to change the value of each of the components of a Module.

  op setName : Module ModuleExpression -> Module .
  op setName : Module ParameterDecl -> Module .
  op setPars : Module ParameterDeclList -> Module .
  op setImports : Module ImportList -> Module .
  op setSorts : Module SortSet -> Module .
  op setSubsorts : Module SubsortDeclSet -> Module .
  op setOps : Module OpDeclSet -> Module .
  op setMbs : Module MembAxSet -> Module .
  op setEqs : Module EquationSet -> Module .
  op setRls : Module RuleSet ~> Module .
  op setClasses : Module ClassDeclSet -> Module .
  op setSubclasses : Module SubclassDeclSet -> Module .
  op setMsgs : Module MsgDeclSet -> Module .

*** \item Functions to add new declarations to the set of declarations 
*** already in a unit.

  op addImports : ImportList Module -> Module .
  op addSorts : SortSet Module -> Module .
  op addSubsorts : [SubsortDeclSet] Module -> Module .
  op addOps : [OpDeclSet] Module -> Module .
  op addMbs : MembAxSet Module -> Module .
  op addEqs : EquationSet Module -> Module .
  op addRls : RuleSet Module -> Module .
  op addClasses : ClassDeclSet Module -> Module .
  op addSubclasses : SubclassDeclSet Module -> Module .
  op addMsgs : MsgDeclSet Module -> Module .

*** \item There are functions and constants to create empty modules of the
***       different types. For example, the function \texttt{emptyFTheory}
***       returns an empty functional theory. There is also a
***       function \texttt{empty} which takes a module as argument and returns 
***       an empty module of the same type.

  op emptyFModule : Header -> FModule .
  op emptyFModule : -> FModule .
  op emptySModule : -> SModule .
  op emptyOModule : -> OModule .
  op emptyFTheory : -> FModule .
  op emptySTheory : -> SModule .
  op emptyOTheory : -> OModule .
  op empty : Module -> Module .

*** \item A function \texttt{addDecls} which returns the module resulting from
***       adding all the declarations in the module passed as second argument 
***       to the module passed as first argument.
 
  op addDecls : Module Module -> Module .

*** \end{itemize}

*** Note that some of the `set' and `add' functions are partial functions.

  vars M M' M'' : Module .
  vars QI V : Qid .
  var  S : Sort .
  vars SSDS SSDS' SSDS'' : SubsortDeclSet .
  vars OPD OPD' : OpDecl .
  vars OPDS OPDS' : OpDeclSet .
  var  OPDS? : [OpDeclSet] .
  var  At : Attr .
  var  AtS : AttrSet .
  vars MAS MAS' MbS : MembAxSet .
  vars Eq Eq' : Equation .
  vars EqS EqS' : EquationSet .
  vars Rl Rl' : Rule .
  vars RlS RlS' : RuleSet .
  vars SS SS' : SortSet .
  vars IL IL' : ImportList .
  vars QIL QIL' : QidList .
  vars PL PL' : ParameterList .
  vars CDS CDS' : ClassDeclSet .
  vars SCD SCD' : SubclassDecl .
  vars SCDS SCDS' : SubclassDeclSet .
  vars U U' : Module .
  vars MDS MDS' : MsgDeclSet .
  vars I I' : Import .
  vars T T' T1 T1' T2 T2' : Term .
  vars ME ME' : ModuleExpression .
  vars PD PD' : ParameterDecl .
  vars PDL PDL' : ParameterDeclList .
  var  H : Header .
  vars MN MN' : ModuleName .
  var  Cd Cond Cond1 Cond2 : Condition .

  eq I in (IL I IL') = true .
  eq I in IL = false [owise] .

  op theory : Module -> Bool .
  eq theory(unitError(QIL)) = false .
  eq theory(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = false .
  eq theory(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = true .
  eq theory(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = false .
  eq theory(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth) = true .
  eq theory(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = false .
  eq theory(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = true .

*** Selection functions for units

  eq getName(unitError(QIL)) = ' .
  eq getName(noModule) = ' .
  eq getName(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = ME .
  eq getName(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = ME .
  eq getName(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = MN .
  ----eq getName(th PD is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = PD .
  eq getName(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm) = ME .
  eq getName(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = ME .
  eq getName(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth) = MN .
  eq getName(
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = ME .
  eq getName(
       omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = ME .
  eq getName(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = MN .

  eq getImports(unitError(QIL)) = nil .
  eq getImports(noModule) = nil .
  eq getImports(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = IL .
  eq getImports(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = IL .
  eq getImports(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = IL .
  eq getImports(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = IL .
  eq getImports(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = IL .
  eq getImports(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = IL .

  eq getPars(unitError(QIL)) = nil .
  eq getPars(noModule) = nil .
  eq getPars(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = nil .
  eq getPars(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = PDL .
  eq getPars(mod nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endm) 
    = nil .
  eq getPars(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = nil .
  eq getPars(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = nil .
  eq getPars(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm) = nil .
  eq getPars(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm) = PDL .
  eq getPars(fmod nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfm) = nil .
  eq getPars(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth) = nil .
  eq getPars(
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = nil .
  eq getPars(
        omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS 
        endom) 
    = PDL .
  eq getPars(
        omod nullHeader is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS 
        endom) 
    = nil .
  eq getPars(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = nil .

  eq getSorts(unitError(QIL)) = none .
  eq getSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = SS .
  eq getSorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = SS .
  eq getSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = SS .
  eq getSorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = SS .
  eq getSorts(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = SS .
  eq getSorts(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = SS .

  op getAllSorts : Module -> SortSet .
  eq getAllSorts(M) = getSorts(M) .

  eq getSubsorts(unitError(QIL)) = none .
  eq getSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = SSDS .
  eq getSubsorts(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = SSDS .
  eq getSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = SSDS .
  eq getSubsorts(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = SSDS .
  eq getSubsorts(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = SSDS .
  eq getSubsorts(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = SSDS .
   
  eq getOps(unitError(QIL)) = none .
  eq getOps(noModule) = none .
  eq getOps(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = OPDS .
  eq getOps(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = OPDS .
  eq getOps(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = OPDS .
  eq getOps(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = OPDS .
  eq getOps(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = OPDS .
  eq getOps(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = OPDS .
   
  eq getMbs(unitError(QIL)) = none .
  eq getMbs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = MAS .
  eq getMbs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = MAS .
  eq getMbs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = MAS .
  eq getMbs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = MAS .
  eq getMbs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = MAS .
  eq getMbs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = MAS .
   
  eq getEqs(unitError(QIL)) = none .
  eq getEqs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = EqS .
  eq getEqs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = EqS .
  eq getEqs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = EqS .
  eq getEqs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = EqS .
  eq getEqs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = EqS .
  eq getEqs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = EqS .
   
  eq getRls(unitError(QIL)) = none .
  eq getRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = RlS .
  eq getRls(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = RlS .
  eq getRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getRls(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getRls(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = RlS .
  eq getRls(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = RlS .
   
  eq getClasses(unitError(QIL)) = none .
  eq getClasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getClasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getClasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getClasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getClasses(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = CDS .
  eq getClasses(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = CDS .

  eq getSubclasses(unitError(QIL)) = none .
  eq getSubclasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getSubclasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getSubclasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getSubclasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getSubclasses(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = SCDS .
  eq getSubclasses(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = SCDS .

  eq getMsgs(unitError(QIL)) = none .
  eq getMsgs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm) = none .
  eq getMsgs(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth) = none .
  eq getMsgs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm) = none .
  eq getMsgs(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth) = none .
  eq getMsgs(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom) 
    = MDS .
  eq getMsgs(oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth) 
    = MDS .

*** Set functions

  eq setImports(unitError(QIL), IL) = unitError(QIL) .
  eq setImports(noModule, IL) = noModule .
  eq setImports(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, IL')
    = mod H is IL' sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setImports(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, IL')
    = th H is IL' sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setImports(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, IL')
    = fmod H is IL' sorts SS . SSDS OPDS MAS EqS endfm .
  eq setImports(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, IL')
    = fth H is IL' sorts SS . SSDS OPDS MAS EqS endfth .
  eq setImports(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, IL')
    = omod H is IL' sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setImports(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, IL')
    = oth H is IL' sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq setOps(unitError(QIL), OPDS) = unitError(QIL) .
  eq setOps(noModule, OPDS) = noModule .
  eq setOps(U, opDeclError(QIL) OPDS) = unitError(QIL) .
  eq setOps(unitError(QIL), opDeclError(QIL') OPDS) = unitError(QIL QIL') .
  eq setOps(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, OPDS')
    = mod H is IL sorts SS . SSDS OPDS' MAS EqS RlS endm .
  eq setOps(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, OPDS')
    = th MN is IL sorts SS . SSDS OPDS' MAS EqS RlS endth .
  eq setOps(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, OPDS')
    = fmod H is IL sorts SS . SSDS OPDS' MAS EqS endfm .
  eq setOps(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, OPDS')
    = fth MN is IL sorts SS . SSDS OPDS' MAS EqS endfth .
  eq setOps(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, 
       OPDS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS' MDS MAS EqS RlS endom .
  eq setOps(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, 
       OPDS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS' MDS MAS EqS RlS endoth .

  eq setSubsorts(unitError(QIL), SSDS) = unitError(QIL) .
  eq setSubsorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SSDS')
    = mod H is IL sorts SS . SSDS' OPDS MAS EqS RlS endm . 
  eq setSubsorts(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SSDS')
    = th MN is IL sorts SS . SSDS' OPDS MAS EqS RlS endth .
  eq setSubsorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SSDS')
    = fmod H is IL sorts SS . SSDS' OPDS MAS EqS endfm .
  eq setSubsorts(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, SSDS')
    = fth MN is IL sorts SS . SSDS' OPDS MAS EqS endfth .
  eq setSubsorts(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, 
       SSDS')
    = omod H is IL sorts SS . SSDS' CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setSubsorts(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, 
       SSDS')
    = oth MN is IL sorts SS . SSDS' CDS SCDS OPDS MDS MAS EqS RlS endoth . 

  eq setMbs(unitError(QIL), membAxError(QIL') MAS) = unitError(QIL QIL') .
  eq setMbs(unitError(QIL), MAS) = unitError(QIL) .
  eq setMbs(U, membAxError(QIL) MAS) = unitError(QIL) .
  eq setMbs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, MAS')
    = mod H is IL sorts SS . SSDS OPDS MAS' EqS RlS endm .
  eq setMbs(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MAS')
    = th MN is IL sorts SS . SSDS OPDS MAS' EqS RlS endth .
  eq setMbs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, MAS')
    = fmod H is IL sorts SS . SSDS OPDS MAS' EqS endfm .
  eq setMbs(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, MAS')
    = fth MN is IL sorts SS . SSDS OPDS MAS' EqS endfth .
  eq setMbs(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, MAS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS' EqS RlS endom .
  eq setMbs(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, MAS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS' EqS RlS endoth .

  eq setEqs(unitError(QIL), EqS) = unitError(QIL) .
  eq setEqs(U, equationError(QIL) EqS?:[EquationSet]) = unitError(QIL) .
  eq setEqs(unitError(QIL), equationError(QIL') EqS?:[EquationSet]) 
    = unitError(QIL QIL') .
  eq setEqs(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, EqS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS' RlS endm .
  eq setEqs(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, EqS')
    = th MN is IL sorts SS . SSDS OPDS MAS EqS' RlS endth .
  eq setEqs(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, EqS')
    = fmod H is IL sorts SS . SSDS OPDS MAS EqS' endfm .
  eq setEqs(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, EqS')
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS' endfth .
  eq setEqs(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, EqS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS' RlS endom .
  eq setEqs(
       oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, EqS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS' RlS endoth .

  var U? : [Module] .
  var RlS? : [RuleSet] .

  eq setRls(unitError(QIL), RlS?) = unitError(QIL) .
  eq setRls(U?, ruleError(QIL) RlS?) = unitError(QIL) .
  eq setRls(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, RlS')
    = mod H is IL sorts SS . SSDS OPDS MAS EqS RlS' endm .
  eq setRls(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, RlS')
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS' endth .
  eq setRls(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, RlS)
    = if RlS == none 
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      fi .
  eq setRls(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, RlS)
    = if RlS == none 
      then fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth
      else th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      fi .
  eq setRls(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       RlS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS' endom .
  eq setRls(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       RlS')
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS' endoth .

  eq setSorts(unitError(QIL), SS) = unitError(QIL) .
  eq setSorts(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SS')
    = mod H is IL sorts SS' . SSDS OPDS MAS EqS RlS endm .
  eq setSorts(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SS')
    = th MN is IL sorts SS' . SSDS OPDS MAS EqS RlS endth .
  eq setSorts(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SS')
    = fmod H is IL sorts SS' . SSDS OPDS MAS EqS endfm .
  eq setSorts(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, SS')
    = fth MN is IL sorts SS' . SSDS OPDS MAS EqS endfth .
  eq setSorts(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, SS')
    = omod H is IL sorts SS' . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setSorts(
        oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, SS')
    = oth MN is IL sorts SS' . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq setPars(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm, PDL)
    = if PDL == nil
      then mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm 
      fi .
  eq setPars(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm, PDL')
    = if PDL' == nil 
      then mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else mod ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS RlS endm 
      fi .
  eq setPars(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, PDL)
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setPars(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm, PDL)
    = if PDL == nil 
      then fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm
      else fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm 
      fi .
  eq setPars(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm, PDL')
    = if PDL' == nil 
      then fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm
      else fmod ME{PDL'} is IL sorts SS . SSDS OPDS MAS EqS endfm 
      fi .
  eq setPars(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, PDL)
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setPars(
        omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, 
        PDL)
    = if PDL == nil
      then omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom
      else omod ME{PDL} is 
             IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS 
           endom 
      fi .
  eq setPars(
       omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, 
       PDL')
    = if PDL' == nil  
      then omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom
      else omod ME{PDL'} is 
             IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS 
           endom 
      fi .
  eq setPars(
        oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, 
        PDL)
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .

  eq setClasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, CDS)
    = if CDS == none
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else omod H is IL sorts SS . SSDS CDS none OPDS none MAS EqS none endom 
      fi .
  eq setClasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, CDS)
    = if CDS == none
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else oth H is IL sorts SS . SSDS CDS none OPDS none MAS EqS none endoth 
      fi .
  eq setClasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, CDS)
    = if CDS == none
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else omod H is IL sorts SS . SSDS CDS none OPDS none MAS EqS RlS endom 
      fi .
  eq setClasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, CDS)
    = if CDS == none
      then th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else oth H is IL sorts SS . SSDS CDS none OPDS none MAS EqS RlS endoth 
      fi .
  eq setClasses(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, 
        CDS')
    = omod H is IL sorts SS . SSDS CDS' SCDS OPDS MDS MAS EqS RlS endom .
  eq setClasses(
        oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, 
        CDS')
    = oth H is IL sorts SS . SSDS CDS' SCDS OPDS MDS MAS EqS RlS endoth .
  eq setClasses(M, CDS) 
    = unitError(header2QidList(getName(M)) 'not 'an 'object-oriented 'module) 
    [owise] .

  eq setSubclasses(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, SCDS)
    = if SCDS == none 
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else omod H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS none endom 
      fi .
  eq setSubclasses(fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, SCDS)
    = if SCDS == none 
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else oth H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS none endoth
      fi .
  eq setSubclasses(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, SCDS)
    = if SCDS == none 
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else omod H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS RlS endom 
      fi .
  eq setSubclasses(th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, SCDS)
    = if SCDS == none 
      then th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else oth H is IL sorts SS . SSDS none SCDS OPDS none MAS EqS RlS endoth
      fi .
  eq setSubclasses(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, SCDS')
    = omod H is IL sorts SS . SSDS CDS SCDS' OPDS MDS MAS EqS RlS endom .
  eq setSubclasses(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       SCDS')
    = oth H is IL sorts SS . SSDS CDS SCDS' OPDS MDS MAS EqS RlS endoth .
  eq setSubclasses(M, SCDS) 
    = unitError(header2QidList(getName(M)) 'not 'an 'object-oriented 'module) 
    [owise] .

  eq setMsgs(
       fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, MDS)
    = if MDS == none 
      then fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm
      else omod H is IL sorts SS . SSDS none none OPDS MDS MAS EqS none endom 
      fi .
  eq setMsgs(
       fth H is IL sorts SS . SSDS OPDS MAS EqS endfth, MDS)
    = if MDS == none 
      then fth H is IL sorts SS . SSDS OPDS MAS EqS endfth
      else oth H is IL sorts SS . SSDS none none OPDS MDS MAS EqS none endoth 
      fi .
  eq setMsgs(
       mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, MDS)
    = if MDS == none 
      then mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm
      else omod H is IL sorts SS . SSDS none none OPDS MDS MAS EqS RlS endom 
      fi .
  eq setMsgs(
       th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MDS)
    = if MDS == none 
      then th H is IL sorts SS . SSDS OPDS MAS EqS RlS endth
      else oth H is IL sorts SS . SSDS none none OPDS MDS MAS EqS RlS endoth 
      fi .
  eq setMsgs(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, MDS')
    = omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS' MAS EqS RlS endom .
  eq setMsgs(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, MDS')
    = oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS' MAS EqS RlS endoth .
  eq setMsgs(M, MDS) 
    = unitError(header2QidList(getName(M)) 'not 'an 'object-oriented 'module) 
    [owise] .

  eq setName(mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME') 
    = mod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME') 
    = mod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm, ME') 
    = fmod ME' is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm, ME') 
    = fmod ME'{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, MN') 
    = fth MN' is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setName(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MN') 
    = th MN' is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setName(omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, ME') 
    = omod ME' is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setName(omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, ME') 
    = omod ME'{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setName(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, MN') 
    = oth MN' is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setName(noModule, ME) = noModule .
  eq setName(unitError(QIL), ME) = unitError(QIL) .

  eq setName(mod nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endm, ME') 
    = mod ME' is IL sorts SS . SSDS OPDS MAS EqS RlS endm .
  eq setName(fmod nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfm, ME') 
    = fmod ME' is IL sorts SS . SSDS OPDS MAS EqS endfm .
  eq setName(fth nullHeader is IL sorts SS . SSDS OPDS MAS EqS endfth, MN) 
    = fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth .
  eq setName(th nullHeader is IL sorts SS . SSDS OPDS MAS EqS RlS endth, MN) 
    = th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth .
  eq setName(
       omod nullHeader is 
         IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS 
       endom, 
       ME') 
    = omod ME' is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom .
  eq setName(
       oth nullHeader is 
         IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, 
       MN) 
    = oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth .
  eq setName(noModule, ME) = noModule .
  eq setName(unitError(QIL), ME) = unitError(QIL) .

*** Add functions

  eq addSorts(SS, U) = setSorts(U, (SS ; getSorts(U))) .
  eq addSorts(SS, unitError(QIL)) = unitError(QIL) .

  eq addSubsorts(SSDS, U) = setSubsorts(U, (SSDS getSubsorts(U))) .
  eq addSubsorts(subsortDeclError(QIL), U) = unitError(QIL) .
  eq addSubsorts(SSDS, unitError(QIL)) = unitError(QIL) .
  
  eq addOps(OPDS, U) = setOps(U, (OPDS getOps(U))) .
  eq addOps(OPDS?, unitError(QIL)) = unitError(QIL) .
  eq addOps(OPDS?, U) = U [owise] .

  eq addMbs(MAS, U) = setMbs(U, (MAS getMbs(U))) .
  eq addMbs(MAS, unitError(QIL)) = unitError(QIL) .
  eq addEqs(EqS, U) = setEqs(U, (EqS getEqs(U))) .
  eq addEqs(EqS, unitError(QIL)) = unitError(QIL) .
  eq addRls(RlS, U) = setRls(U, (RlS getRls(U))) .
  eq addRls(RlS, unitError(QIL)) = unitError(QIL) .
  eq addRls(ruleError(QIL), U) = unitError(QIL) .
  eq addImports(IL, U) = setImports(U, (getImports(U) IL)) .
  eq addImports(IL, unitError(QIL)) = unitError(QIL) .
  eq addClasses(CDS, U) = setClasses(U, (getClasses(U) CDS)) .
  eq addClasses(CDS, unitError(QIL)) = unitError(QIL) .
  eq addSubclasses(SCDS, U) = setSubclasses(U, (getSubclasses(U) SCDS)) .
  eq addSubclasses(SCDS, unitError(QIL)) = unitError(QIL) .
  eq addMsgs(MDS, U) = setMsgs(U, (getMsgs(U) MDS)) .
  eq addMsgs(MDS, unitError(QIL)) = unitError(QIL) .

*** Creation of empty units

  eq emptyFModule(ME) 
    = fmod header2Qid(ME) is nil sorts none . none none none none endfm .
  eq emptyFModule 
    = fmod nullHeader is nil sorts none . none none none none endfm .
  eq emptySModule
    = mod nullHeader is nil sorts none . none none none none none endm . 
  eq emptyOModule
    = omod nullHeader is 
        nil sorts none . none none none none none none none none
      endom . 
  eq emptyFTheory
    = fth nullHeader is nil sorts none . none none none none endfth .
  eq emptySTheory
    = th nullHeader is nil sorts none . none none none none none endth .
  eq emptyOTheory
    = oth nullHeader is
         nil sorts none . none none none none none none none none
      endoth .

*** \texttt{empty} returns an empty unit of the same type of the one given as 
*** argument.
  
  eq empty(mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = (mod H is nil sorts none . none none none none none endm) .
  eq empty(th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = (th MN is nil sorts none . none none none none none endth) .
  eq empty(fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = (fmod H is nil sorts none . none none none none endfm) .
  eq empty(fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = (fth MN is nil sorts none . none none none none endfth) .
  eq empty(omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = (omod H is 
         nil sorts none . none none none none none none none none 
       endom) .
  eq empty(oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = (oth MN is 
         nil sorts none . none none none none none none none none 
       endoth) .

*** In the following \texttt{addDecls} function, the declarations of the unit
*** given as second argument are added to the unit given as first argument.

  eq addDecls(noModule, U) = U .
  eq addDecls(U, noModule) = U .
  eq addDecls(unitError(QIL), U) = unitError(QIL) .
  eq addDecls(U, unitError(QIL)) = unitError(QIL) .
  eq addDecls(U, U')
    = addImports(getImports(U'),
        addSorts(getSorts(U'),
          addSubsorts(getSubsorts(U'),
            addOps(getOps(U'),
              addMbs(getMbs(U'),
                addEqs(getEqs(U'), 
                  if U' :: FModule or U' :: FTheory
                  then U
                  else addRls(getRls(U'), 
                         if U' :: SModule or U' :: STheory
                         then U
                         else addClasses(getClasses(U'),
                                addSubclasses(getSubclasses(U'),
                                  addMsgs(getMsgs(U'), U)))
                         fi)
                  fi))))))
    [owise] .

  op removeNonExecs : Module -> Module .
  op removeNonExecs : MembAxSet -> MembAxSet .
  op removeNonExecs : EquationSet -> EquationSet .
  op removeNonExecs : RuleSet -> RuleSet .

  ceq removeNonExecs(M)
    = setRls(M'', removeNonExecs(getRls(M)))
    if M' := setMbs(M, removeNonExecs(getMbs(M)))
    /\ M'' := setEqs(M', removeNonExecs(getEqs(M))) .
  eq removeNonExecs(unitError(QIL)) = unitError(QIL) .

  eq removeNonExecs(mb T : S [nonexec AtS] . MbS) = removeNonExecs(MbS) .
  eq removeNonExecs(cmb T : S if Cd [nonexec AtS] . MbS) = removeNonExecs(MbS) .
  eq removeNonExecs(MbS) = MbS [owise] .

  eq removeNonExecs(eq T = T' [nonexec AtS] . EqS) = removeNonExecs(EqS) .
  eq removeNonExecs(ceq T = T' if Cd [nonexec AtS] . EqS) = removeNonExecs(EqS) .
  eq removeNonExecs(EqS) = EqS [owise] .

  eq removeNonExecs(rl T => T' [nonexec AtS] . RlS) = removeNonExecs(RlS) .
  eq removeNonExecs(crl T => T' if Cd [nonexec AtS] . RlS) = removeNonExecs(RlS) .
  eq removeNonExecs(RlS) = RlS [owise] .

  *** moreGeneralEqs  ******************************
  ---- An equation is more general than other if there is a substitution such that 
  ---- the more general equation with such a substitution applied is equal to the 
  ---- less general one. 
  op moreGeneralEqs : Module -> Module .
  op moreGeneralRls : Module -> Module .
  op $moreGeneralEqs : Module Module EquationSet EquationSet -> Module .
  op $moreGeneralRls : Module Module RuleSet RuleSet -> Module .
  op $moreGeneral : Module Equation Equation -> Bool .
  op $moreGeneral : Module Rule Rule -> Bool .
  op $moreGeneral : Module Condition Condition Term Term -> Bool .

  eq moreGeneralEqs(M) 
    = $moreGeneralEqs(
        M, 
        addOps((op '@/\@ : '@@@ '@@@ -> '@@@ [assoc] .
                op '@--@ : 'Universal -> '@@@ [poly(1)] .
                op '@--@ : 'Universal 'Universal -> '@@@ [poly(1 2)] .), 
               addSorts('@@@, M)), 
        getEqs(M), getEqs(M)) .
  eq moreGeneralRls(M) 
    = $moreGeneralRls(
        M, 
        addOps((op '@/\@ : '@@@ '@@@ -> '@@@ [assoc] .
                op '@--@ : 'Universal -> '@@@ [poly(1)] .
                op '@--@ : 'Universal 'Universal -> '@@@ [poly(1 2)] .), 
               addSorts('@@@, M)), 
        getRls(M), getRls(M)) .

 ceq $moreGeneralEqs(M, M', Eq EqS, Eq Eq' EqS') 
    = $moreGeneralEqs(M, M', EqS, Eq' EqS')
    if $moreGeneral(M', Eq', Eq) .
  eq $moreGeneralEqs(M, M', EqS, EqS') = setEqs(M, EqS') [owise] .
  
 ceq $moreGeneralRls(M, M', Rl RlS, Rl Rl' RlS') 
    = $moreGeneralRls(M, M', RlS, Rl' RlS')
    if $moreGeneral(M', Rl', Rl) .
  eq $moreGeneralRls(M, M', RlS, RlS') = setRls(M, RlS') [owise] .
  
  eq $moreGeneral(M, Eq, Eq') 
    = sameKind(M, leastSort(M, lhs(Eq)), leastSort(M, lhs(Eq')))
      and-then
      $moreGeneral(M, cond(Eq), cond(Eq'), '@--@[lhs(Eq), rhs(Eq)], '@--@[lhs(Eq'), rhs(Eq')]) .
      
  eq $moreGeneral(M, Rl, Rl') 
    = sameKind(M, leastSort(M, lhs(Rl)), leastSort(M, lhs(Rl')))
      and-then
      $moreGeneral(M, cond(Rl), cond(Rl'), '@--@[lhs(Rl), rhs(Rl)], '@--@[lhs(Rl'), rhs(Rl')]) .
      
  eq $moreGeneral(M, T1 = T1' /\ Cond1, T2 = T2' /\ Cond2, T, T') 
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1, T1'], T], '@/\@['@--@[T2, T2'], T']) .
  eq $moreGeneral(M, T1 := T1' /\ Cond1, T2 := T2' /\ Cond2, T, T') 
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1, T1'], T], '@/\@['@--@[T2, T2'], T']) .
  eq $moreGeneral(M, T1 => T1' /\ Cond1, T2 => T2' /\ Cond2, T, T') 
    = sameKind(M, leastSort(M, T1), leastSort(M, T2))
      and-then
      $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1, T1'], T], '@/\@['@--@[T2, T2'], T']) .
  eq $moreGeneral(M, T1 : S /\ Cond1, T2 : S /\ Cond2, T, T') 
    = $moreGeneral(M, Cond1, Cond2, '@/\@['@--@[T1], T], '@/\@['@--@[T2], T']) .
      
  eq $moreGeneral(M, nil, nil, T, T') = metaMatch(M, T, T', nil, 0) =/= noMatch .
  eq $moreGeneral(M, Cond1, Cond2, T, T') = false [owise] .

  op rmVariantAttrs : Module -> Module .
  op $rmVariants : EquationSet -> EquationSet .
  op $rmVariants : RuleSet -> RuleSet .
  op $rmVariants : MembAxSet -> MembAxSet .
  eq rmVariantAttrs(M) = setRls(setEqs(setMbs(M, $rmVariants(getMbs(M))), $rmVariants(getEqs(M))), $rmVariants(getRls(M))) .
  eq rmVariantAttrs(unitError(QIL)) = unitError(QIL) .   
  
  eq $rmVariants(eq T = T' [variant AtS] . EqS) = (eq T = T' [variant AtS] .) $rmVariants(EqS) .
  eq $rmVariants(ceq T = T' if Cond [variant AtS] . EqS) = (ceq T = T' if Cond [variant AtS] .) $rmVariants(EqS) .
  eq $rmVariants(EqS) = EqS [owise] .
  
  eq $rmVariants(rl T => T' [variant AtS] . RlS) = (rl T => T' [variant AtS] .) $rmVariants(RlS) .
  eq $rmVariants(crl T => T' if Cond [variant AtS] . RlS) = (crl T => T' if Cond [variant AtS] .) $rmVariants(RlS) .
  eq $rmVariants(RlS) = RlS [owise] .
  
  eq $rmVariants(mb T : S [variant AtS] . MbS) = (mb T : S [variant AtS] .) $rmVariants(MbS) .
  eq $rmVariants(cmb T : S if Cond [variant AtS] . MbS) = (cmb T : S if Cond [variant AtS] .) $rmVariants(MbS) .
  eq $rmVariants(MbS) = MbS [owise] .
endfm

-------------------------------------------------------------------------------

fmod AX-COHERENCE-COMPLETION is 
  inc UNIT .
----  inc MODULE-HANDLING * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .

  vars V W : Variable .
  var  C : Constant .
  var  FM : FModule .
  var  SM : SModule .
  var  M : Module .
  var  N : Nat .
  vars T T' T'' LHS RHS : Term .
  vars Subst Subst' : Substitution .
  var  F : Qid .
  var  TL : TermList .
  vars AtS AtS' : AttrSet .
----  var  VFS : VariantFourSet .
  vars Tp Tp' Tp'' : Type .
  var  TpL : TypeList .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  Cond : Condition .
  var  QIL : QidList .

  ------------------------------------------------------------------------------
  ---- coherence completion
  ------------------------------------------------------------------------------
  
  op axCohComplete : SModule -> SModule .
  op axCohComplete : SModule OpDeclSet RuleSet -> RuleSet .
  op axCohCompleteAux : SModule OpDeclSet RuleSet -> RuleSet .
  op axCohComplete : SModule Type AttrSet Rule -> RuleSet .
  op axCohComplete : SModule OpDeclSet EquationSet -> EquationSet .
  op axCohCompleteAux : SModule OpDeclSet EquationSet -> EquationSet .
  op axCohComplete : SModule Type AttrSet Equation -> EquationSet .
    
  eq axCohComplete(FM) 
    = moreGeneralEqs(setEqs(FM, axCohComplete(FM, getOps(FM), getEqs(FM)))) .
  eq axCohComplete(SM) 
    = moreGeneralEqs(
        moreGeneralRls(
          setRls(
            setEqs(SM, 
              axCohComplete(SM, getOps(SM), getEqs(SM))), 
            axCohComplete(SM, getOps(SM), getRls(SM))))) 
    [owise] .
  eq axCohComplete(unitError(QIL)) = unitError(QIL) .  
  
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, rl F[TL] => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc AtS, rl F[TL] => RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, RlS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, crl F[TL] => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc AtS, crl F[TL] => RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, RlS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, RlS) = axCohCompleteAux(M, ODS, RlS) [owise] .
    
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, rl LHS => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc id(T) AtS, rl F[LHS] => RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, crl LHS => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc id(T) AtS, crl F[LHS] => RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, rl LHS => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, rl F[LHS] => RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, crl LHS => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, crl F[LHS] => RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, rl LHS => RHS [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, rl F[LHS] => RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, crl LHS => RHS if Cond [AtS'] . RlS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, crl F[LHS] => RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, RlS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  eq axCohCompleteAux(M, ODS, RlS) = RlS [owise] .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, eq F[TL] = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, ceq F[TL] = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, EqS) = axCohCompleteAux(M, ODS, EqS) [owise] .
    
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, eq LHS = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc id(T) AtS, eq F[LHS] = RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, ceq LHS = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc id(T) AtS, ceq F[LHS] = RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, eq LHS = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, eq F[LHS] = RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, ceq LHS = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc left-id(T) AtS, ceq F[LHS] = RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc left-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, eq LHS = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, eq F[LHS] = RHS [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  ceq axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, ceq LHS = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc right-id(T) AtS, ceq F[LHS] = RHS if Cond [AtS'] .)
      axCohCompleteAux(M, op F : Tp Tp' -> Tp'' [assoc right-id(T) AtS] . ODS, EqS)
    if sameKindAll(M, Tp, leastSort(M, LHS)) .
  eq axCohCompleteAux(M, ODS, EqS) = EqS [owise] .

  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, eq F[TL] = RHS [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  ceq axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, ceq F[TL] = RHS if Cond [AtS'] . EqS)
    = axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
      axCohComplete(M, op F : Tp Tp' -> Tp'' [assoc AtS] . ODS, EqS)
    if sameKind(M, Tp, Tp')
    /\ sameKind(M, Tp', Tp'')
    /\ sameKindAll(M, Tp, eLeastSort(M, TL)) .
  eq axCohComplete(M, ODS, eq LHS = RHS [AtS] . EqS) 
    = eq LHS = RHS [AtS] . axCohComplete(M, ODS, EqS) 
    [owise] . 
  eq axCohComplete(M, ODS, ceq LHS = RHS if Cond [AtS] . EqS) 
    = ceq LHS = RHS if Cond [AtS] . axCohComplete(M, ODS, EqS) 
    [owise] . 
  eq axCohComplete(M, ODS, (none).EquationSet) = none . 
    
  ---- Given f(t1,...,tn) -> r if C
  ---- if f AC add f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL] => RHS [AtS'] .)
      (rl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    [owise] . 
  eq axCohComplete(M, Tp, assoc comm AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL] => RHS if Cond [AtS'] .)
      (crl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    [owise] . 
  ---- if f ACU replace by f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .) . 
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL, qid("X@@@:" + string(getKind(M, Tp)))] => getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) . 
  ---- if f AU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) 
    if not comm in AtS . 
  ceq axCohComplete(M, Tp, assoc id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) 
    if not comm in AtS . 
  ---- if f ALU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)  . 
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)  . 
  ---- if f ARU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (rl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) . 
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (crl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) . 
  ---- if f A add f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----            f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  ----            f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc AtS, rl F[TL] => RHS [AtS'] .)
    = (rl F[TL] => RHS [AtS'] .) 
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) 
      (rl F[qid("X@@@:" + string(getKind(M, Tp))), TL] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .) 
      (rl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) 
    if not comm in AtS 
    [owise] . 
  ceq axCohComplete(M, Tp, assoc AtS, crl F[TL] => RHS if Cond [AtS'] .)
    = (crl F[TL] => RHS if Cond [AtS'] .) 
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) 
      (crl F[qid("X@@@:" + string(getKind(M, Tp))), TL] 
         => getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .) 
      (crl F[TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         => getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) 
    if not comm in AtS 
    [owise] . 

  ---- Given f(t1,...,tn) -> r if C
  ---- if f AC add f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL] = RHS [AtS'] .)
      (eq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
    [owise] . 
  eq axCohComplete(M, Tp, assoc comm AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL] = RHS if Cond [AtS'] .)
      (ceq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
    [owise] . 
  ---- if f ACU replace by f(t1,...,tn,x:[s]) -> f(r,x:[s]) if C
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) [AtS'] .) . 
  eq axCohComplete(M, Tp, assoc comm id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL, qid("X@@@:" + string(getKind(M, Tp)))] = getTerm(metaNormalize(M, F[RHS, qid("X@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) . 
  ---- if f AU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) 
    if not comm in AtS . 
  ceq axCohComplete(M, Tp, assoc id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) 
    if not comm in AtS . 
  ---- if f ALU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .)  . 
  eq axCohComplete(M, Tp, assoc left-id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .)  . 
  ---- if f ARU replace by f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----             and add f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .)
      (eq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) . 
  eq axCohComplete(M, Tp, assoc right-id(T) AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .)
      (ceq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) . 
  ---- if f A add f(x:[s],t1,...,tn,y:[s]) -> f(x:[s],r,y:[s]) if C
  ----            f(x:[s],t1,...,tn) -> f(x:[s],r) if C
  ----            f(t1,...,tn,y:[s]) -> f(r,y:[s]) if C
  ceq axCohComplete(M, Tp, assoc AtS, eq F[TL] = RHS [AtS'] .)
    = (eq F[TL] = RHS [AtS'] .) 
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) 
      (eq F[qid("X@@@:" + string(getKind(M, Tp))), TL] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) [AtS'] .) 
      (eq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) [AtS'] .) 
    if not comm in AtS 
    [owise] . 
  ceq axCohComplete(M, Tp, assoc AtS, ceq F[TL] = RHS if Cond [AtS'] .)
    = (ceq F[TL] = RHS if Cond [AtS'] .) 
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) 
      (ceq F[qid("X@@@:" + string(getKind(M, Tp))), TL] 
         = getTerm(metaNormalize(M, F[qid("X@@@:" + string(getKind(M, Tp))), RHS])) if Cond [AtS'] .) 
      (ceq F[TL, qid("Y@@@:" + string(getKind(M, Tp)))] 
         = getTerm(metaNormalize(M, F[RHS, qid("Y@@@:" + string(getKind(M, Tp)))])) if Cond [AtS'] .) 
    if not comm in AtS 
    [owise] . 
endfm

*** To parse some input using the built-in function \texttt{metaParse}, we
*** need to give the metarepresentation of the signature in which the input is 
*** going to be parsed.

*** But we do not need to give the complete metarepresentation of such a
*** module. In modules including \texttt{META-LEVEL} it is possible to define 
*** terms of sort \texttt{Module} that import built-in modules or any module 
*** introduced at the ``object level'' of Core Maude. In this way, it is 
*** possible to get the equivalent effect of having the explicit 
*** metarepresentation of a module by declaring a constant and adding an 
*** equation identifying such a constant with the metarepresentation of an 
*** extended module that imports the original module at the object level.

*** The declaration of constructors for bubble sorts at the object level is 
*** not supported in the current version of Core Maude. The \texttt{special} 
*** attributes linking the constructors for the bubble sorts to the built-in 
*** ones are only supported at the metalevel, that is, the declarations of the 
*** constructor operators for bubble sorts have to be given in the 
*** metarepresentation of a module.

*** To allow the greatest generality and flexibility in future extensions of
*** Full Maude, we have declared its signature as a module
*** \texttt{FULL-MAUDE-SIGN}. Then, in the following module 
*** \texttt{META-FULL-MAUDE-SIGN} we declare a constant \texttt{GRAMMAR} of 
*** sort \texttt{FModule}, and we give an equation identifying such constant 
*** with the metarepresentation of a module \texttt{GRAMMAR} in which there is 
*** a declaration importing \texttt{FULL-MAUDE-SIGN}. Declarations for the 
*** constructors of the bubble sorts are also included in this module. Note 
*** that the bubble sorts \texttt{@Token@}, \texttt{@Bubble@}, 
*** \texttt{@SortToken@}, and \texttt{@NeTokenList@} are declared in the 
*** module \texttt{SIGN\&VIEW-EXPR}, which is imported by 
*** \texttt{FULL-MAUDE-SIGN}. These sorts are used in the declarations 
*** describing the syntax of the system.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod META-FULL-MAUDE-SIGN is
---  including META-LEVEL + PRE-VARIANT .
  including META-LEVEL .
  including UNIT .

  op BUBBLES : -> FModule .
  op GRAMMAR : -> FModule [memo] .

  eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@ 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> '@ViewToken@ 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'sortToken : 'Qid -> '@SortToken@ 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ': '|
                                  'ditto 'precedence 'prec 'gather
                                  'assoc 'associative 'comm 'commutative 
                                  'ctor 'constructor 'id: 'strat 'strategy 
                                  'poly 'memo 'memoization 'iter 'frozen
                                  'config 'object 'msg 'metadata 'nonexec 'variant)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@ 
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        op 'bubble : 'QidList -> '@Bubble@ 
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        none
        none
     endfm) .
     
  eq GRAMMAR = addImports((including 'FULL-MAUDE-SIGN .), BUBBLES) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------


*** The \texttt{GRAMMAR} module will be used in calls to the \texttt{metaParse}
*** function in order to get the input parsed in this signature. Note that
*** this module is not the data type in which we shall represent the inputs.
*** From the call to \texttt{metaParse} we shall get a term representing the
*** parse tree of the input. This term will then be transformed into terms of 
*** other appropriate data types if necessary.

*** Future extensions to Full Maude will require extending the signature as
*** well. The addition of new commands, new module expressions, or additions
*** of any other kind will require adding new declarations to the present Full
*** Maude signature and defining the corresponding extensions to the data
*** types and functions to deal with the new cases introduced by the
*** extensions. 

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{View}
***

*** In this section we present the data type \texttt{View} for views.
*** Basically, the data elements of sort \texttt{View} are composed by the
*** name of the view, the names of the source and target units, and a set of
*** maps representing the maps asserting how the given target unit is claimed 
*** to satisfy the source theory (see Section~\ref{Views}).

*** Internally, renaming maps are considered to be a particular case of view
*** maps. The sort \texttt{ViewMap} is declared as a supersort of
*** \texttt{Map}. The only kind of maps in sort \texttt{ViewMap} not in sort
*** \texttt{Map} are maps of operators going to derived operators. We start
*** introducing the declarations for renaming maps and sTS of renaming maps
*** in Section~\ref{renaming-maps}, we then introduce view maps and sTS of
*** view maps in Section~\ref{view-maps}, and finally we introduce the sort 
*** \texttt{View}, its constructor, and some operations on it in 
*** Section~\ref{viewADT}.

***
*** View Maps
***

*** In addition to the maps of sort \texttt{Renaming}, 
*** in views there can also be maps from operators to derived
*** operators, that is, terms with variables (see Section~\ref{Views}). Maps
*** of this kind are given with the constructor \texttt{op_to`term_}, which, in
*** addition to the source and target terms, takes the set of variable
*** declarations for the variables used in the map. The source term must be of
*** the form $\texttt{F(X}_1\texttt{,}\ldots,\texttt{X}_n\texttt{)}$, where
*** \texttt{F} is an operator name declared with $n$ arguments of sorts in the
*** connected components of the variables $\texttt{X}_1\ldots\texttt{X}_n$,
*** respectively. We will see in Section~\ref{view-processing} how in the 
*** initial processing of a view the variables declared in it are associated 
*** to each of the maps in which they are used.


***
*** Views
***

*** The \texttt{View} sort is introduced in the following module
*** \texttt{VIEW}.  In addition to the constructor for views (\texttt{view}),
*** selector functions are added for each of the components of a
*** view (\texttt{name}, \texttt{source}, \texttt{target}, and 
*** \texttt{mapSet}), and a constant \texttt{emptyView}, which is identified 
*** in an equation with the empty view, is defined.

*** Although the declaration of the constructor for views includes an argument
*** for the list of parameters, parameterized views are not handled yet, so at
*** present this argument must be set to the \texttt{nil}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-RENAMING is
  pr META-MODULE .

  op op_to term_ : Term Term -> Renaming . 
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW is
  ex META-VIEW .
  pr VIEW-EXPR .
  inc FMAP .

  *** mappings
  op class_to_. : Sort Sort -> SortMapping .
  op attr_._to_. : Qid Sort Qid -> OpMapping .
  op msg_to_. : Qid Qid -> OpMapping .
  op msg_:_->_to_. : Qid TypeList Sort Qid -> OpMapping .

  subsort ViewExp < Header .

  op null : -> View [ctor] .
  op viewError : QidList -> [View] [ctor format (r o)] .

  eq VE{(nil).ParameterDeclList} = VE .

  vars A A' F F' Q Q' : Qid .
  var QIL : QidList .
  var VH : Header .
  var VE : ViewExp .
  vars PDL PDL' : ParameterDeclList .
  vars ME ME' ME'' : ModuleExpression .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars S S' C : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  vars T T' : Term .
  
  op maps2rens : SortMappingSet -> RenamingSet .
  op maps2rens : OpMappingSet -> RenamingSet .
  eq maps2rens(sort S to S' . SMS) = sort S to S', maps2rens(SMS) .
  eq maps2rens(class S to S' . SMS) = class S to S', maps2rens(SMS) .
  eq maps2rens((none).SortMappingSet) = none .
  
  eq maps2rens(op F to F' . OMS) = op F to F' [none], maps2rens(OMS) .
  eq maps2rens(op F : TyL -> Ty to F' . OMS) = op F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(op T to  term T' . OMS) = op T to term T', maps2rens(OMS) .
  eq maps2rens(msg F to F' . OMS) = msg F to F' [none], maps2rens(OMS) .
  eq maps2rens(msg F : TyL -> Ty to F' . OMS) = msg F : TyL -> Ty to F' [none], maps2rens(OMS) .
  eq maps2rens(attr A . C to A' . OMS) = attr A . C to A', maps2rens(OMS) .
  eq maps2rens((none).OpMappingSet) = none .

*** projection functions
  op getName : View -> Qid .
  eq getName(view VE from ME to ME' is SMS OMS endv) = VE [owise] .
  eq getName(view VE{PDL} from ME to ME' is SMS OMS endv) = VE .

  op getPars : [View] -> ParameterDeclList .
  eq getPars(view VE from ME to ME' is SMS OMS endv) = nil [owise] .
  eq getPars(view VE{PDL} from ME to ME' is SMS OMS endv) = PDL .
  eq getPars(viewError(QIL)) = nil .
  
  eq getFrom(view VH from ME to ME' is SMS OMS endv) = ME .
  eq getTo(view VH from ME to ME' is SMS OMS endv) = ME' .
  eq getSortMappings(view VH from ME to ME' is SMS OMS endv) = SMS .
  eq getOpMappings(view VH from ME to ME' is SMS OMS endv) = OMS .

*** injection functions
  op setName : View Qid -> View .
  eq setName(view Q from ME to ME' is SMS OMS endv, Q') 
    = view Q' from ME to ME' is SMS OMS endv .
  eq setName(view Q{PDL} from ME to ME' is SMS OMS endv, VH) = view VH{PDL} from ME to ME' is SMS OMS endv .
  eq setName(viewError(QIL), VE) = viewError(QIL) .

  op setPars : [View] ParameterDeclList -> [View] .
  eq setPars(view VH from ME to ME' is SMS OMS endv, PDL) 
    = view VH{PDL} from ME to ME' is SMS OMS endv [owise] .
  eq setPars(view VH{PDL} from ME to ME' is SMS OMS endv, PDL') = view VH{PDL'} from ME to ME' is SMS OMS endv .
  eq setPars(viewError(QIL), PDL) = viewError(QIL) .

  op setFrom : View ModuleExpression -> View .
  eq setFrom(view VH from ME to ME' is SMS OMS endv, ME'') 
    = view VH from ME'' to ME' is SMS OMS endv .
  eq setFrom(viewError(QIL), ME) = viewError(QIL) .

  op setTo : View ModuleExpression -> View .
  eq setTo(view VH from ME to ME' is SMS OMS endv, ME'') 
    = view VH from ME to ME'' is SMS OMS endv .
  eq setTo(viewError(QIL), ME) = viewError(QIL) .

  op setSortMappings : View SortMappingSet -> View .
  eq setSortMappings(view VH from ME to ME' is SMS OMS endv, SMS') 
    = view VH from ME to ME' is SMS' OMS endv .
  eq setSortMappings(viewError(QIL), SMS') = viewError(QIL) .

  op setOpMappings : View OpMappingSet -> View .
  eq setOpMappings(view VH from ME to ME' is SMS OMS endv, OMS') 
    = view VH from ME to ME' is SMS OMS' endv .
  eq setOpMappings(viewError(QIL), OMS') = viewError(QIL) .

  op emptyView : Qid ModuleExpression ModuleExpression -> View .
  eq emptyView(VH, ME, ME') = view VH from ME to ME' is none none endv .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Abstract Data Type \texttt{Database}
***

*** In this section we present the data type \texttt{Database}, which will be
*** used to store information about the units and views in the system. Before
*** discussing this data type in Section~\ref{databaseADT}, we present the
*** predefined units added in Full Maude to those already available in Core 
*** Maude.

*** 
*** Non-Built-In Predefined Modules
***

*** As we shall see in the following section, except for the
*** \texttt{LOOP-MODE} module, all the predefined modules that are available
*** in Core Maude are also available in Full Maude. In addition to these Core
*** Maude predefined modules, in Full Maude there are some additional
*** predefined units. In the present system, the only units with which the
*** database is initialized are the functional theory \texttt{TRIV}, the
*** module \texttt{CONFIGURATION}, and the module \texttt{UP}, which will be 
*** used to evaluate the \texttt{up} functions. We shall see in 
*** Section~\ref{main-module} how new predefined modules can be added to the 
*** initial database.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PREDEF-UNITS is
  pr UNIT .

*** The following module \texttt{UP} contains the necessary declarations to
*** be able to parse the \texttt{up} functions presented in
*** Section~\ref{structured-specifications}. We shall see in
*** Section~\ref{evaluation} how a declaration importing the following module
*** \texttt{UP} is added to all the modules importing the predefined module
*** \texttt{META-LEVEL}. With this declaration, it is possible to parse the
*** \texttt{up} commands in the bubbles of such modules or in commands being 
*** evaluated in such modules. We shall see in Section~\ref{bubble-parsing} 
*** how these commands are then evaluated.

  op #UP# : -> FModule [memo] .
  eq #UP#
    = (fmod '#UP# is
        including 'QID-LIST .
        including 'MOD-EXPRS .
        sorts none .
        none
        op 'upTerm : '@ModExp@ '@Bubble@ -> 'Term [none] .
        op 'upModule : '@ModExp@ -> 'Module [none] .
        op '`[_`] : '@Token@ -> 'Module [none] .
        op 'token : 'Qid -> '@Token@ 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> '@ViewToken@ 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'sortToken : 'Qid -> '@SortToken@ 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to '`, '. '`( '`) '`{ '`} ':
                                  'ditto 'precedence 'prec 'gather
                                  'assoc 'associative 'comm 'commutative 
                                  'ctor 'constructor 'id: 'strat 'strategy 
                                  'poly 'memo 'memoization 'iter 'frozen
                                  'config 'object 'msg 'metadata 'nonexec 'variant)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@ 
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        op 'bubble : 'QidList -> '@Bubble@ 
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        none
        none
     endfm) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** 7 The Evaluation of Views
***

*** Before being entered into the database, besides containing bubbles, views
*** have a somewhat different structure from that of the views given in
*** Section~\ref{viewADT}. We introduce in the following module a sort
*** \texttt{PreView} with constructor \texttt{view}, which is declared as the
*** constructor for views of sort \texttt{View}, but with an additional
*** argument, namely, a set of variable declarations to hold the declarations
*** of variables in the view. During the processing of views (see
*** Section~\ref{view-processing}), which takes place once the parsing process 
*** has concluded, these variables are associated with the corresponding maps 
*** where they are used, generating a term of sort \texttt{View}.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod PRE-VIEW is
  pr VIEW .

  sort PreView .
  op preview_from_to_is___endpv : Header ModuleExpression 
       ModuleExpression OpDeclSet SortMappingSet OpMappingSet -> PreView
       [ctor format (nir! o r! o r! o r! o o o r! o)] .
  op null : -> PreView .

  op getName : PreView -> ViewExp .
  op getPars : PreView -> ParameterDeclList .
  op getFrom : PreView -> ModuleExpression .
  op getTo : PreView -> ModuleExpression .
  op getVars : PreView -> OpDeclSet .
  op getSortMappings : PreView -> SortMappingSet .
  op getOpMappings : PreView -> OpMappingSet .

  var  QI : Qid .
  vars ME ME' : ModuleExpression .
  var  VE : ViewExp .
  var  VH : Header .
  vars PDL PDL' : ParameterDeclList .
  vars VDS VDS' : OpDeclSet .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .

  eq getName(preview VE from ME to ME' is VDS SMS OMS endpv) = VE .
  eq getName(preview VE{PDL} from ME to ME' is VDS SMS OMS endpv) = VE .
  eq getPars(preview VE from ME to ME' is VDS SMS OMS endpv) = nil .
  eq getPars(preview VE{PDL} from ME to ME' is VDS SMS OMS endpv) = PDL .
  eq getFrom(preview VH from ME to ME' is VDS SMS OMS endpv) = ME .
  eq getTo(preview VH from ME to ME' is VDS SMS OMS endpv) = ME' .
  eq getVars(preview VH from ME to ME' is VDS SMS OMS endpv) = VDS .
  eq getSortMappings(preview VH from ME to ME' is VDS SMS OMS endpv) = SMS .
  eq getOpMappings(preview VH from ME to ME' is VDS SMS OMS endpv) = OMS .

*** The following functions can be used to add new declarations to the set of
*** declarations already in a preview.

  op addMaps : SortMappingSet PreView -> PreView .
  op addMaps : OpMappingSet PreView -> PreView .
  op addVars : OpDeclSet PreView -> PreView .

  eq addMaps(SMS, preview VH from ME to ME' is VDS SMS' OMS endpv) 
    = preview VH from ME to ME' is VDS (SMS SMS') OMS endpv .
  eq addMaps(OMS, preview VH from ME to ME' is VDS SMS OMS' endpv) 
    = preview VH from ME to ME' is VDS SMS (OMS OMS') endpv .

  eq addVars(VDS, preview VH from ME to ME' is VDS' SMS OMS endpv) 
    = preview VH from ME to ME' is (VDS VDS') SMS OMS endpv .

  op setPars : PreView ParameterDeclList -> PreView .
  eq setPars(preview VE from ME to ME' is VDS SMS OMS endpv, PDL) 
    = preview VE{PDL} from ME to ME' is VDS SMS OMS endpv .
  eq setPars(preview VE{PDL} from ME to ME' is VDS SMS OMS endpv, PDL')
    = preview VE{PDL'} from ME to ME' is VDS SMS OMS endpv .

  op emptyPreView : Qid ModuleExpression ModuleExpression -> PreView .
  eq emptyPreView(QI, ME, ME') 
    = preview QI from ME to ME' is none none none endpv .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Database
***

*** In order to be able to refer to modules by name, which is extremely useful
*** for module definition purposes at the user level, the evaluation of module
*** expressions takes place in the context of a database, in which we keep
*** information about the modules already introduced in the system, and also
*** about those modules generated internally.  This information is stored as
*** a set of elements of sort \texttt{ModuleInfo} and \texttt{ViewInfo}, in
*** which we hold, respectively, the information concerning units and views. 
*** For each unit we save: 
*** \begin{itemize} 
*** \item Its original form, as introduced by the user, or, in case of an 
***       internally generated unit, as generated from the original form of 
***       some other unit.  
*** \item Its internal representation, in which variables have been renamed 
***       to avoid collisions with the names of variables in other units in 
***       the same hierarchy.  In the case of object-oriented units, we store 
***       its equivalent system module, that is, the result of transforming 
***       it into a system module.  
*** \item Its signature, which is given as a functional module of sort 
***       \texttt{FModule} with no axioms, ready to be used in calls to 
***       \texttt{metaParse}. There can only be importation declarations 
***       including built-in modules in this module. These are the only 
***       inclusions handled by the Core Maude engine.  
*** \item Its flattened version, for which, as for signatures, only the 
***       importation of built-in modules is left unevaluated.  
*** \end{itemize} 
*** For each view we keep its name and the view itself.

*** As a simple mechanism to keep the database consistent, for each unit we
*** maintain the list of names of all the units and views ``depending'' on it.
*** Similarly, for each view we maintain the list of names of all the units
*** ``depending'' on it. The idea is that if a unit or view is redefined or
*** removed, all those units and/or views depending on it will also be
*** removed. This dependency does not only mean direct importation. For
*** example, the module resulting from the renaming of some module also
*** depends on the module being renamed; the instantiation of a parameterized
*** module also depends on the parameterized module and on all the views used
*** in its instantiation; a view depends on its source and target units, etc.
*** This dependency is transitive: if a module, theory, or view has to be
*** removed, all the units and/or views depending on them will be removed as
*** well. The dependencies derived from the module expressions themselves are
*** established by the function \texttt{setUpModExpDeps}. The function
*** \texttt{setUpModuleDeps} calls \texttt{setUpModExpDeps}, 
*** and then \texttt{setUpImportSetDeps} to add the \emph{back 
*** references} in the modules being imported. The function 
*** \texttt{setUpViewDeps} sTS up the back references for the views 
*** being introduced.

*** In addition to this set of information cells for units and views, we also
*** keep lists with the names of all the units and views in the database, and
*** a list of quoted identifiers in which we store the messages generated
*** during the process of treatment of the inputs in order to simplify the 
*** communication with the read-eval-print loop process.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view ModuleName from TRIV to MOD-NAME is
  sort Elt to ModuleName .
endv

view ViewExp from TRIV to VIEW-EXPR is
  sort Elt to ViewExp .
endv

view ParameterDecl from TRIV to META-MODULE is
  sort Elt to ParameterDecl .
endv

fmod INFO is
  pr VIEW .
  pr DEFAULT-VALUE{Term} .
  pr (SET * (op _`,_ to _._, 
             op empty to emptyModuleNameSet, 
             op insert to insertModuleNameSet,
             op delete to deleteModuleNameSet,
             op _in_ to _inModuleNameSet_,
             op |_| to |_|ModuleNameSet,
             op $card to $cardModuleNameSet,
             op union to unionModuleNameSet,
             op intersection to intersectionModuleNameSet,
             op $intersect to $intersectModuleNameSet,
             op _\_ to _\ModuleNameSet_,
             op $diff to $diffModuleNameSet,
             op _subset_ to _subsetModuleNameSet_,
             op _psubset_ to _psubsetModuleNameSet_)){ModuleName} .
  pr (SET * (op _`,_ to _#_, 
             op empty to emptyViewExpSet, 
             op insert to insertViewExpSet,
             op delete to deleteViewExpSet,
             op _in_ to _inViewExpSet_,
             op |_| to |_|ViewExprSet,
             op $card to $cardViewExprSet,
             op union to unionViewExprSet,
             op intersection to intersectionViewExprSet,
             op $intersect to $intersectViewExprSet,
             op _\_ to _\ViewExprSet_,
             op $diff to $diffViewExprSet,
             op _subset_ to _subsetViewExprSet_,
             op _psubset_ to _psubsetViewExprSet_)){ViewExp} .
  pr (SET * (op _`,_ to _._)){ParameterDecl} .

  var  MN : ModuleName .
  var  MNS : Set{ModuleName} .

  op remove : Set{ModuleName} ModuleName -> Set{ModuleName} .
  eq remove(MN . MNS, MN) = remove(MNS, MN) .
  eq remove(MNS, MN) = MNS [owise] .

  sort ModuleInfo .
  op <_;_;_;_;_;_;_;_> : ModuleName Default{Term} Module Module Module 
       OpDeclSet Set{ModuleName} Set{ViewExp} -> ModuleInfo
     [ctor
      format 
        (nig o g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_;_;_;_> : ModuleName Module Module Module Module  
       OpDeclSet Set{ModuleName} Set{ViewExp} -> ModuleInfo
     [ctor
      format 
      (nig ur! g n+++io g nio g nio g nio g nio g nio g nio n---ig o)] .

  *** - Modules can be introduced by the user or can be generated internally.
  ***   When introduced by the user the 2nd arg. keeps the term representation 
  ***   of the module as given, so that it can be recompiled later. If the 
  ***   module is generated internally as the result of the evaluation of a 
  ***   module expression, then this second arg. will be null, the default 
  ***   term value. The user can also enter modules with the procModule 
  ***   function, providing then the metarepresentation of a module, which 
  ***   is directly stored in the database as the 2nd arg. of one of these 
  ***   ModuleInfo units of the second kind. This is useful for the ITP for 
  ***   example, where the interaction with the database takes place at the
  ***   metalevel and the modules given by the "user" are already at the 
  ***   metalevel but still wants the same treatment.
  *** - The sixth arg. stores the variables (corresponding ops.) in the top
  ***   module.

  sort ViewInfo .
  op <_;_;_;_;_> : ViewExp Default{Term} View Set{ModuleName}  
       Set{ViewExp} -> ViewInfo 
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .
  op <_;_;_;_;_> : 
       ViewExp View View Set{ModuleName} Set{ViewExp} -> ViewInfo 
       [ctor format (nig o g n+++io g nio g nio g nio n---ig o)] .

endfm

view ModuleInfo from TRIV to INFO is
  sort Elt to ModuleInfo .
endv

view ViewInfo from TRIV to INFO is
  sort Elt to ViewInfo .
endv

fmod DATABASE-DECLS is
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ModuleInfo} .
  pr (SET * (op _`,_ to __, op empty to emptyInfoSet)){ViewInfo} .

  sort Database .
  op db : 
     Set{ModuleInfo}  *** module info tuples
     Set{ModuleName}  *** names of the modules in the database
     Set{ViewInfo}    *** view info tuples
     Set{ViewExp}     *** names of the views in the db
     Set{ModuleName}  *** modules with set protect on (by default empty)
     Set{ModuleName}  *** modules with set extend on (by default empty)
     Set{ModuleName}  *** modules with set include on (by default empty)
     QidList 
       -> Database 
     [ctor
      format (nib i++o)] .
      
  ops getDefPrs getDefExs getDefIncs : Database -> Set{ModuleName} .
  eq getDefPrs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExp}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList)) 
    = MNS':Set{ModuleName} .
  eq getDefExs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExp}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList)) 
    = MNS'':Set{ModuleName} .
  eq getDefIncs(
        db(MIS:Set{ModuleInfo}, MNS:Set{ModuleName}, VIS:Set{ViewInfo},
           VES:Set{ViewExp}, MNS':Set{ModuleName}, MNS'':Set{ModuleName},
           MNS3:Set{ModuleName}, QIL:QidList)) 
    = MNS3:Set{ModuleName} .
endfm

view Database from TRIV to DATABASE-DECLS is
  sort Elt to Database .
endv

view ModuleExpression from TRIV to META-MODULE is
  sort Elt to ModuleExpression .
endv

fmod DATABASE is
  pr (2TUPLE * (op `(_`,_`) to <_;_>, 
                op p1_ to database, 
                op p2_ to modExp)) {Database, ModuleExpression} .
  pr PRE-VIEW .
  pr UNIT .
  pr VIEW-EXPR-TO-QID .

  op evalModule : Module OpDeclSet Database -> Database .
  *** its definition is in the module EVALUATION

  op procModule : Qid Database -> Database .
  op procView : Qid Database -> Database .
  op procView : View Database -> Database .
  *** their definitions are in the modules UNIT-PROCESSING and VIEW-PROCESSING

  op evalModExp : ModuleExpression Database -> Tuple{Database, ModuleExpression} .
  *** its definition is in the module MOD-EXPR-EVAL 

  vars QI X Y F : Qid .
  vars QIL QIL' : QidList .
  vars NQIL NQIL' : NeQidList .
  vars VE VE' VE'' : ViewExp .
  vars VES VES' VES'' VES3 : Set{ViewExp} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 MNS6 : Set{ModuleName} .
  vars PL PL' : ParameterList .
  vars PDS PDS' PDS'' : Set{ParameterDecl} .
  var  PDL : ParameterDeclList .
  var  PD : ParameterDecl .
  vars ME ME' : ModuleExpression .
  vars VI VI' : View .
  var  SMS : SortMappingSet .
  var  OMS : OpMappingSet .
  vars PU PU' U U' U'' U3 U4 : Module .
  var  M : Module .
  var  DB : Database .
  vars IL IL' : ImportList .
  var  VIf : ViewInfo .
  var  UIf : ModuleInfo . 
  vars OPDS VDS VDS' : OpDeclSet .
  var  PV : PreView .
  vars T T' : Term .
  var  DT : Default{Term} .
  var  NL : IntList .
  var  TyL : TypeList .
  var  Ty : Type .
  var  AtS : AttrSet .
  var  B : Bool .
  var  I : Import .
  var  MN MN' : ModuleName .

  ops dincluded : ModuleExpression ImportList -> Bool .

  eq dincluded(ME, IL (protecting ME .) IL') = true .
  eq dincluded(ME, IL (extending ME .) IL') = true .
  eq dincluded(ME, IL (including ME .) IL') = true .
  eq dincluded(ME, IL) = false [owise] .

  ops included includedAux : ModuleExpression ImportList Database -> Bool .

  eq included(ME, IL (protecting ME .) IL', DB) = true .
  eq included(ME, IL (extending ME .) IL', DB) = true .
  eq included(ME, IL (including ME .) IL', DB) = true .
  eq included(ME, nil, DB) = false .
  eq included(ME, IL, DB) = includedAux(ME, IL, DB) [owise] .

  eq includedAux(ME, I IL, DB) 
    = included(ME, getImports(getTopModule(moduleName(I), DB)), DB)
      or-else includedAux(ME, IL, DB) .
  eq includedAux(ME, nil, DB) = false .

  op defImports : Module Database -> ImportList .
  op defImports : ImportList ImportList Set{ModuleName} Set{ModuleName} 
       Set{ModuleName} -> ImportList .

  eq defImports(M, DB) 
    = if theory(M) 
      then nil 
      else defImports(getImports(M), nil,
             getDefPrs(DB), getDefExs(DB), getDefIncs(DB))
      fi .

  eq defImports(IL, IL', MN . MNS, MNS', MNS'') 
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'') 
      else defImports(IL, IL' (protecting MN .), MNS, MNS', MNS'') 
      fi .
  eq defImports(IL, IL', MNS, MN . MNS', MNS'') 
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'') 
      else defImports(IL, IL' (extending MN .), MNS, MNS', MNS'') 
      fi .
  eq defImports(IL, IL', MNS, MNS', MN . MNS'') 
    = if dincluded(MN, IL IL')
      then defImports(IL, IL', MNS, MNS', MNS'') 
      else defImports(IL, IL' (including MN .), MNS, MNS', MNS'') 
      fi .
  eq defImports(IL, IL', 
       emptyModuleNameSet, emptyModuleNameSet, emptyModuleNameSet) 
    = IL' .

*** The constant \texttt{emptyDatabase} denotes the empty database, and there
*** are predicates \texttt{viewInDatabase} and \texttt{unitInDb} to check,
*** respectively, whether a view and a unit are in a database or not.

  op emptyDatabase : -> Database .
  eq emptyDatabase 
    = db(emptyInfoSet, emptyModuleNameSet, emptyInfoSet, emptyViewExpSet, 
         emptyModuleNameSet, emptyModuleNameSet, 'BOOL, nil) .

  op unitInDb : ModuleName Database -> Bool .
  eq unitInDb(MN, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL)) 
    = MN inModuleNameSet MNS .

  op viewInDb : ViewExp Database -> Bool .
  eq viewInDb(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL)) 
    = VE inViewExpSet VES .

  op includeBOOL : Database -> Bool .
  eq includeBOOL(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL)) 
    = 'BOOL inModuleNameSet MNS' .

*** If a module, theory, or view is being redefined, that is, if there was
*** already in the database a module, theory, or view with the same name,
*** then all the units and/or views depending on it are removed using the
*** functions \texttt{delModules} and \texttt{delViews}. Removing a view 
*** or a unit from the database means removing its info cell from the set of 
*** cells in the database. Those entered by the user are not completely 
*** removed, their term form is saved so that it can be recompiled later.

  op delModules : Set{ModuleName} Database -> Database .
  op delViews : Set{ViewExp} Database -> Database .

  eq delModules((MN . MNS), 
       db(< MN ; T ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS, 
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'), 
          delViews(VES, 
            db(< MN ; T ; noModule ; noModule ; noModule ; VDS ; 
                 emptyModuleNameSet ; emptyViewExpSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS), 
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS' ; VES > MIS, 
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'), 
          delViews(VES,
            db(< MN ; U ; noModule ; noModule ; noModule ; VDS ; 
                 emptyModuleNameSet ; emptyViewExpSet > MIS,
               MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules((MN . MNS), 
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS' ; VES > MIS, 
          MN . MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))
    = delModules((MNS . MNS'), 
        delViews(VES, 
            db(MIS, MNS'', VIS, VES', MNS3, MNS4, MNS5, QIL))) .
  eq delModules(emptyModuleNameSet, DB) = DB .
  eq delModules((MN . MNS), DB) = delModules(MNS, DB) [owise] .

  eq delViews(VE # VES, 
       db(MIS, MNS, < VE ; T ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES', 
        delModules(MNS', 
          db(MIS, MNS, 
             < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpSet > VIS, 
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES, 
       db(MIS, MNS, 
          < VE ; (null).Default{Term} ; VI ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES', 
        delModules(MNS', 
          db(MIS, MNS, VIS, VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(VE # VES, 
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES' > VIS, VE # VES'',
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES # VES', 
        delModules(MNS', 
          db(MIS, MNS, 
             < VE ; VI ; null ; emptyModuleNameSet ; emptyViewExpSet > VIS, 
             VE # VES'', MNS'', MNS3, MNS4, QIL))) .
  eq delViews(emptyViewExpSet, DB) = DB .
  eq delViews(VE # VES, DB) = delViews(VES, DB) [owise] .

*** The \texttt{warning} function allows us to place messages (warning, error,
*** or any other kind of messages) in the last argument of the database
*** constructor. These messages are given in the form of quoted identifier
*** lists, and will be passed to the third argument of the read-eval-print 
*** loop, to be printed in the terminal.

  op warning : Database QidList -> Database .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, nil), QIL) 
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) .
  eq warning(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL), QIL) 
    = db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL QIL) .

  op getMsg : Database -> QidList .
  eq getMsg(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL)) = QIL .

*** Core Maude built-in modules are handled in a special way in the current
*** version of the system. They are not explicitly defined in the Full Maude
*** database; their importation is directly handled by Core Maude. This has
*** some drawbacks: Core Maude built-in modules cannot be renamed; they cannot
*** be directly used with built-in functions, such as \texttt{metaReduce} or
*** \texttt{sameComponent}, although they can be imported in modules being
*** used in the calls to these functions; and, in general, any function taking
*** as argument or returning as result the metarepresentation of a module
*** cannot take one of these built-in modules as argument. This is the case,
*** for example, for the \texttt{up} function presented in
*** Section~\ref{changing-levels}, or for functions or commands in which the
*** name of a module has to be specified, as the \texttt{select} or
*** \texttt{down} commands, or the \texttt{up} function presented in
*** Section~\ref{structured-specifications}. Nevertheless, there are also 
*** some advantages: The flattening of the built-in part of the structure is 
*** accomplished more efficiently, and, since these modules do not have to be 
*** stored in the database of Full Maude, the size of the database is reduced.

*** Our plan is to have in the future a hybrid solution. Once we have some way
*** of storing the modules entered to Full Maude in Core Maude's database, it
*** will be enough to keep in the Full Maude database just the original form
*** of the top of all the modules, including built-ins, leaving all the
*** importation declarations to be resolved by the engine. The structures will
*** be normalized as they are now, so that the engine will have to deal just
*** with inclusions, but it will be possible to use the predefined modules as 
*** any other module. Moreover, the Full Maude database will be relatively 
*** smaller and the flattening will be computed more efficiently.

*** When a new module or theory is entered, the names of all the modules,
*** theories, and views depending on it are included in its lists of
*** dependencies with functions \texttt{setUpModuleDeps} and
*** \texttt{setUpViewDeps}. Notice that if new module expressions are
*** defined, the function \texttt{setUpModExpDeps} will have to be 
*** extended accordingly.

  op setUpModuleDeps : Module Database -> Database .
  op setUpModExpDeps : ModuleName Database -> Database .
  op setUpModExpDeps : ModuleName Header Database -> Database .
  op setUpModExpDeps : ModuleName ViewExp Database -> Database .
  op setUpImportDeps : ModuleName ImportList Database -> Database .

  eq setUpModuleDeps(U, DB)
    = setUpImportDeps(getName(U), getImports(U), 
        setUpModExpDeps(getName(U), DB)) .

  eq setUpModExpDeps(QI, DB) = DB .

  eq setUpModExpDeps(pd(X :: ME), 
       db(< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DT ; U ; U' ; U'' ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME), 
       db(< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; U ; U' ; U'' ; U3 ; VDS ; (MNS . pd(X :: ME)) ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(pd(X :: ME), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    [owise] .

---- This could be a bug in Core Maude.
---- It should work if the next 6 equations are replaced by this single equation. 
----  ceq setUpImportDeps(MN, (I IL), 
----       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), 
----          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
----    = setUpImportDeps(MN, IL, 
----        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), 
----           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) 
----    if MN' := moduleName(I) .
  eq setUpImportDeps(MN, ((including MN' .) IL), 
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL, 
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((including MN' .) IL), 
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL, 
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL), 
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL, 
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((extending MN' .) IL), 
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL, 
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL), 
       db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL, 
        db((< MN' ; DT ; U ; U' ; U'' ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, ((protecting MN' .) IL), 
       db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpImportDeps(MN, IL, 
        db((< MN' ; U ; U' ; U'' ; U3 ; VDS ; MN . MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpImportDeps(MN, I IL, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(moduleName(I)) 'not 'in 'database. '\n)
    [owise] .
  eq setUpImportDeps(MN, nil, DB) = DB .

  op setUpViewDeps : ModuleExpression ViewExp Database -> Database .
  op setUpViewExpDeps : ViewExp Database -> Database .
  op setUpViewExpDeps : ViewExp ParameterList Database -> Database .

  eq setUpViewDeps(ME, VE, 
       db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; DT ; U ; U' ; U'' ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE, 
       db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db((< ME ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VE # VES > MIS), MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpViewDeps(ME, VE, DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    [owise] .

  eq setUpViewExpDeps(QI, DB) = DB .
  eq setUpViewExpDeps(QI{PL}, DB) = setUpViewExpDeps(QI{PL}, PL, DB) .

  eq setUpViewExpDeps(VE, (QI, PL), 
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, PL, 
        db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpDeps(VE, (QI, PL), 
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, PL, 
        db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpDeps(QI{PL}, PL', 
       db(MIS, MNS, < QI ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) 
    = db(MIS, MNS, < QI ; DT ; VI ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL) 
    [owise] .
  eq setUpViewExpDeps(QI{PL}, PL', 
       db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(MIS, MNS, < QI ; VI ; VI' ; MNS' ; QI{PL} # VES > VIS, VES', MNS'', MNS3, MNS4, QIL) 
    [owise] .

  eq setUpViewExpDeps(VE, (QI{PL}, PL'), 
       db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, PL', 
        db(MIS, MNS, < QI{PL} ; DT ; VI ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpDeps(VE, (QI{PL}, PL'), 
       db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, PL', 
        db(MIS, MNS, < QI{PL} ; VI ; VI' ; MNS' ; VE # VES > VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpViewExpDeps(VE, (QI{PL}, PL'), DB) 
    = setUpViewExpDeps(VE, PL', DB) 
    [owise] .
  eq setUpViewExpDeps(VE, empty, DB) = DB .

  op compiledModule : ModuleExpression Database -> Bool .
  op compiledModule : ParameterDecl Database -> Bool .
  op compiledView : ViewExp Database -> Bool .

  eq compiledView(VE, 
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI =/= null .
  eq compiledView(ME, DB) = false [owise] .

  eq compiledModule(MN, 
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' =/= noModule .
  eq compiledModule(MN, 
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U3 =/= noModule .
  eq compiledModule(MN, DB) = false [owise] .

  op insertTermView : ViewExp Term Database -> Database .
  op insertView : View Database -> Database .
  op getTermView : ViewExp Database -> Default{Term} .
  op getView : ViewExp Database -> View .

  eq insertTermView(VE, T, 
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', 
          MNS'', MNS3, MNS4, QIL))
    = delViews(VES,
        delModules(MNS', 
          db(MIS, MNS, 
            < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpSet > VIS, VES', 
            MNS'', MNS3, MNS4, 
            QIL 
            '\g 'Advisory: '\o 'View viewExp2QidList(VE) 'redefined. '\n))) .
  eq insertTermView(VE, T, 
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(MIS, MNS, 
         < VE ; T ; null ; emptyModuleNameSet ; emptyViewExpSet > VIS, 
         (VE # VES), MNS', MNS'', MNS3, QIL)
    [owise] .

  eq insertView(view VE from ME to ME' is SMS OMS endv, 
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, 
        setUpViewDeps(ME, VE, 
          setUpViewDeps(ME', VE, 
            db(MIS, MNS, 
               < VE ; DT ; 
                 view VE from ME to ME' is SMS OMS endv ; 
                 MNS' ; VES > VIS, 
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS endv, 
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, 
        setUpViewDeps(ME, VE, 
          setUpViewDeps(ME', VE, 
            db(MIS, MNS, 
               < VE ; DT ; 
                 view VE{PDL} from ME to ME' is SMS OMS endv ; 
                 MNS' ; VES > VIS, 
                 VES', MNS'', MNS3, MNS4, QIL)))) .
  eq insertView(view VE from ME to ME' is SMS OMS endv, 
       db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, 
        setUpViewDeps(ME, VE, 
          setUpViewDeps(ME', VE, 
            db(MIS, MNS, 
               < VE ; (null).Default{Term} ; 
                 view VE from ME to ME' is SMS OMS endv ; 
                 emptyModuleNameSet ; emptyViewExpSet > VIS, 
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(view VE{PDL} from ME to ME' is SMS OMS endv, db(MIS, MNS, VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpViewExpDeps(VE, 
        setUpViewDeps(ME, VE, 
          setUpViewDeps(ME', VE, 
            db(MIS, MNS, 
               < VE ; (null).Default{Term} ; 
                 view VE{PDL} from ME to ME' is SMS OMS endv ; 
                 emptyModuleNameSet ; emptyViewExpSet > VIS, 
                 VE # VES', MNS'', MNS3, MNS4, QIL))))
    [owise] .
  eq insertView(viewError(QIL), DB) = warning(DB, QIL) .
  ceq insertView(view VE:[ViewExp] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] endv, DB) 
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.) 
    if not view VE:[ViewExp] from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] endv :: View 
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExp])
    [owise] .
  ceq insertView(view VE:[ViewExp]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] endv, DB) 
    = warning(DB, 'The 'view QIL QI if QI == '`) then '\s else nil fi 'contains 'errors.) 
    if not view VE:[ViewExp]{PDL:[ParameterDeclList]} from ME:[ModuleExpression] to ME':[ModuleExpression] is SMS:[SortMappingSet] OMS:[OpMappingSet] endv :: View 
    /\ QIL QI := eMetaPrettyPrint(VE:[ViewExp])
    [owise] .

  eq getTermView(VE, 
       db(MIS, MNS, (< VE ; DT ; VI ; MNS' ; VES > VIS), VES', MNS'', MNS3, MNS4, QIL))
    = DT .
  eq getTermView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = qidError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

  eq getView(VE, 
       db(MIS, MNS, < VE ; DT ; VI ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI .
  eq getView(VE, 
       db(MIS, MNS, < VE ; VI ; VI' ; MNS' ; VES > VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VI' .
  eq getView(VE, db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL)) 
    = viewError('\r 'Error: '\o 'View viewExp2QidList(VE) 'not 'in 'database. '\n)
    [owise] .

*** There are functions to insert the different versions of a unit, and to
*** extract them.  We only give here the equations for the insertion of top
*** units to illustrate the way in which the consistency of the database is
*** maintained.  We assume that when the internal version, the signature, or
*** the flat version of a module is entered in the database, its corresponding 
*** top module is already present in it.

  pr 3TUPLE{Term,OpDeclSet,Module}
       * (op ((_,_,_)) to <_;_;_>) .

----  sort Tuple{Term,OpDeclSet,Module} .
----  op <_;_;_> : Default{Term} OpDeclSet Module -> Tuple{Term,OpDeclSet,Module} .
  op error : QidList -> [Tuple{Term,OpDeclSet,Module}] .

  op insTermModule : ModuleName Module Database -> Database .
  op insTermModule : ModuleName Term Database -> Database .
  op insertTopModule : ModuleExpression [Module] Database -> Database .
  op insertInternalModule : ModuleExpression [Module] Database -> Database .
  op insertFlatModule : ModuleExpression [Module] Database -> Database .
  op insertVars : ModuleExpression [OpDeclSet] Database -> Database .
  op getTermModule : ModuleExpression Database -> [Tuple{Term,OpDeclSet,Module}] .
  op getTopModule : ModuleExpression Database -> [Module] .
  op getInternalModule : ModuleExpression Database -> [Module] .
  op getFlatModule : ModuleExpression Database -> [Module] .
  op getFlatModuleNeg : ModuleExpression Database -> [Module] .
  op getVars : ModuleExpression Database -> [OpDeclSet] .
  op insertTopModule : ParameterDecl [Module] Database -> Database .
  op insertInternalModule : ParameterDecl [Module] Database -> Database .
  op insertFlatModule : ParameterDecl [Module] Database -> Database .
  op insertVars : ParameterDecl [OpDeclSet] Database -> Database .
  op getTermModule : ParameterDecl Database -> [Tuple{Term,OpDeclSet,Module}] .
  op getTopModule : ParameterDecl Database -> [Module] .
  op getInternalModule : ParameterDecl Database -> [Module] .
  op getFlatModule : ParameterDecl Database -> [Module] .
  op getFlatModuleNeg : ParameterDecl Database -> [Module] .
  op getVars : ParameterDecl Database -> [OpDeclSet] .

  eq insTermModule(MN, T, 
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS, 
          delViews(VES, 
            db(< MN ; T ; noModule ; noModule ; noModule ; none ; 
                 emptyModuleNameSet ; emptyViewExpSet > MIS, 
               MNS', VIS, VES', MNS'', MNS3, MNS4, 
               QIL 
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T, 
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS, 
          delViews(VES, 
            db(< MN ; T ; noModule ; noModule ; noModule ; none ; 
                 emptyModuleNameSet ; emptyViewExpSet > MIS, 
               MNS', VIS, VES', MNS'', MNS3, MNS4, 
               QIL 
               '\g 'Advisory: '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, T, 
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; T ; noModule ; noModule ; noModule ; none ; 
           emptyModuleNameSet ; emptyViewExpSet > MIS, 
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL) 
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insTermModule(MN, U, 
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS, 
          delViews(VES, 
            db(< MN ; U ; noModule ; noModule ; noModule ; none ; 
                 emptyModuleNameSet ; emptyViewExpSet > MIS, 
               MNS', VIS, VES', MNS'', MNS3, MNS4, 
               QIL 
               '\g 'Advisory: 
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U, 
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = delModules(MNS, 
          delViews(VES, 
            db(< MN ; U ; noModule ; noModule ; noModule ; none ; 
                 emptyModuleNameSet ; emptyViewExpSet > MIS, 
               MNS', VIS, VES', MNS'', MNS3, MNS4, 
               QIL 
               '\g 'Advisory: 
               '\o 'Module header2QidList(MN) 'redefined. '\n))).
  eq insTermModule(MN, U, 
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = db(< MN ; U ; noModule ; noModule ; noModule ; none ; 
           emptyModuleNameSet ; emptyViewExpSet > MIS, 
         MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL) 
    [owise] .
  eq insTermModule(MN, qidError(QIL), DB) = warning(DB, QIL) .
  eq insTermModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertTopModule(MN, U,
       db(< MN ; null ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; null ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS, 
         MNS', VIS, VES', MNS'', MNS3, MNS4,
         QIL 
         '\r 'Advisory: '\o 
         'Internally 'generated 'module header2QidList(MN) 'redefined. '\n) .
  eq insertTopModule(MN, U,
       db(< MN ; T ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U, 
        db(< MN ; T ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModuleDeps(U, 
        db(< MN ; U' ; U ; noModule ; noModule ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq insertTopModule(MN, U, 
       db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    = setUpModuleDeps(U, 
        db(< MN ; null ; U ; noModule ; noModule ; 
              none ; emptyModuleNameSet ; emptyViewExpSet > MIS, 
           MN . MNS, VIS, VES, MNS', MNS'', MNS3, QIL))
    [owise] .
  eq insertTopModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertInternalModule(MN, U, 
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U ; U3 ; VDS ; MNS ; VES > MIS, 
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, U, 
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U ; U4 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertInternalModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertFlatModule(MN, U, 
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U ; VDS ; MNS ; VES > MIS, 
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, U, 
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertFlatModule(MN, unitError(QIL), DB) = warning(DB, QIL) .

  eq insertVars(MN, VDS,
       db(< MN ; DT ; U' ; U'' ; U3 ; VDS' ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; DT ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, 
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, VDS,
       db(< MN ; U' ; U'' ; U3 ; U4 ; VDS' ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< MN ; U' ; U'' ; U3 ; U4 ; VDS ; MNS ; VES > MIS, 
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq insertVars(MN, opDeclError(QIL), DB) = warning(DB, QIL) .

  eq getTermModule(MN, 
       db(< MN ; null ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = error('\r 'Error: '\o header2QidList(MN) 'is 'an 'internal 'module. '\n) .
  eq getTermModule(MN, 
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < DT ; none ; noModule > .
  eq getTermModule(MN, 
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = < null ; VDS ; U > .
  eq getTermModule(MN, DB)
    = error('\r 'Error: '\o 'Module header2QidList(MN)  '\n) 
    [owise] .

  eq getTopModule(MN, 
      db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) 
    = U .
  eq getTopModule(MN, 
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getTopModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getInternalModule(MN, 
       db(< MN ; DT ; U ; U' ; U'' ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U' .
  eq getInternalModule(MN, 
       db(< MN ; U ; U' ; U'' ; U3 ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = U'' .
  eq getInternalModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  eq getVars(MN, 
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN, 
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = VDS .
  eq getVars(MN, DB) = none [owise] .

*** The name of the signature and the flattened module is not the
*** module expression used as the name of the module but the result of
*** converting it into a quoted identifier.

  eq getFlatModule(MN, 
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n) 
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN, 
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = if M == noModule
      then unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'compiled. '\n)
      else remNegAnns(M)
      fi .
  eq getFlatModule(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** Handling of negative annotations (by Santiago Escobar)

  eq getFlatModuleNeg(MN, 
       db(< MN ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN, 
       db(< MN ; U ; U' ; U'' ; M ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = M .
  eq getFlatModuleNeg(MN, 
       db(< MN ; DT ; U ; U' ; noModule ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o 
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN, 
      db(< MN ; U ; U' ; U'' ; noModule ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = unitError('\r 'Error: '\o 
                'Module header2QidList(MN) 'not 'compiled. '\n) .
  eq getFlatModuleNeg(MN, DB)
    = unitError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    [owise] .

  *** removeNegAnnotations
  op remNegAnns : Module -> Module .
  op remNegAnns : OpDeclSet -> OpDeclSet .
  op remNegAnns : AttrSet -> AttrSet .
  op remNegAnns : IntList -> IntList .

  eq remNegAnns(M) = setOps(M, remNegAnns(getOps(M))) .

  eq remNegAnns(op F : TyL -> Ty [AtS] . OPDS)
    = op F : TyL -> Ty [remNegAnns(AtS)] . remNegAnns(OPDS) .
  eq remNegAnns((none).OpDeclSet) = (none).OpDeclSet .

  eq remNegAnns(strat(NL:NatList) AtS) = strat(NL:NatList) AtS .
  eq remNegAnns(strat(IL:IntList) AtS) = AtS [owise] .
  eq remNegAnns(AtS) = AtS [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The Evaluation of Modules
***

*** The general principle for the evaluation of units in our design consists in
*** first evaluating any module expression, reducing it to a canonical form in
*** which only unit inclusions appear, that is, to a unit hierarchy, which can
*** be seen as a partial order of unit inclusions. The design of the Full Maude
*** system has been based upon the principle of evaluating all module
*** expressions to irreducible structured units, and on using the flat version
*** of the units only for execution purposes. We have then two different
*** processes clearly distinguished: a first step in which the structured unit 
*** is evaluated and reduced to its normal form, and a second step in which 
*** this normal form is flattened.

*** As explained in Section~\ref{execution-environment}, the process of
*** evaluation to normal form is also responsible for the parsing of the
*** bubbles in the premodules, which is accomplished once the signature has
*** been built. The parsing of bubbles is discussed in
*** Section~\ref{bubble-parsing}. To be able to handle the \texttt{up}
*** function and the \texttt{down} command presented in
*** Section~\ref{structured-specifications}, it is necessary to be able to
*** move terms and modules from one level of reflection to another. The
*** functionality to move between levels is presented in
*** Section~\ref{changing-levels}, where functions \texttt{up} and
*** \texttt{down} on sorts \texttt{Module} and \texttt{Term} are defined. The 
*** transformation of object-oriented modules into system modules in discussed 
*** in Section~\ref{omod2modfunction}. The evaluation of module expressions is 
*** discussed in Sections~\ref{evalModExp}, \ref{application-of-maps}, 
*** \ref{instantiation}, and~\ref{renaming}.

***
*** Changing Levels
***

*** Moving terms of sorts \texttt{Term} and \texttt{Module} from one
*** level of reflection to another is possible thanks to the
*** \texttt{up} and \texttt{down} functions, which are defined,
*** respectively, in the following modules \texttt{MOVE-UP} and
*** \texttt{MOVE-DOWN}.

***
*** The \texttt{up} Function
***

*** Given a term of sort \texttt{Module} or \texttt{Term}, the
*** \texttt{up} function, defined in the following module
*** \texttt{MOVE-UP}, returns the term metarepresenting it. The
*** function is just call the \texttt{upTerm} predefined function.

*** We shall see in Section~\ref{bubble-parsing} how the \texttt{up} function
*** is used to evaluate the homonymous function discussed in
*** Section~\ref{structured-specifications}. In Section~\ref{instantiation} we
*** shall discuss how the \texttt{up} function is used to evaluate the 
*** \texttt{META-LEVEL} module expression (see 
*** Section~\ref{structured-specifications}).

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOVE-UP is
---  pr META-LEVEL + PRE-VARIANT .  
  pr META-LEVEL .  
  pr CONVERSION .
  op up : Module -> Term .
  op up : Term -> Term .
  op up : EquationSet -> Term .

  eq up(M:Module) = upTerm(M:Module) .
  eq up(T:Term) = upTerm(T:Term) .
  eq up(EqS:EquationSet) = upTerm(EqS:EquationSet) .
  
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** The \texttt{down} Function
***

*** Given a term of sort \texttt{Term} metarepresenting a term of sort
*** \texttt{Term} or \texttt{Module}, the \texttt{down} function can be seen
*** as the inverse of the \texttt{up} function discussed in the previous
*** section, that is, it returns the original term that had been
*** metarepresented. There are also \texttt{down} functions for terms 
*** metarepresenting terms in other sorts. We present here only some of them.

*** We assume that the \texttt{down} functions are called with valid
*** metarepresentations. In fact, these functions should be declared as
*** partial functions going to error sorts when their arguments are invalid.

*** The main application of the \texttt{down} functions is in the evaluation
*** of the \texttt{down} command (see
*** Section~\ref{structured-specifications}).  However, they are also used in 
*** other tasks, as for example in the parsing of some inputs.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOVE-DOWN is
  pr UNIT .
  pr CONVERSION .
  pr INT-LIST .

  op downTerm : Term -> [Term] .
  op downModule : Term -> [Module] .
  op downQid : Term -> [Qid] [memo] .
  op downQidList : Term -> [QidList] .
  op downTypes : Term -> [TypeList] .
  op downSorts : Term -> [SortSet] .
  op downSort : Term -> [Sort] .
  op downModExp : Constant -> [Header] .
  op downNat : Term -> [Int] .
  op downString : Term -> [String] .

  op downResultPair : Term -> [ResultPair] .
  op downTerm : TermList -> [Term] .
  op downImports : TermList -> [ImportList] .
  op downSubsorts : TermList -> [SubsortDeclSet] .
  op downOps : TermList -> [OpDeclSet] .
  op downEqCond : TermList -> [EqCondition] .
  op downCond : TermList -> [Condition] .
  op downMbs : TermList -> [MembAxSet] .
  op downEqs : TermList -> [EquationSet] .
  op downRls : TermList -> [RuleSet] .
  op downAttrs : TermList -> [AttrSet] .
  op downAttr : Term -> [Attr] .
  op downHooks : TermList -> [HookList] .
  op downMetaNat : Term -> [Term] .
  op downNat : TermList -> [IntList] .

  op downClasses : TermList -> [ClassDeclSet] .
  op downMsgs : TermList -> [MsgDeclSet] .
  op downSubclasses : TermList -> [SubclassDeclSet] .
  op downClassAttrs : TermList -> [AttrDeclSet] .
  
  vars T T' T'' T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 : Term .
  vars TL TL' : TermList .
  vars QI QI' F V L : Qid .
  var  Ct : Constant .
  var  M : Module .
  var  Tp : Type .

  eq downResultPair('`{_`,_`}[T, T']) = {downTerm(T), downTerm(T')} .

  eq downModule('fmod_is_sorts_.____endfm[T1, T2, T3, T4, T5, T6, T7])
    = (fmod downModExp(T1) is
         downImports(T2) 
         sorts downSorts(T3) .
         downSubsorts(T4) 
         downOps(T5) 
         downMbs(T6) 
         downEqs(T7)
       endfm) .
  eq downModule('mod_is_sorts_._____endm[T1, T2, T3, T4, T5, T6, T7, T8])
    = (mod downModExp(T1) is
         downImports(T2) 
         sorts downSorts(T3) .
         downSubsorts(T4) 
         downOps(T5) 
         downMbs(T6) 
         downEqs(T7) 
         downRls(T8)
       endm) .
  eq downModule('omod_is_sorts_.________endom[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11])
    = (omod downModExp(T1) is
         downImports(T2) 
         sorts downSorts(T3) .
         downSubsorts(T4) 
         downClasses(T5) 
         downSubclasses(T6) 
         downOps(T7) 
         downMsgs(T8) 
         downMbs(T9) 
         downEqs(T10) 
         downRls(T11)
       endom) .

  eq downModExp(Ct) = downQid(Ct) .

  eq downImports('nil.ImportList) = nil .
  eq downImports('__[TL]) = downImports(TL) .
  eq downImports('including_.[T]) = (including downModExp(T) .) .
  eq downImports('extending_.[T]) = (extending downModExp(T) .) .
  eq downImports('protecting_.[T]) = (protecting downModExp(T) .) .
  ceq downImports((TL, TL')) = (downImports(TL) downImports(TL')) if TL =/= empty /\ TL' =/= empty .
  
  eq downSubsorts('none.SubsortDeclSet) = none .
  eq downSubsorts('__[TL]) = downSubsorts(TL) .
  eq downSubsorts('subsort_<_.[T, T']) = (subsort downQid(T) < downQid(T') .) .
  ceq downSubsorts((TL, TL')) = (downSubsorts(TL) downSubsorts(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downOps('none.OpDeclSet) = none .
  eq downOps('__[TL]) = downOps(TL) .
  eq downOps('op_:_->_`[_`].[Ct, T, T', T''])
    = (op downQid(Ct) : downTypes(T) -> downQid(T') [downAttrs(T'')] .) .
  ceq downOps((TL, TL')) = (downOps(TL) downOps(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downAttrs('none.AttrSet) = none .
  eq downAttrs('__[TL]) = downAttrs(TL) .
  ceq downAttrs((TL, TL')) = (downAttr(TL) downAttrs(TL')) if TL =/= empty /\ TL' =/= empty .
  ceq downAttrs(T)
    = downAttr(T)
    if T =/= 'none.AttrSet .

  eq downAttr('assoc.Attr) = assoc .
  eq downAttr('comm.Attr) = comm .
  eq downAttr('idem.Attr) = idem .
  eq downAttr('id[T]) = id(downTerm(T)) .
  eq downAttr('left-id[T]) = left-id(downTerm(T)) .
  eq downAttr('right-id[T]) = right-id(downTerm(T)) .
  eq downAttr('poly[T]) = poly(downNat(T)) .
  eq downAttr('strat[T]) = strat(downNat(T)) .
  eq downAttr('memo.Attr) = memo .
  eq downAttr('prec[T]) = prec(downNat(T)) .
  eq downAttr('gather[T]) = gather(downQidList(T)) .
  eq downAttr('ctor.Attr) = ctor .
  eq downAttr('special[T]) = special(downHooks(T)) .
  eq downAttr('iter.Attr) = iter .
  eq downAttr('frozen[T]) = frozen(downNat(T)) .
  eq downAttr('label[T]) = label(downQid(T)) .
  eq downAttr('config.Attr) = config .
  eq downAttr('object.Attr) = object .
  eq downAttr('msg.Attr) = msg .
  eq downAttr('nonexec.Attr) = nonexec .
  eq downAttr('variant.Attr) = variant .
----  eq downAttr('metadata`(_`)['token[T]]) = metadata(downString(downQid(T))) .
  eq downAttr('owise.Attr) = owise .
  eq downAttr('metadata[T]) = metadata(substr(string(T), 1, find(string(T), "\".String", 0) + (- 1))) .
  eq downAttr('format[T]) = format(downQidList(T)) .

  eq downHooks('__[TL]) = downHooks(TL) .
  eq downHooks('id-hook[T, T']) = id-hook(downQid(T), downQidList(T')) .
  eq downHooks('op-hook[T, T', T'', T3])
    = op-hook(downQid(T), downQid(T'), downQidList(T''), downQid(T3)) .
  eq downHooks('term-hook[T, T']) = term-hook(downQid(T), downTerm(T')) .
  ceq downHooks((TL, TL')) = downHooks(TL) downHooks(TL') if TL =/= empty /\ TL' =/= empty .

----  eq downTerm(T) = downTerm(T, qidError('\r 'Error: '\o 'Incorrect 'term. '\n)) .
  eq downTerm(QI) = downQid(QI) .
  eq downTerm('_`[_`][T, T']) = downQid(T)[downTerm(T')] .
  eq downTerm('_`,_[T, TL]) = (downTerm(T), downTerm(TL)) .
  ceq downTerm((T, TL)) = (downTerm(T), downTerm(TL)) if TL =/= empty .
  eq downTerm(F[TL]) 
    = qidError('\r 'Error: '\o 'Incorrect 'term. '\n) [owise] .

  eq downEqCond('_/\_[TL]) = downEqCond(TL) .
  eq downEqCond('_=_[T, T']) = downTerm(T) = downTerm(T') .
  eq downEqCond('_:_[T, T']) = downTerm(T) : downSort(T') .
  eq downEqCond('_:=_[T, T']) = downTerm(T) := downTerm(T') .
  ceq downEqCond((TL, TL')) = downEqCond(TL) /\ downEqCond(TL') if TL =/= empty /\ TL' =/= empty .

  eq downCond('_/\_[TL]) = downCond(TL) .
  eq downCond('_=_[T, T']) = downEqCond('_=_[T, T']) .
  eq downCond('_:_[T, T']) = downEqCond('_:_[T, T']) .
  eq downCond('_:=_[T, T']) = downEqCond('_:=_[T, T']) .
  eq downCond('_=>_[T, T']) = downTerm(T) => downTerm(T') .
  ceq downCond((TL, TL')) = downCond(TL) /\ downCond(TL') if TL =/= empty /\ TL' =/= empty .

  eq downMbs('none.MembAxSet) = none .
  eq downMbs('__[TL]) = downMbs(TL) .
  eq downMbs('mb_:_`[_`].[T, T', T'']) 
    = (mb downTerm(T) : downSort(T') [downAttrs(T'')] .) .
  eq downMbs('cmb_:_if_`[_`].[T, T', T'', T3]) 
    = (cmb downTerm(T) : downSort(T') if downEqCond(T'') [downAttrs(T3)] .) .
  ceq downMbs((TL, TL')) = (downMbs(TL) downMbs(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downEqs('none.EquationSet) = none .
  eq downEqs('__[TL]) = downEqs(TL) .
  eq downEqs('eq_=_`[_`].[T, T', T'']) 
    = (eq downTerm(T) = downTerm(T') [downAttrs(T'')] .) .
  eq downEqs('ceq_=_if_`[_`].[T, T', T'', T3]) 
    = (ceq downTerm(T) = downTerm(T') if downEqCond(T'') [downAttrs(T3)] .) .
  ceq downEqs((TL, TL')) = (downEqs(TL) downEqs(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downRls('none.RuleSet) = none .
  eq downRls('__[TL]) = downRls(TL) .
  eq downRls('rl_=>_`[_`].[T, T', T'']) 
    = (rl downTerm(T) => downTerm(T') [downAttrs(T'')] .) .
  eq downRls('crl_=>_if_`[_`].[T, T', T'', T3])
    = (crl downTerm(T) => downTerm(T') if downCond(T'') [downAttrs(T3)] .) .
  ceq downRls((TL, TL')) = (downRls(TL) downRls(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downSorts('none.EmptyTypeSet) = none .
----  eq downSorts('none.SortSet) = none .
  eq downSorts('_;_[TL]) = downSorts(TL) .
  ceq downSorts((TL, TL')) = (downSorts(TL) ; downSorts(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downSorts(QI) = downSort(QI) [owise] .

  eq downSort(Ct) = downQid(Ct) .

  eq downTypes('nil.TypeList) = nil .
  eq downTypes('__[TL]) = downTypes(TL) .
  ceq downTypes((TL, TL')) 
    = (downTypes(TL) downTypes(TL')) 
    if TL =/= empty /\ TL' =/= empty .
  eq downTypes(QI) = downSort(QI) [owise] .

  eq downQidList('nil.TypeList) = nil .
  eq downQidList('__[TL]) = downQidList(TL) .
  ceq downQidList((TL, TL')) = (downQidList(TL) downQidList(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downQidList(QI) = downQid(QI) [owise] .

  eq downQid(Ct) 
    = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .
----  eq downQid(Ct) = downTerm(Ct) . 

  eq downMetaNat(QI) 
    = qid(substr(string(getName(QI)), 1, length(string(getName(QI)))) 
          + ".Nat") .

----  eq downNat(T) = downTerm(T, numberError('Error: 'non 'valid 'metaterm)) .
  ceq downNat(QI) 
    = trunc(rat(string(getName(QI)), 10)) 
    if getType(QI) == 'Nat or getType(QI) == 'NzNat .
  ceq downNat(QI) 
    = if substr(string(getName(QI)), 0 ,1) == "-"
      then - trunc(rat(substr(string(getName(QI)), 1, 
                            length(string(getName(QI)))), 10)) 
      else trunc(rat(string(getName(QI)), 10)) 
      fi
    if getType(QI) == 'Int or getType(QI) == 'NzInt .
  eq downNat('0.Zero) = 0 .
  eq downNat('s_['0.Zero]) = 1 .
  ceq downNat(F['0.Zero]) 
    = trunc(rat(substr(string(F), 3, 2), 10)) 
    if substr(string(F), 0, 3) = "s_^" .

  eq downString(QI) = substr(string(QI), 1, _-_(length(string(QI)), 2)) .

  eq downNat('__[TL]) = downNat(TL) . 
  ceq downNat((TL, TL')) = (downNat(TL) downNat(TL')) if TL =/= empty /\ TL' =/= empty .

  eq downClasses('none.ClassDeclSet) = none .
  eq downClasses('__[TL]) = downClasses(TL) .
  ceq downClasses((TL, TL')) = (downClasses(TL) downClasses(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downClasses('class_|_.[T, T']) = (class downSort(T) | downClassAttrs(T') .) .

  eq downClassAttrs('none.AttrDeclSet) = none .
  eq downClassAttrs('_`,_[TL]) = downClassAttrs(TL) .
  ceq downClassAttrs((TL, TL')) = (downClassAttrs(TL), downClassAttrs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downClassAttrs('attr_:_[T, T']) = (attr downQid(T) : downSort(T')) .

  eq downSubclasses('none.SubclassDeclSet) = none .
  eq downSubclasses('__[TL]) = downSubclasses(TL) .
  ceq downSubclasses((TL, TL')) = (downSubclasses(TL) downSubclasses(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downSubclasses('subclass_<_.[T, T']) = (subclass downQid(T) < downQid(T') .) .

  eq downMsgs('none.MsgDeclSet) = none .
  eq downMsgs('__[TL]) = downMsgs(TL) .
  ceq downMsgs((TL, TL')) = (downMsgs(TL) downMsgs(TL')) if TL =/= empty /\ TL' =/= empty .
  eq downMsgs('msg_:_->_.[Ct, T, T'])
    = (msg downQid(Ct) : downTypes(T) -> downQid(T') .) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing of Bubbles
***

*** As discussed in Section~\ref{implementation-introduction}, in Full Maude,
*** the parsing process is split into two phases. In a first stage, the input
*** is parsed using the top-level grammar for Full Maude modules, theories,
*** views, and commands. Once this first stage is completed, we get a term
*** with bubbles in it, which is converted into a module, theory, or view.
*** This unit or view may still have the bubbles in it. We say that a module
*** with bubbles is a premodule, a view with bubbles a preview, and so on. The
*** second stage of the process consists in taking this preunit or preview and
*** converting the bubbles in it into terms by parsing them in the appropriate
*** signatures, obtaining a `valid' unit or view out of it, or otherwise a
*** parsing error. In the case of commands, if they contain any bubble, the 
*** same will have to be done. All bubbles have to be parsed in the 
*** appropriate signature before any further processing can be done with the 
*** module, view, or command in which they appear.

***
*** Parsing of Module Expressions
***

*** Before introducing the \texttt{parseDecl} function, we present some
*** auxiliary functions. For example, the following functions
*** \texttt{parseType}, \texttt{parseSortSet}, and \texttt{parseTypeList}
*** return, respectively, the sort, set of sorts, and list of sorts
*** represented by the term given as argument. Note that these functions, as
*** most of the functions in this module, are partial functions. We assume
*** that the term given as argument is in fact the representation of, for 
*** example, a valid sort, or set of sorts, etc. In the case of 
*** \texttt{parseDecl} we assume that the term is the representation of a 
*** predeclaration.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXP-PARSING is
  pr MOVE-DOWN .
  pr INT-LIST .
  pr VIEW-EXPR-TO-QID .

  vars T T' T'' T3 T4 : Term .
  vars T? T?' : [Term] .
  var  TL TL' : TermList .
  var  QIL  : QidList .
  var  Ct : Constant .
  var  AtS : AttrSet .
  vars QI F : Qid .
  var  CD? : [Condition] .
  vars S S' : Sort .
  var  TyL : TypeList .

  op parseSort : Term ~> Sort .
  op parseType : Term ~> Type .
  op parseSortSet : Term ~> SortSet .
  op parseTypeList : Term ~> TypeList .
  op parseViewExp : Term ~> ViewExp .
  op parseParameterList : Term ~> ParameterList .

  eq parseSort('sortToken[T]) 
    = if downQid(T) :: Type 
      then downQid(T)
      else qidError('\r 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
      fi .
  eq parseSort('_`{_`}[T, T']) 
    = qid(string(parseSort(T)) 
          + "{" + string(parameterList2Qid(parseParameterList(T'))) + "}") .
  eq parseSort(T) = qidError('\r 'Warning: '\o 'invalid 'sort. '\n) [owise] .

  eq parseType('`[_`][T]) 
    ---- = kind(parseSort(T)) .
    = qid("[" + string(parseSort(T)) + "]") .
  eq parseType(T) = parseSort(T) [owise] .

  eq parseSortSet('__[T, T']) = (parseSort(T) ; parseSortSet(T')) .
  eq parseSortSet(T) = parseSort(T) [owise].

  eq parseTypeList('__[T, T']) = (parseType(T) parseTypeList(T')) .
  eq parseTypeList(T) = parseType(T) [owise] .

  eq parseViewExp('viewToken[T]) 
    = if downQid(T) :: Sort 
      then downQid(T)
      else qidError('\r 'Warning: '\o downQid(T) 'is 'not 'a 'valid 'sort. '\n)
      fi .
  eq parseViewExp('_`{_`}[T, T']) 
    = parseViewExp(T){parseParameterList(T')} .
  eq parseViewExp(T) 
    = qidError('\r 'Warning: '\o 'invalid 'view 'expression. '\n) 
    [owise] .

  eq parseParameterList('_`,_[T, T']) 
    = parseViewExp(T), parseParameterList(T') .
  eq parseParameterList(T) = parseViewExp(T) [owise] .

*** The function \texttt{parseModExp} takes a term representing a 
*** module expression and returns the corresponding term in sort 
*** \texttt{ModuleExpression}. In case of adding new constructors for module 
*** expressions, as it will be done in Section~\ref{extension}, new equations d
*** efining the semantics of the function on them will have to be given.

  op parseModExp : Term -> ModuleExpression .
  op parseMaps : Term -> RenamingSet .

  op parseAttrs : Term -> AttrSet .

  eq parseModExp('token[T]) = downQid(T) .
  eq parseModExp('`(_`)[T]) = parseModExp(T) .
  eq parseModExp('_`{_`}[T, T']) 
    = _`{_`}(parseModExp(T), parseParameterList(T')) .
  eq parseModExp('_*`(_`)[T, T']) = _*`(_`)(parseModExp(T), parseMaps(T')) .
  eq parseModExp('_+_[T, T']) = parseModExp(T) + parseModExp(T') .
  eq parseModExp('TUPLE`[_`]['token[T]]) = TUPLE[parseNat(T)] .
  eq parseModExp('POWER`[_`]['token[T]]) = POWER[parseNat(T)] .

  eq parseMaps('_`,_[T, T']) = (parseMaps(T), parseMaps(T')) .

  eq parseMaps('sort_to_[T, T']) = (sort parseType(T) to parseType(T')) .
  eq parseMaps('label_to_['token[T], 'token[T']]) 
    = (label downQid(T) to downQid(T')) .
  eq parseMaps('class_to_[T, T']) = (class parseType(T) to parseType(T')) .
  eq parseMaps('attr_._to_[T, 'token[T'], 'token[T'']])
    = (attr downQid(T') . parseType(T) to downQid(T'')) .
  eq parseMaps('msg_to_['token[T], 'token[T']]) 
    = (msg downQid(T) to downQid(T')) .
  eq parseMaps('msg_:_->_to_['token[T], T', T'', 'token[T3]])
    = (msg downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3)) .
  eq parseMaps('msg_:`->_to_['token[T], T', 'token[T'']])
    = (msg downQid(T) : nil -> parseType(T') to downQid(T'')) .
  eq parseMaps('op_to_`[_`]['token[T], 'token[T'], T''])
    = (op downQid(T) to downQid(T') [parseAttrs(T'')]) .
  eq parseMaps('op_:_->_to_`[_`]['token[T], T', T'', 'token[T3], T4])
    = (op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) 
            [parseAttrs(T4)]) .
  eq parseMaps('op_:`->_to_`[_`]['token[T], T', 'token[T''], T3])
    = (op downQid(T) : nil -> parseType(T') to downQid(T'') 
          [parseAttrs(T3)]) .
  eq parseMaps('op_:_~>_to_`[_`]['token[T], T', T'', 'token[T3], T4])
    = (op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T'')) 
            to downQid(T3) [parseAttrs(T4)]) .
  eq parseMaps('op_:`~>_to_`[_`]['token[T], T', 'token[T''], T3])
    = (op downQid(T) : nil -> kind(parseType(T')) to downQid(T'') 
          [parseAttrs(T3)]) .
  eq parseMaps('op_to_['token[T], 'token[T']]) 
    = (op downQid(T) to downQid(T') [none]) .
  eq parseMaps('op_:_->_to_['token[T], T', T'', 'token[T3]])
    = (op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) 
          [none]) .
  eq parseMaps('op_:`->_to_['token[T], T', 'token[T'']])
    = (op downQid(T) : nil -> parseType(T') to downQid(T'') [none]) .
  eq parseMaps('op_:_~>_to_['token[T], T', T'', 'token[T3]])
    = (op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T'')) 
          to downQid(T3) [none]) .
  eq parseMaps('op_:`~>_to_['token[T], T', 'token[T'']])
    = (op downQid(T) : nil -> kind(parseType(T')) to downQid(T'') [none]) .

  eq parseAttrs('__[T, T']) = (parseAttrs(T) parseAttrs(T')) .
  eq parseAttrs('assoc.@Attr@) = assoc .
  eq parseAttrs('associative.@Attr@) = assoc .
  eq parseAttrs('comm.@Attr@) = comm .
  eq parseAttrs('commutative.@Attr@) = comm .
  eq parseAttrs('idem.@Attr@) = idem .
  eq parseAttrs('idempotent.@Attr@) = idem .
  eq parseAttrs('id:_[T]) = none .
  eq parseAttrs('identity:_[T]) = none .
  eq parseAttrs('left`id:_[T]) = none .
  eq parseAttrs('left`identity:_[T]) = none .
  eq parseAttrs('right`id:_[T]) = none .
  eq parseAttrs('right`identity:_[T]) = none .
  eq parseAttrs('poly`(_`)[T]) = poly(parseInt(T)) .
  eq parseAttrs('strat`(_`)[T]) = none .
  eq parseAttrs('strategy`(_`)[T]) = none .
  eq parseAttrs('memo.@Attr@) = none .
  eq parseAttrs('memoization.@Attr@) = none .
  eq parseAttrs('prec_['token[T]]) = prec(parseNat(T)) .
  eq parseAttrs('precedence_['token[T]]) = prec(parseNat(T)) .
  eq parseAttrs('prec_['`(_`)['token[T]]]) = prec(parseNat(T)) .
  eq parseAttrs('precedence_['`(_`)['token[T]]]) = prec(parseNat(T)) .
  eq parseAttrs('gather`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrs('gathering`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrs('format`(_`)['neTokenList[T]]) = none .
  eq parseAttrs('ctor.@Attr@) = ctor .
  eq parseAttrs('constructor.@Attr@) = ctor .
  eq parseAttrs('frozen.@Attr@) = none .
  eq parseAttrs('frozen`(_`)[T]) = none .
  eq parseAttrs('iter.@Attr@) = iter .
  eq parseAttrs('ditto.@Attr@) = ditto .
  eq parseAttrs('special`(_`)[T]) = parseSpecial(parseHookList(T)) .
  eq parseAttrs('config.@Attr@) = config .
  eq parseAttrs('object.@Attr@) = object .
  eq parseAttrs('msg.@Attr@) = msg .
  eq parseAttrs('message.@Attr@) = msg .
  eq parseAttrs('metadata_['token[T]]) = metadata(downString(downQid(T))) .
  eq parseAttrs('variant.@Attr@) = variant .
  eq parseAttrs('nonexec.@Attr@) = nonexec .

  op parseSpecial : Set<Hook> -> Attr .
  op parseHookList : Term -> Set<Hook> .
  op hookList : Set<Hook> -> HookList .
  sort Set<Hook> .
  subsort Hook < Set<Hook> .
  op none : -> Set<Hook> .
  op _._ : Set<Hook> Set<Hook> -> Set<Hook> [assoc comm id: none] .
  var  SH : Set<Hook> .
  var  H : Hook .

  eq parseSpecial(none) = none .
  eq parseSpecial(SH) = special(hookList(SH)) [owise] .

  eq parseHookList('__[T, TL]) = parseHookList(T) . parseHookList(TL) .
  eq parseHookList('id-hook_['token[T]]) = id-hook(downQid(T), nil) .
  eq parseHookList('id-hook_`(_`)['token[T], 'neTokenList[T']])
    = id-hook(downQid(T), downQidList(T')) .
  eq parseHookList(
       'op-hook_`(_:_->_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parseHookList('op-hook_`(_:`->_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parseHookList(
       'op-hook_`(_:_~>_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parseHookList('op-hook_`(_:`~>_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parseHookList('term-hook_`(_`)['token[T], T']) = none .

  eq hookList(H) = H .
  eq hookList(H . SH) = H hookList(SH) [owise] .

*** Given a term representing a machine integer, the function 
*** \texttt{parseInt} returns the corresponding integer.

  op parseNat : Term -> Nat .

  op parseInt : Term -> Int .
  op parseInt : TermList -> IntList .

  eq parseInt(('neTokenList['__[TL]], TL')) = parseInt(TL) parseInt(TL') .
  eq parseInt(('neTokenList[QI], TL)) = parseInt(QI) parseInt(TL) .
  eq parseInt(empty) = nil .

  eq parseInt((T, TL)) = parseInt(T) parseInt(TL) [owise] .
  eq parseInt(nil) = nil .

  eq parseInt(Ct) 
    = downNat(
        qid(substr(string(getName(Ct)), 1, length(string(getName(Ct)))) 
            + ".Int")) .

  eq parseNat(Ct) 
    = downNat(
        qid(substr(string(getName(Ct)), 1, length(string(getName(Ct)))) 
            + ".Nat")) .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing of Bubbles
***

*** In the following module \texttt{BUBBLE-PARSING}, the definitions for the
*** basic processing of bubbles are introduced. In it we declare a function
*** \texttt{solveBubbles} which takes a bubble and some other arguments and 
*** returns the term resulting from parsing it.


-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod BUBBLE-PARSING is
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr MOD-EXP-PARSING .
  pr PRINT-SYNTAX-ERROR .

  vars T T' : Term .
  vars M M' : Module .
  var  B : Bool .
  var  QIL : QidList .
  vars DB DB' : Database .
  var  TL : TermList .
  var  S : Sort .
  vars QI QI' F : Qid .
  var  VDS : OpDeclSet .
  var  C : Constant .
  var  V : Variable .
  var  N : Nat .
  var  Tp : Type .
  var  RP : [ResultPair] .
  var  MN : ModuleName .
  var  ME : ModuleExpression .
  var  U : Module .
  var  Cond : Condition .

  op resultPairError : QidList -> [ResultPair] [ctor] .

*** As we shall see in Section~\ref{evaluation}, a declaration importing the
*** predefined module \texttt{UP} (see Section~\ref{non-built-in-predefined})
*** is added to all modules importing the \texttt{META-LEVEL} module. The
*** \texttt{solveBubbles} function is called with a `flag' indicating whether
*** the module can contain calls to the \texttt{up} function or not. Thus,
*** when we call \texttt{metaParse} with some bubble and the module in which
*** such bubble has to be parsed, if there are occurrences of the function
*** \texttt{up} in it, they will be of the form \verb~'token[T]]~ or 
*** \verb~'up['token[T], 'bubble[T']]~ for terms \texttt{T} and \texttt{T'}. 
*** The function \texttt{solveUps} will evaluate them.

  op solveBubbles : Term Module Bool OpDeclSet Database -> [Term] .
  op solveUps : TermList Database -> [TermList] .
  op solveUpsCondition : Condition Database -> Condition .
  op solveUpsModExp : TermList Database -> [TermList] .
  op constsToVars : Term OpDeclSet -> Term [memo] .
  op constsToVars : TermList OpDeclSet -> TermList [memo] .
  op constsToVarsAux : Constant OpDeclSet -> Qid [memo] .

  eq constsToVars(F[TL], VDS) = F[constsToVars(TL, VDS)] .
  eq constsToVars(C, VDS) = constsToVarsAux(C, VDS) .
  eq constsToVars(V, VDS) = V . 
  eq constsToVars(qidError(QIL), VDS) = qidError(QIL) . 
  ceq constsToVars((T, TL), VDS) 
    = (constsToVars(T, VDS), constsToVars(TL, VDS)) 
    if TL =/= empty .

  eq constsToVarsAux(C, (op F : nil -> Tp [none] .) VDS) 
    = if getName(C) == F 
      then qid(string(F) + ":" + string(Tp))
      else constsToVarsAux(C, VDS)
      fi .
  eq constsToVarsAux(C, none) = C .

  ceq solveBubbles('bubble[T], M, true, VDS, DB) 
    *** if META-LEVEL is a submodule the ups need to be solved
    = if RP :: ResultPair
      then solveUps(constsToVars(getTerm(RP), VDS), DB)
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                    '\r 'Error: '\o 'no 'parse 'for QIL '\n)
      fi 
    if M' := addOps(VDS, M) 
       /\ QIL := downQidList(T)
       /\ RP := metaParse(M', QIL, anyType) .

  ceq solveBubbles('bubble[T], M, false, VDS, DB) 
    = if RP :: ResultPair
      then constsToVars(getTerm(RP), VDS) 
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n
                    '\r 'Error: '\o 'no 'parse 'for QIL '\n)
      fi 
    if M' := addOps(VDS, M) 
       /\ QIL := downQidList(T)
       /\ RP := metaParse(M', QIL, anyType) .

*** The \texttt{solveBubbles1} function is in charge of calling the function 
*** \texttt{metaParse}. The flag indicating the inclusion of the module  
*** \texttt{META-LEVEL} in the module in which the term appears decides 
*** whether the function \texttt{solveUps} is called or not, so the extra 
*** price of searching for calls to the \texttt{up} function is paid only 
*** when an occurrence of the function is possible. This function takes care 
*** of the occurrences of the \texttt{up} function that may exist in such 
*** bubbles.

*** The function \texttt{solveUps} goes through the term looking for a term
*** with \texttt{'up} as top operator and \texttt{'token} as top operator of
*** its unique argument if there is only one argument, or with \texttt{'token}
*** and \texttt{'bubble} as top operators of its first and second arguments,
*** respectively, if there are two. If a term of the form
*** \mbox{\texttt{'up['token[T]]}} is reached, it is replaced by the
*** metarepresentation of the flat version of the module in the database with
*** the name given by the token. If a term of form 
*** \mbox{\texttt{'up['token[T], 'bubble[T']]}} is reached, the 
*** metarepresentation of the result of parsing the bubble in the signature 
*** of the module with the name given by the token, after solving possible 
*** nested calls to the \texttt{up} function, is returned.

  eq solveUps(QI, DB) = QI .
  eq solveUps(F[TL], DB) = F[solveUps(TL, DB)] [owise] .
  ceq solveUps((T, TL), DB) 
    = (solveUps(T, DB), solveUps(TL, DB)) 
    if TL =/= empty .

  eq solveUps('upModule['token[T]], DB) 
    = solveUpsModExp('upModule['token[T]], DB) .
  eq solveUps('upModule['`(_`)[T]], DB) 
    = solveUpsModExp('upModule['`(_`)[T]], DB) .
  eq solveUps('upModule['_`{_`}[T, T']], DB) 
    = solveUpsModExp('upModule['_`{_`}[T, T']], DB) .
  eq solveUps('upModule['_*`(_`)[T, T']], DB) 
    = solveUpsModExp('upModule['_*`(_`)[T, T']], DB) .
  eq solveUps('upModule['_+_[T, T']], DB) 
    = solveUpsModExp('upModule['_+_[T, T']], DB) .
  eq solveUps('upModule['TUPLE`[_`]['token[T]]], DB) 
    = solveUpsModExp('upModule['TUPLE`[_`]['token[T]]], DB) .
  eq solveUps('upModule['POWER`[_`]['token[T]]], DB) 
    = solveUpsModExp('upModule['POWER`[_`]['token[T]]], DB) .

  eq solveUpsCondition(T = T' /\ Cond, DB)  
    = solveUps(T, DB) = solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T : S /\ Cond, DB)  
    = solveUps(T, DB) : S /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T := T' /\ Cond, DB)  
    = T := solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(T => T' /\ Cond, DB)  
    = solveUps(T, DB) => solveUps(T', DB) /\ solveUpsCondition(Cond, DB) .
  eq solveUpsCondition(nil, DB) = nil .

  ceq solveUpsModExp('upModule[T], DB)
    = up(getFlatModule(MN, DB'))
    if < DB' ; MN > := evalModExp(parseModExp(T), DB) 
    /\ unitInDb(MN, DB') .
  ceq solveUpsModExp('upModule[T], DB)
    = qidError('\r 'Error: '\o 'Module header2QidList(MN) 'not 'in 'database. '\n)
    if MN := parseModExp(T)
    [owise] .

  eq solveUps('upTerm['token[T], 'bubble[T']], DB) 
    = solveUpsModExp('upTerm['token[T], 'bubble[T']], DB) .
  eq solveUps('upTerm['`(_`)[T], 'bubble[T']], DB) 
    = solveUpsModExp('upTerm['`(_`)[T], 'bubble[T']], DB) .
  eq solveUps('upTerm['_`{_`}[T, T'], 'bubble[T']], DB) 
    = solveUpsModExp('upTerm['_`{_`}[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['_*`(_`)[T, T'], 'bubble[T']], DB) 
    = solveUpsModExp('upTerm['_*`(_`)[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['_+_[T, T'], 'bubble[T']], DB) 
    = solveUpsModExp('upTerm['_+_[T, T'], 'bubble[T']], DB) .
  eq solveUps('upTerm['TUPLE`[_`]['token[T]], 'bubble[T']], DB) 
    = solveUpsModExp('upTerm['TUPLE`[_`]['token[T]], 'bubble[T']], DB) .
  eq solveUps('upTerm['POWER`[_`]['token[T]], 'bubble[T']], DB) 
    = solveUpsModExp('upTerm['POWER`[_`]['token[T]], 'bubble[T']], DB) .

  ceq solveUpsModExp('upTerm[T, 'bubble[T']], DB)
    = if included('META-MODULE, getImports(getInternalModule(MN, DB')), DB')
      then if metaParse(U, QIL, anyType) :: ResultPair
           then up(solveUps(getTerm(metaParse(U, QIL, anyType)), DB'))
           else qidError('\r 'Warning: '\o 
                  'No 'parse 'for 'argument 'of 'up
                  printSyntaxError(metaParse(U, QIL, anyType), QIL) 
                  '\n)
           fi
      else if metaParse(U, QIL, anyType) :: ResultPair
           then up(getTerm(metaParse(U, QIL, anyType)))
           else qidError('\r 'Warning: '\o 
                  'No 'parse 'for 'argument 'of 'up
                  printSyntaxError(metaParse(U, QIL, anyType), QIL) 
                  '\n)
           fi
      fi
    if < DB' ; MN > := evalModExp(parseModExp(T), DB) 
       /\ U := getFlatModule(MN, DB') 
       /\ QIL := downQidList(T').
  ceq solveUpsModExp('upTerm[T, 'bubble[T']], DB)
    = qidError('\r 'Error: 'op '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    if ME := parseModExp(T)
    [owise] .

  eq solveUps('`[_`][QI], DB) = '`[_`][QI] .
  ceq solveUps('`[_`]['token[T]], DB)
    = up(getFlatModule(QI, database(evalModExp(QI, DB))))
    if QI := downQid(T) .
  eq solveUps('`[_`][F[TL]], DB) = '`[_`][F[solveUps(TL, DB)]] [owise] .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Parsing the Bubbles in a Module
***

*** The \texttt{solveBubbles} function defined in the
*** \texttt{UNIT-BUBBLE-PARSING} module takes a term of sort \texttt{Module} (a
*** preunit in fact) and a signature, and returns the unit resulting from the 
*** evaluation (parsing) of all the bubbles in it.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

view AttrSet from TRIV to META-LEVEL is 
  sort Elt to AttrSet .
endv


fmod UNIT-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr PRINT-SYNTAX-ERROR .

  vars T T' T'' T3 T4 : Term .
  vars T? T?' : [Term] .
  vars TL TL' TL'' : TermList .
  vars TL? TL?' : [TermList] .
  var  B : Bool .
  vars M M' M'' : Module .
  var  DB : Database .
  vars PU U U' : Module .
  var  K : Kind .
  var  KS : KindSet .
  vars S S' : Sort .
  var  SS : SortSet .
  var  VE : ViewExp .
  vars Ty Ty' Tp : Type .
  vars TyL TyL' : TypeList .
  var  At : Attr .
  vars AtS AtS' AtS'' : AttrSet .
  var  NL : IntList .
  var  QI QI' QI'' QI3 QI4 QI5 F L : Qid .
  vars QIL QIL' : QidList .
  var  I : Nat .
  var  Hk : Hook .
  var  HkL : HookList .
  var  MAS : MembAxSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  OPD : OpDecl .
  vars OPDS OPDS' OPDS'' VDS : OpDeclSet .
  var  CD? : [Condition] .
  var  Ct : Constant .
  var  RP : [ResultPair] .
  var  St : String .

*** In the parsing of bubbles themselves, we consider three different cases: 
*** The case of having one single bubble in which no context is 
*** considered (used to parse bubbles in term maps in views and in the 
*** special attributes of operators); the case of two bubbles to be parsed in 
*** the same connected component (used for bubbles in equations and rules), 
*** and the case of one bubble to be parsed in a specific sort (used for the 
*** bubbles appearing in the identity element attributes in the declarations 
*** of operators, and in membership axioms). These three cases are reduced to 
*** the case of one single bubble without context, which is handled by the 
*** function \texttt{solveBubbles3}.

  op solveBubblesEq : Term Term Module Bool OpDeclSet Database -> Term .
  op solveBubblesCEq : Term Term Module Bool OpDeclSet Database -> Term .
  op solveBubblesRl : Term Term Module Bool OpDeclSet Database -> Term .
  op solveBubblesCRl : Term Term Module Bool OpDeclSet Database -> Term .
  op solveBubbles2 : Term [Type] Module Bool OpDeclSet Database -> Term .
  op solveBubblesCond : Term Module Module Bool OpDeclSet Database -> [Condition] .

  op conditionError : QidList -> [Condition] [ctor format (r o)] .

*** The case of two bubbles, generated in the case of equations and rules, is 
*** reduced to the case with one single bubble using the polymorphic operator
*** \verb~_==_~ and enclosing each of the bubbles in parentheses. Below, we 
*** shall see how after calling this function the terms corresponding to each 
*** of the bubbles is extracted.

  ceq solveBubblesEq('bubble[T], 'bubble[T'], M, B, VDS, DB)
    = if RP :: ResultPair
      then if B 
           then solveUps(constsToVars(getTerm(RP), VDS), DB) 
           else constsToVars(getTerm(RP), VDS) 
           fi 
      else qidError('\r 'Warning: 
                 '\o printSyntaxError(RP, '`( QIL '`) '= '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'eq QIL '\s '= '\s QIL' '\n)
      fi 
    if M' := addOps((VDS
                     op '_@@@=@@@_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .), 
               addSorts('@@@, M)) 
       /\ QIL := downQidList(T) 
       /\ QIL' := downQidList(T') 
       /\ RP := metaParse(M', '`( QIL '`) '@@@=@@@ '`( QIL' '`), '@@@) .

  ceq solveBubblesCEq('bubble[T], 'bubble[T'], M, B, VDS, DB)
    = if RP :: ResultPair
      then if B 
           then solveUps(constsToVars(getTerm(RP), VDS), DB) 
           else constsToVars(getTerm(RP), VDS) 
           fi 
      else qidError('\r 'Warning: 
                 '\o printSyntaxError(RP, '`( QIL '`) '= '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'ceq QIL '\s '= '\s QIL' '\n)
      fi 
    if M' := addOps((VDS
                     op '_@@@=@@@_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .), 
               addSorts('@@@, M)) 
       /\ QIL := downQidList(T) 
       /\ QIL' := downQidList(T') 
       /\ RP := metaParse(M', '`( QIL '`) '@@@=@@@ '`( QIL' '`), '@@@) .

  ceq solveBubblesRl('bubble[T], 'bubble[T'], M, B, VDS, DB)
    = if RP :: ResultPair
      then if B 
           then solveUps(constsToVars(getTerm(RP), VDS), DB) 
           else constsToVars(getTerm(RP), VDS) 
           fi 
      else qidError('\r 'Warning: 
                 '\o printSyntaxError(RP, '`( QIL '`) '=> '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'rl QIL '\s '=> '\s QIL' '\n)
      fi 
    if M' := addOps((VDS
                     op '_@@@=>@@@_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .), 
               addSorts('@@@, M)) 
       /\ QIL := downQidList(T) 
       /\ QIL' := downQidList(T') 
       /\ RP := metaParse(M', '`( QIL '`) '@@@=>@@@ '`( QIL' '`), '@@@) .
  ceq solveBubblesCRl('bubble[T], 'bubble[T'], M, B, VDS, DB)
    = if RP :: ResultPair
      then if B 
           then solveUps(constsToVars(getTerm(RP), VDS), DB) 
           else constsToVars(getTerm(RP), VDS) 
           fi 
      else qidError('\r 'Warning: 
                 '\o printSyntaxError(RP, '`( QIL '`) '=> '`( QIL' '`)) '\n
                 '\r 'Error: '\o 'no 'parse 'for 'crl QIL '\s '=> '\s QIL' '\n)
      fi 
    if M' := addOps((VDS
                     op '_@@@=>@@@_ : 'Universal 'Universal -> '@@@ [poly(1 2)] .), 
               addSorts('@@@, M)) 
       /\ QIL := downQidList(T) 
       /\ QIL' := downQidList(T') 
       /\ RP := metaParse(M', '`( QIL '`) '@@@=>@@@ '`( QIL' '`), '@@@) .


  ceq solveBubbles2('bubble[T], T?:Type?, M, true, VDS, DB)
    = if RP :: ResultPair
      then solveUps(constsToVars(getTerm(RP), VDS), DB)
      else qidError('\r 'Warning: 
                 '\o printSyntaxError(RP, QIL) '\n 
                 '\r 'Error: 'No 'parse 'for QIL '\n)
      fi 
    if QIL := downQidList(T) 
       /\ RP := metaParse(M, QIL, T?:Type?) .
  ceq solveBubbles2('bubble[T], T?:Type?, M, false, VDS, DB)
    = if RP :: ResultPair
      then constsToVars(getTerm(RP), VDS) 
      else qidError('\r 'Warning: '\o printSyntaxError(RP, QIL) '\n 
                 '\r 'Error: 'No 'parse 'for QIL '\n)
      fi 
    if QIL := downQidList(T) 
       /\ RP := metaParse(M, QIL, T?:Type?) .

  op addInfoConds : Module -> [Module] .
  op addInfoConds : Module SortSet -> Module . 

  eq addInfoConds(M) = addInfoConds(M, getAllSorts(M)) .

  eq addInfoConds(M, '@Token@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, '@Bubble@ ; SS) = addInfoConds(M, SS) .
  eq addInfoConds(M, S ; SS)
    = addInfoConds(
        addOps(op qid(string(S)) : nil -> '@Sort@ [ctor] .
               op '_:_ : S '@Sort@ -> '@Condition@ [ctor prec(71)] ., M), 
        SS) 
    [owise] .
  eq addInfoConds(M, none) 
    = addOps(op '_/\_ : '@Condition@ '@Condition@ -> '@Condition@ 
                               [ctor assoc prec(73)] .
             op '_=_  : 'Universal 'Universal -> '@Condition@ 
                               [ctor poly(1 2) prec(71)] .
             op '_:=_ : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) prec(71)] .
             op '_=>_ : 'Universal 'Universal -> '@Condition@
                               [ctor poly(1 2) prec(71)] .,
        addSorts('@Condition@ ; '@Sort@, 
          if 'Bool in getSorts(M)
          then addSubsorts(subsort 'Bool < '@Condition@ ., M)
          else M
          fi)) .

  ceq solveBubblesCond('bubble[T], M, M', B, VDS, DB)
    = if 'Bool in getSorts(M) 
         and-then metaParse(M, QIL, 'Bool) :: ResultPair
      then if B 
           then solveUps(constsToVars(getTerm(metaParse(M, QIL, 'Bool)), VDS), DB) 
                = 'true.Bool
           else constsToVars(getTerm(metaParse(M, QIL, 'Bool)), VDS) 
                = 'true.Bool
           fi
      else if metaParse(M', QIL, '@Condition@) :: ResultPair
           then if B 
                then solveUpsCondition(
                       parseCond(getTerm(metaParse(M', QIL, '@Condition@)), VDS), DB)
                else parseCond(getTerm(metaParse(M', QIL, '@Condition@)), VDS)
                fi
           else conditionError('\r 'Warning: '\o 
                  printSyntaxError(metaParse(M', QIL, '@Condition@), QIL) '\n)
           fi
      fi 
    if QIL := downQidList(T) .

  op parseCond : Term OpDeclSet -> Condition .

  eq parseCond('_/\_[T, T'], VDS) = parseCond(T, VDS) /\ parseCond(T', VDS) .
  eq parseCond('_=_[T, T'], VDS) 
    = constsToVars(T, VDS) = constsToVars(T', VDS) .
  eq parseCond('_:_[T, T'], VDS) = constsToVars(T, VDS) : getName(T') .
  eq parseCond('_:=_[T, T'], VDS) 
    = constsToVars(T, VDS) := constsToVars(T', VDS) .
  eq parseCond('_=>_[T, T'], VDS) 
    = constsToVars(T, VDS) => constsToVars(T', VDS) .
  eq parseCond(T, VDS) = constsToVars(T, VDS) = 'true.Bool [owise] .

*** Since bubbles can only appear in the identity or special attributes in the 
*** declaration of operators, in equations, membership axioms, and rules, the 
*** evaluation of bubbles on a preunit is reduced to calls to the 
*** \texttt{solveBubbles} functions on each of these sTS of declarations.

  op solveBubblesMod : Module OpDeclSet Module Bool OpDeclSet Database -> Module .

  op solveBubbles : EquationSet Module [Module] Bool OpDeclSet Database -> EquationSet .
  op solveBubbles : RuleSet Module [Module] Bool OpDeclSet Database -> RuleSet .
  op solveBubbles : MembAxSet Module [Module] Bool OpDeclSet Database -> MembAxSet .
  op solveBubbles : Condition Module Bool OpDeclSet Database -> Condition .
  op solveBubblesOps : OpDeclSet OpDeclSet Module Module -> OpDeclSet .
  op solveBubblesOps : OpDeclSet OpDeclSet Module -> OpDeclSet .
  op solveBubblesOpsAux : OpDeclSet Module -> OpDeclSet .
  op solveBubblesAts : AttrSet TypeList Type Module -> AttrSet .
  op solveBubblesHooks : HookList Type Module -> HookList .

  ceq solveBubblesMod(PU, OPDS, M, B, VDS, DB)
    = setOps(
       (if getMbs(PU) == none and getEqs(PU) == none and getRls(PU) == none
        then PU
        else setEqs(
               setMbs(
                 setRls(PU, 
                   solveBubbles(getRls(PU), M', addInfoConds(M'), B, VDS, DB)),
                 solveBubbles(getMbs(PU), M', addInfoConds(M'), B, VDS, DB)),
               solveBubbles(getEqs(PU), M', addInfoConds(M'), B, VDS, DB))
        fi),
       solveBubblesOps(getOps(PU), OPDS, M'))
    if M' := addOps(VDS, M) . 

*** To avoid the parsing ambiguities in the identity elements we add the sort 
*** of the operator to be used as context in which doing the parsing. We
*** assume that the term given as identity element of an operator is in the 
*** kind of the sort of such operator.

  eq solveBubblesOps(OPDS, OPDS', M)
    = solveBubblesOps(OPDS, OPDS', 
        setSubsorts(
          setSorts(emptyFModule('DUMMY), getSorts(M)), getSubsorts(M)), M) .

  ceq solveBubblesOps(op F : TyL -> Ty [ditto AtS] . op F : TyL' -> Ty' [AtS'] . OPDS, OPDS', M, M')
    = solveBubblesOps(
        op F : TyL -> Ty [AtS removeCtorMetadata(AtS'')] . op F : TyL' -> Ty' [AtS''] . OPDS, 
        OPDS', M, M')
    if not ditto in AtS'
    /\ sameKind(M, TyL Ty, TyL' Ty') 
----    /\ AtS'' := solveBubblesAts(AtS', TyL', Ty', M') .
    /\ AtS'' := AtS' .
  ceq solveBubblesOps(op F : TyL -> Ty [ditto AtS] . OPDS, op F : TyL' -> Ty' [AtS'] . OPDS', M, M')
    = solveBubblesOps(op F : TyL -> Ty [AtS removeCtorMetadata(AtS'')] . OPDS, op F : TyL' -> Ty' [AtS''] . OPDS', M, M')
    if not ditto in AtS'
    /\ sameKind(M, TyL Ty, TyL' Ty') 
----       /\ AtS'' := solveBubblesAts(AtS', TyL, Ty, M') 
    /\ AtS'' := AtS' .
----    [owise] .
  eq solveBubblesOps(OPDS, OPDS', M, M') 
    = solveBubblesOpsAux(OPDS, M') 
    [owise] .

  op removeCtorMetadata : AttrSet -> AttrSet .
  eq removeCtorMetadata(ctor AtS) = removeCtorMetadata(AtS) .
  eq removeCtorMetadata(metadata(St) AtS) = removeCtorMetadata(AtS) .
  eq removeCtorMetadata(AtS) = AtS [owise] .
  
  eq solveBubblesOpsAux(op F : TyL -> Ty [AtS] . OPDS, M)
    = op F : TyL -> Ty [solveBubblesAts(AtS, TyL, Ty, M)] .
      solveBubblesOpsAux(OPDS, M) .
  eq solveBubblesOpsAux(none, M) = none .

  eq solveBubblesAts(id('bubble[T]) AtS, TyL, Ty, M)
    = (id(solveBubbles2('bubble[T], Ty, M, false, none, emptyDatabase)) 
       solveBubblesAts(AtS, TyL, Ty, M)) .
  eq solveBubblesAts(left-id('bubble[T]) AtS, Ty TyL, Ty', M)
    = (left-id(solveBubbles2('bubble[T], Ty, M, false, none, emptyDatabase)) 
       solveBubblesAts(AtS, Ty TyL, Ty', M)) .
  eq solveBubblesAts(right-id('bubble[T]) AtS, TyL Ty, Ty', M)
    = (right-id(solveBubbles2('bubble[T], Ty, M, false, none, emptyDatabase)) 
       solveBubblesAts(AtS, TyL Ty, Ty', M)) .
  eq solveBubblesAts(special(HkL) AtS, TyL, Ty, M)
    = (special(solveBubblesHooks(HkL, Ty, M)) 
       solveBubblesAts(AtS, TyL, Ty, M)) .
  eq solveBubblesAts(AtS, TyL, Ty, M) = AtS [owise] .

  eq solveBubblesHooks(term-hook(QI, 'bubble[T]) HkL, Ty, M)
    = term-hook(QI, 
        solveBubbles2('bubble[T], anyType, M, false, none, emptyDatabase)) 
      solveBubblesHooks(HkL, Ty, M) .
  eq solveBubblesHooks(Hk HkL, Ty, M) 
    = Hk solveBubblesHooks(HkL, Ty, M) 
    [owise] .
  eq solveBubblesHooks(nil, Ty, M) = nil .

*** Since both sides of any equation or rule have to be in the same connected
*** component of sorts, we parse the two bubbles together using the
*** polymorphic operator \verb~_==_~\footnote{Note that if including
*** \texttt{BOOL} the operator \texttt{\_\,==\_\,} is added for each kind.}.
*** That is, given for example an equation as \verb~eq T = T' .~, we parse
*** \verb~T == T'~, forcing them to be parsed in the same connected component,
*** if possible. We add functions \texttt{lhs} and \texttt{rhs} to extract, 
*** respectively, the lefthand and righthand side terms from the result. Note 
*** that these are partial functions.

  pr 2TUPLE{Term,AttrSet} 
       * (op p1_ to term, op p2_ to attrSet, 
          op `(_`,_`) : Term AttrSet -> Tuple{Term,AttrSet} to `{_`,_`}) .

  op pullStmtAttrOut : Term OpDeclSet -> [Tuple{Term,AttrSet}] .
  op pullStmtAttrOutAux : Term TermList AttrSet OpDeclSet -> [Tuple{Term,AttrSet}] .
  op pullLabelOut : Term -> [Tuple{Term,AttrSet}] .

  eq pullStmtAttrOut('bubble[QI], VDS) = {'bubble[QI], none} .
  eq pullStmtAttrOut('bubble['__[QI, QI']], VDS) = {'bubble['__[QI, QI']], none} .
  eq pullStmtAttrOut('bubble['__[QI, QI', QI'']], VDS) 
    = {'bubble['__[QI, QI', QI'']], none} .
  eq pullStmtAttrOut('bubble['__[QI, QI', TL, QI'']], VDS) 
    = if QI'' =/= ''`].Qid 
      then {'bubble['__[QI, QI', TL, QI'']], none}
      else pullStmtAttrOutAux('bubble['__[QI, QI', TL, QI'']], (QI, QI', TL), none, VDS) 
      fi .

  eq pullStmtAttrOutAux(T, (TL, ''`[.Qid), AtS, VDS) 
    = if AtS =/= none 
      then {'bubble['__[TL]], AtS}
      else {T, none}
      fi . 
  eq pullStmtAttrOutAux(T, (TL, QI, ''nonexec.Qid), AtS, VDS) 
    = pullStmtAttrOutAux(T, (TL, QI), AtS nonexec, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''variant.Qid), AtS, VDS) 
    = pullStmtAttrOutAux(T, (TL, QI), AtS variant, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''owise.Qid), AtS, VDS) 
    = pullStmtAttrOutAux(T, (TL, QI), AtS owise, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''otherwise.Qid), AtS, VDS) 
    = pullStmtAttrOutAux(T, (TL, QI), AtS owise, VDS) .
  eq pullStmtAttrOutAux(T, (TL, QI, ''label.Qid, QI'), AtS, VDS) 
    = if downQid(QI') :: Qid
      then pullStmtAttrOutAux(T, (TL, QI), AtS label(downQid(QI')), VDS)
      else {T, none}
      fi .
  eq pullStmtAttrOutAux(T, (TL, QI, ''metadata.Qid, QI'), AtS, VDS) 
    = if downString(downQid(QI')) :: String
      then pullStmtAttrOutAux(T, (TL, QI), AtS metadata(downString(downQid(QI'))), VDS)
      else {T, none}
      fi .
  ceq pullStmtAttrOutAux(T, (TL, QI, ''`[.Qid, TL',  ''print.Qid, TL''), AtS, VDS) 
    = pullStmtAttrOutAux(T, (TL, QI, ''`[.Qid, TL'), AtS print(printArg(TL'', VDS)), VDS) 
    if printArg(TL'', VDS) : QidList .
  eq pullStmtAttrOutAux(T, TL, AtS, VDS) = {T, none} [owise] .
  
  op printArg : TermList OpDeclSet ~> QidList .
  ceq printArg((T, TL), op QI : nil -> Tp [AtS] . VDS) 
    = qid(string(downQid(T)) + ":" + string(Tp)) printArg(TL, VDS) 
    if QI = downQid(T) .
  ceq printArg((T, TL), VDS)
    = downQid(T) printArg(TL, VDS)
    if downString(downQid(T)) : String .
  eq printArg(empty, VDS) = nil .

  eq pullLabelOut('bubble[QI]) = {'bubble[QI], none} .
  eq pullLabelOut('bubble['__[QI, QI']]) = {'bubble['__[QI, QI']], none} .
  eq pullLabelOut('bubble['__[QI, QI', QI'']]) 
    = {'bubble['__[QI, QI', QI'']], none} .
  eq pullLabelOut('bubble['__[QI, QI', QI'', QI3]]) 
    = {'bubble['__[QI, QI', QI'', QI3]], none} .
  eq pullLabelOut('bubble['__[QI, QI', QI'', QI3, TL]])
    = if QI == ''`[.Qid and-then (QI'' == ''`].Qid and-then QI3 == '':.Qid)
      then {'bubble['__[TL]], label(downQid(QI'))} 
      else {'bubble['__[QI, QI', QI'', QI3, TL]], none}
      fi .

  ops lhs rhs : Term -> Term .
  eq lhs(F[T, T']) = T .
  eq lhs(F[T, T']) = T .
  eq rhs(F[T, T']) = T' .
  eq rhs(F[T, T']) = T' .
  eq lhs(qidError(QIL)) = qidError(QIL) .
  eq rhs(qidError(QIL)) = qidError(QIL) .

  eq solveBubbles(EqS, M, unitError(QIL), B, VDS, DB) = equationError(QIL) .
  eq solveBubbles(RlS, M, unitError(QIL), B, VDS, DB) = ruleError(QIL) .
  eq solveBubbles(MAS, M, unitError(QIL), B, VDS, DB) = membAxError(QIL) .

  eq solveBubbles(((eq T = T' [AtS] .) EqS), M, M', B, VDS, DB)
    = ((eq lhs(solveBubblesEq(term(pullLabelOut(T)), term(pullStmtAttrOut(T', VDS)), 
                 M, B, VDS, DB)) 
          = rhs(solveBubblesEq(term(pullLabelOut(T)), term(pullStmtAttrOut(T', VDS)), 
                  M, B, VDS, DB)) 
            [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T', VDS)) AtS] .)
       solveBubbles(EqS, M, M', B, VDS, DB)) .
  eq solveBubbles(((ceq T = T' if T'' = 'true.Bool [AtS] .) EqS), 
       M, M', B, VDS, DB)
    = ((ceq lhs(solveBubblesCEq(term(pullLabelOut(T)), T', M, B, VDS, DB)) 
          = rhs(solveBubblesCEq(term(pullLabelOut(T)), T', M, B, VDS, DB))
          if solveBubblesCond(term(pullStmtAttrOut(T'', VDS)), M, M', B, VDS, DB) 
          [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T'', VDS)) AtS] .)
       solveBubbles(EqS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).EquationSet, M, M', B, VDS, DB) = none .

  eq solveBubbles(((rl T => T' [AtS] .) RlS), M, M', B, VDS, DB)
    = ((rl lhs(solveBubblesRl(term(pullLabelOut(T)), 
                 term(pullStmtAttrOut(T', VDS)), M, B, VDS, DB)) 
        => rhs(solveBubblesRl(term(pullLabelOut(T)),  
                 term(pullStmtAttrOut(T', VDS)), M, B, VDS, DB))
             [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T', VDS)) AtS] .)
       solveBubbles(RlS, M, M', B, VDS, DB)) .
  eq solveBubbles(
       ((crl T => T' if T'' = 'true.Bool [AtS] .) RlS), M, M', B, VDS, DB)
    = ((crl lhs(solveBubblesCRl(term(pullLabelOut(T)), T', M, B, VDS, DB)) 
          => rhs(solveBubblesCRl(term(pullLabelOut(T)), T', M, B, VDS, DB))
          if solveBubblesCond(term(pullStmtAttrOut(T'', VDS)), M, M', B, VDS, DB) 
          [attrSet(pullLabelOut(T)) attrSet(pullStmtAttrOut(T'', VDS)) AtS] .)
       solveBubbles(RlS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).RuleSet, M, M', B, VDS, DB) = none .

*** In the call to solve the bubbles in membership axioms we add the sort to
*** which it is constrained to be used as context.

  eq solveBubbles(((mb T : S [AtS] .) MAS), M, M', B, VDS, DB)
    = ((mb solveBubbles2(term(pullLabelOut(T)), S, M, B, VDS, DB) : S 
           [attrSet(pullLabelOut(T)) AtS] .) 
       solveBubbles(MAS, M, M', B, VDS, DB)) .
  eq solveBubbles(((cmb T : S if T' = 'true.Bool [AtS] .) MAS), 
       M, M', B, VDS, DB)
    = ((cmb solveBubbles2(term(pullLabelOut(T)), S, M, B, VDS, DB) : S
          if solveBubblesCond(T', M, M', B, VDS, DB) 
          [attrSet(pullLabelOut(T)) AtS] .)
       solveBubbles(MAS, M, M', B, VDS, DB)) .
  eq solveBubbles((none).MembAxSet, M, M', B, VDS, DB) = none .

*** The parsing process may generate error terms. Since in the
*** current version of the system Core Maude is generating the appropriate
*** error messages, we just have to worry about the elimination of these
*** terms. The effect is the same one as introducing a module at the object
*** level of Core Maude: If there is any term in an identity attribute in an
*** operator declaration, equation, rule, or membership axiom with a parsing 
*** error a message is generated and the axiom is eliminated.

  eq (op F : TyL -> Ty [id(qidError(QIL)) AtS] .) = opDeclError(QIL) .
  eq (op F : TyL -> Ty [left-id(qidError(QIL)) AtS] .) = opDeclError(QIL) .
  eq (op F : TyL -> Ty [right-id(qidError(QIL)) AtS] .) = opDeclError(QIL) .

  eq (conditionError(QIL) /\ T = T' /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T : S /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T := T' /\ CD?) = conditionError(QIL) .
  eq (conditionError(QIL) /\ T => T' /\ CD?) = conditionError(QIL) .

  eq (eq qidError(QIL) = T? [AtS] .) = equationError(QIL) .
  eq (eq T? = qidError(QIL) [AtS] .) = equationError(QIL) .
  eq (ceq qidError(QIL) = T? if CD? [AtS] .) = equationError(QIL) .
  eq (ceq T? = qidError(QIL) if CD? [AtS] .) = equationError(QIL) .
  eq (ceq T? = T?' if conditionError(QIL) [AtS] .) = equationError(QIL) .

  eq (mb qidError(QIL) : S [AtS] .) = membAxError(QIL) .
  eq (cmb qidError(QIL) : S if CD? [AtS] .) = membAxError(QIL) .
  eq (cmb T? : S if conditionError(QIL) [AtS] .) = membAxError(QIL) .

  eq (rl qidError(QIL) => T? [AtS] .) = ruleError(QIL) .
  eq (rl T? => qidError(QIL) [AtS] .) = ruleError(QIL) .
  eq (crl qidError(QIL) => T? if CD? [AtS] .) = ruleError(QIL) .
  eq (crl T? => qidError(QIL) if CD? [AtS] .) = ruleError(QIL) .
  eq (crl T? => T?' if conditionError(QIL) [AtS] .) = ruleError(QIL) .

  eq F[qidError(QIL), TL?] = qidError(QIL) .
  eq F[TL?, qidError(QIL)] = qidError(QIL) .
  eq F[TL?, qidError(QIL), TL?'] = qidError(QIL) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** The function \texttt{solveBubbles} defined in the following
*** \texttt{VIEW-BUBBLE-PARSING} module parses the bubbles in a set of preview
*** maps. It takes two modules, the signature of the view's source theory,
*** with the variables declared in the view, to parse the source term in the
*** term maps, and the target theory, with the mappings of the variable 
*** declarations in the view, to parse the target terms.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod VIEW-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr PRE-VIEW .

  var  OMS : OpMappingSet .
  vars T T' : Term .
  vars M M' : Module .
  var  U : Module .
  var  QIL : QidList .
  vars VDS VDS' : OpDeclSet .

  op solveBubbles : OpMappingSet OpDeclSet OpDeclSet Module Module -> OpMappingSet .

  eq solveBubbles(OMS, VDS, VDS', U, unitError(QIL)) = none .
  eq solveBubbles(OMS, VDS, VDS', unitError(QIL), U) = none .
  eq solveBubbles(OMS, VDS, VDS', M, M') = OMS [owise] .
  eq solveBubbles((op_to`term_.(T, T') OMS), VDS, VDS', M, M')
    = (op_to`term_.(
         solveBubbles(T, M, false, VDS, emptyDatabase),
         solveBubbles(T', M', false, VDS', emptyDatabase))
      solveBubbles(OMS, VDS, VDS', M, M')) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Module Expression Evaluation
***

*** So far we have not introduced more module expressions than those given by
*** simple quoted identifiers. We will introduce some later, but the scheme
*** followed for evaluating them is very simple and can be presented in a
*** generic way. Given a module expression and a database state, the
*** evaluation of a module expression results in the generation of a new
*** module, which is introduced in the database, with the module expression
*** as its name. The resulting database is then returned. If there is already
*** a module in the database with that name, the function returns the original
*** database without any change. The evaluation of a module expression may
*** produce the evaluation of other module expressions contained in the
*** modules involved in the process. This is the case, for example, for the
*** renaming of modules, in which not only the top module is renamed but,
*** perhaps, some of its submodules as well; it is also the case for the
*** instantiation of parameterized modules, where the module being 
*** instantiated may contain submodules which are parameterized by some of 
*** the parameter theories of the parameterized module in which are imported. 
*** We shall discuss in more detail the renaming and instantiation of module 
*** expressions in Sections~\ref{renaming} and~\ref{instantiation}, 
*** respectively.

*** We saw in Section~\ref{module-expressions} how it is possible to import a
*** module expression in which a parameterized module is instantiated by some
*** of the formal parameters of the parameterized module into which it is
*** imported. To be able to evaluate this kind of module expression, the list
*** of parameters of the module in which the module expression appears has to 
*** be given.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod MOD-EXPR-EVAL is
  pr DATABASE .

  *** decl. moved to module DATABASE
  *** op evalModExp : ModuleExpression Database -> Database .
  op evalModExp : ModuleExpression ParameterDeclList Database -> Tuple{Database, ModuleExpression} .
  op evalViewExp : ViewExp ParameterDeclList Database -> Database .
  op evalViewExp : ParameterList ParameterDeclList Database -> Database .

  var  S : Sort .
  var  QI : Qid .
  var  ME : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  vars VE VE' VE'' : ViewExp .
  vars PL PL' : ParameterList .

  eq evalModExp(ME, DB) = evalModExp(ME, nil, DB) .

  eq evalModExp(ME, PDL, DB) = < DB ; ME > [owise] .

  eq evalModExp(QI, PDL, DB) 
    = if unitInDb(QI, DB)
      then if compiledModule(QI, DB)
           then < DB ; QI >
           else < procModule(QI, DB) ; QI >
           fi
      else if upModule(QI, false) :: Module 
           then < procModule(QI, insTermModule(QI, upModule(QI, false), DB)) ; QI > 
           else < warning(DB, '\r 'Error: '\o 'Module QI 'not 'in 'database. '\n) ; QI >
           fi
      fi .

  eq evalViewExp(QI, PDL, DB)
    = if labelInParameterDeclList(QI, PDL) 
      then DB
      else if viewInDb(QI, DB) 
           then if compiledView(QI, DB)
                then DB
                else procView(QI, DB)
                fi
           else if upView(QI) :: View 
                then procView(upView(QI), DB)
                else warning(DB, ('\r 'Error: '\o 'View QI 'not 'in 'database. '\n))
                fi 
           fi
      fi .
  eq evalViewExp(S{PL}, PDL, DB)
    = if viewInDb(S{PL}, DB)
      then DB
      else viewInst(S, PL, PDL, evalViewExp(S, PDL, evalViewExp(PL, PDL, DB)))
      fi .
  ceq evalViewExp(VE ;; VE', PDL, DB)
    = evalViewExp(VE, PDL, evalViewExp(VE', PDL, DB))
    if VE =/= mtViewExp /\ VE' =/= mtViewExp .
  eq evalViewExp((S, PL), PDL, DB)
    = evalViewExp(S, PDL, evalViewExp(PL, PDL, DB)) 
    [owise] .
  eq evalViewExp((S{PL}, PL'), PDL, DB)
    = evalViewExp(S{PL}, PDL, evalViewExp(PL', PDL, DB)) 
    [owise] .
  eq evalViewExp(nil, PDL, DB) = DB . 

  op viewInst : ViewExp ViewExp ParameterDeclList Database -> Database .

*******************************************************************************
*** The equations specifying its behavior are later, in INST-EXPR-EVALUATION **
*******************************************************************************

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** 
*** The Transformation of Object-Oriented Modules to System Modules
***

*** The transformation of object-oriented modules into system modules has
*** already been discussed in Section~\ref{omod2mod}, and also in
*** \cite{Meseguer93b,ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99}. 
*** We focus here on the part of the process accomplished by each of the main

*** functions involved in the transformation. The transformation discussed
*** in~\cite{DuranMeseguer98} assumed that object-oriented modules were
*** flattened before being transformed into system modules. However, doing it
*** in this way, the transformations already made for the modules in the
*** structure were not reused. In the current system, the transformation is
*** done only for the module being introduced, the top of the structure, and 
*** dusing the `internal' representations of the submodules stored in the 
*** ddatabase for the rest of the structure.

*** This approach requires gathering all class and subclass relation
*** declarations in the structure before starting with the transformation
*** process itself. The function \texttt{prepClasses} collects all these
*** declarations in the structure, and completes all the declarations of 
*** classes with the attributes inherited from their superclasses. 
*** \begin{comment} 
*** This function makes use of a `dummy' module, in which the classes are
*** introduced as sorts and the subclass relations as subsort relations to be 
*** able to compute all the operations on the subclass relation using the 
*** built-in functions on sorts.  
*** \end{comment}

*** Once all the class declarations in the structure have been collected and
*** completed, the transformation is accomplished in two stages. First, the
*** function \texttt{omod2modAux} carries out the 
*** following tasks:
*** \begin{itemize} 
*** \item For each class declaration of the form 
***       $\texttt{class }C\texttt{ | }a_1\texttt{:} S_1\texttt{,}
***       \ldots\texttt{,} a_n\texttt{:} S_n$, the following items are
***       introduced: a subsort $C$ of sort \texttt{Cid}, a constant
***       $C$ of sort $C$, and declarations of operations $a_i
***       \texttt{\ :\_} \texttt{ :\,\,} S_i \texttt{ -> Attribute}$
***       for each attribute $a_i$ (the function
***       \texttt{ops4Attr} creates these declarations).
*** \item For each subclass relation of the form 
***       $\texttt{subclass\ }C\texttt{\ <\ }C'$, a subsort
***       declaration $\texttt{subsort\ }C\texttt{\ <\ }C'$ is
***       introduced.
*** \item For each message declaration of the form \verb~msg F : TyL
***       -> S~, an operator declaration \verb~op F : TyL -> S~ is added.
*** \end{itemize} 
*** When this process has been completed, the function \texttt{prepAxs} is
***  called.  This function applies to the membership axioms, equations, and
*** rewriting rules in the module the transformations indicated in
*** Section~\ref{omod2mod}, so that they become applicable to all the objects
*** of the given class and of their subclasses. The set of attributes of the
*** objects appearing in the membership axioms, equations, and rewriting rules
*** are completed, so that the default convention of not having to 
*** exhaustively mention the set of attributes of a class is supported.

*** Note that in Meseguer's paper~\cite{Meseguer93b} a parallel hierarchy of
*** sorts was defined to deal with objects in different classes, and membership
*** axioms constraining the objects to their corresponding sorts were added.
*** The transformation could be easily completed with sorts, subsort relations,
*** and membership constraints as indicated there. In fact, these declarations
*** were added in an initial version and were then removed because they were
*** computationally expensive. However, there are examples in which it would 
*** be interesting to have them; when needed, these declarations can be 
*** explicitly added by the user in the current version.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EXT-TERMSET is
  protecting TERMSET .
  op |_| : TermSet -> Nat .
  eq | X:Term | T:TermSet | = 1 + | T:TermSet | .
  eq | emptyTermSet | = 0 .
endfm

view TermSet from TRIV to EXT-TERMSET is 
  sort Elt to TermSet .
endv

fmod O-O-TO-SYSTEM-MOD-TRANSF is
  pr DATABASE .
  pr CONVERSION .
  pr EXT-TERMSET .

  var  DB : Database .
  var  I : Nat .
  var  ME : Header .
  vars S S' S'' C C' : Sort .
  vars SS SS' SS'' : SortSet .
  var  Ty : Type .
  var  TyL : TypeList .
  vars T T' T'' T3 : Term .
  vars TL TL' : TermList .
  var  PL : ParameterList .
  vars IL IL' IL'' : ImportList .
  vars CDS CDS' : ClassDeclSet .
  vars ADS ADS' : AttrDeclSet .
  var  SSDS : SubsortDeclSet .
  vars SCDS SCDS' : SubclassDeclSet .
  var  OPDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  vars MAS MAS' : MembAxSet .
  vars EqS EqS' : EquationSet .
  vars RlS RlS' : RuleSet .
  var  QIL : QidList .
  var  NQIL : NeQidList .
  vars O O' : Term .
  vars M U : Module .
  vars QI A A' L F : Qid .
  var  V V' : Variable .
  var  CD : ClassDecl .
  vars SCD SCD' : SubclassDecl .
  vars Ct Ct' Ct'' : Constant .
  var  Cond : Condition .
  var  AtS : AttrSet .
  var  H : Header .
  var  PD : ParameterDecl .
  var  PDL : ParameterDeclList .
  var  MN : ModuleName .
  var  CH : ClassHierarchy .
  var  C'' : Sort .
  vars TS TS' : TermSet .


  op newVar : Sort Nat -> Variable .
  eq newVar(S, I) = qid("V#" + string(I, 10) + ":" + string(S)) .

*** The function \texttt{prepClasses} completes all classes in the module with
*** all the attributes they inherit from their superclasses.

  op prepClasses : ClassDeclSet SubclassDeclSet ImportList ParameterDeclList 
       Database -> ClassDeclSet .
  op prepClasses2 : ClassDeclSet SubclassDeclSet ImportList
       ImportList Database -> ClassDeclSet .
  op prepClasses3 : ClassDeclSet SubclassDeclSet -> ClassDeclSet .

  eq prepClasses(CDS, SCDS, IL, (PD, PDL), DB) 
    = prepClasses(CDS, SCDS, (IL protecting pd(PD) .), PDL, DB) .
  eq prepClasses(CDS, SCDS, IL, nil, DB) 
    = prepClasses2(CDS, SCDS, IL, nil, DB) .

  eq prepClasses2(CDS, SCDS, ((including MN .) IL), IL', DB)
    = if (including MN . ) in IL' 
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS), 
             (getSubclasses(getTopModule(MN, DB)) SCDS), 
             (getImports(getTopModule(MN, DB)) IL), 
             ((including MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, ((extending MN .) IL), IL', DB)
    = if (extending MN . ) in IL' 
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS), 
             (getSubclasses(getTopModule(MN, DB)) SCDS), 
             (getImports(getTopModule(MN, DB)) IL), 
             ((extending MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, ((protecting MN .) IL), IL', DB)
    = if (protecting MN . ) in IL' 
      then prepClasses2(CDS, SCDS, IL, IL', DB)
      else prepClasses2(
             (getClasses(getTopModule(MN, DB)) CDS), 
             (getSubclasses(getTopModule(MN, DB)) SCDS), 
             (getImports(getTopModule(MN, DB)) IL), 
             ((protecting MN .) IL'), DB)
      fi .
  eq prepClasses2(CDS, SCDS, nil, IL, DB) = prepClasses3(CDS, SCDS) .

  eq prepClasses3(CDS, SCDS) 
    = addAttrs(buildHierarchy(CDS, SCDS, none, empty), SCDS) .

  sort ClassHierarchy ClassStruct .
  subsort ClassStruct < ClassHierarchy .

  op [_,_] : ClassDecl SortSet -> ClassStruct .

  op empty : -> ClassHierarchy .
  op __ : ClassHierarchy ClassHierarchy -> ClassHierarchy 
       [assoc comm id: empty] .

  op buildHierarchy : 
       ClassDeclSet SubclassDeclSet SortSet ClassHierarchy -> ClassHierarchy .
  op addAttrs : ClassHierarchy SubclassDeclSet -> ClassDeclSet .
  op addAttrsToItsSons : 
       ClassDecl ClassHierarchy SubclassDeclSet -> ClassHierarchy .

  eq buildHierarchy(((class C | ADS .) CDS), SCDS, SS, CH)
    = if C in SS 
      then buildHierarchy(CDS, SCDS, SS, CH)
      else buildHierarchy(CDS, SCDS, C ; SS, [(class C | ADS .), none] CH)
      fi .
  eq buildHierarchy(none, (subclass C < C' .) SCDS, SS, 
       [(class C | ADS .), SS'] [(class C' | ADS' .), SS''] CH) 
    = buildHierarchy(none, SCDS, SS,
        [(class C | ADS .), C' ; SS'] [(class C' | ADS' .), SS''] CH) .
  eq buildHierarchy(none, none, SS, CH) = CH .

  eq addAttrs([(class C | ADS .), none] CH, SCDS)
    = (class C | ADS .) 
      addAttrs(addAttrsToItsSons((class C | ADS .), CH, SCDS), SCDS) .
  eq addAttrs(empty, SCDS) = none .

  eq addAttrsToItsSons((class C | ADS .), [(class C' | ADS' .), C ; SS] CH,
       (subclass C' < C .) SCDS) 
    = addAttrsToItsSons((class C | ADS .), [(class C' | ADS, ADS' .), SS] CH, 
        SCDS) .
  ceq addAttrsToItsSons((class C | ADS .), CH, (subclass C' < C'' .) SCDS) 
    = addAttrsToItsSons((class C | ADS .), CH, SCDS) 
    if C =/= C'' .
  eq addAttrsToItsSons((class C | ADS .), CH, none) = CH .

----  op inAttrDeclSet : Qid AttrDeclSet -> Bool .
----
----  eq inAttrDeclSet(A, ((attr A' : S), ADS)) 
----    = (A == A') or-else inAttrDeclSet(A, ADS) .
----  eq inAttrDeclSet(A, none) = false .

*** Given a set of attribute declarations, the \texttt{ops4Attr}
*** function returns a set of operator declarations as indicated above. That
*** is, for each attribute $a\texttt{:} S$, an operator of the form 
*** $a \texttt{\ :\_} \texttt{ :\,\,} S \texttt{ -> Attribute}$ is declared.

  op ops4Attr : AttrDeclSet -> OpDeclSet .

  eq ops4Attr(((attr A : S), ADS))
    = ((op qid(string(A) + "`:_") : S -> 'Attribute [gather('&)] .) 
       ops4Attr(ADS)) .
  eq ops4Attr(none) = none .

*** The function \texttt{prepLHS} takes the term in the lefthand side of a
*** rule, equation, or membership axiom, and replaces each object
***
***   $\texttt{<\ }O\texttt{\ :\ }C\texttt{\ |\ }ADS\texttt{\ >}$
***
*** in it---with $O$ of sort \texttt{Oid}, $C$ the name of a class, and $ADS$
*** a set of attributes with their corresponding values---by an object
***
***   $\texttt{<\ }O\texttt{\ :\ }V\texttt{\ |\ }ADS\ ADS'\ Atts\texttt{\ >}$
***
*** where the identifier of the class is replaced by a variable $V$ of sort
*** $C$, which is not used in the axiom, and where the set of attributes is
*** completed with attributes $ADS'$ as indicated in Section~\ref{omod2mod}, so
*** that each attribute declared in class $C$ or in any of its superclasses is
*** added with a new variable as value. $Atts$ is a new variable of sort
*** \texttt{AttributeSet}, which is used to range over the additional 
*** attributes that may appear in objects of a subclass.

*** The function \texttt{prepLHS} takes as arguments a term (in the initial
*** call, the term in the lefthand side of a rule, equation, or membership
*** axiom), the set of variable declarations of those variables declared in the
*** module that are not used in the axiom---new variables are created only if
*** there are no variables in the module with the appropriate sort---the set of
*** attributes in the* occurrences of the objects---and an index---to make sure
*** that the variables being added have not occurrences of the objects---and an
*** index---to make sure that the variables being added have not been added
*** previously. In the initial call this index is set to zero. \texttt{prepLHS}
*** gives as result a tuple composed of the resulting term, the set of objects
*** in the term (so that the modification of the objects in the righthand side
*** of the rule is simplified), the set of variable declarations corresponding 
*** to the new added variables, the set of variable declarations of the 
*** variables in the module that have not been used, and the index for the 
*** creation of new variables.

*** change (03/20/2002): a new variable is created everytime one is needed

*** The set of objects in the lefthand side will be given as a set of terms.

  pr 4TUPLE{TermList, TermSet, Nat, QidList} 
       * (op p1_ to term, op p2_ to objects, op p3_ to index, op p4_ to messages,
          op ((_,_,_,_)) : TermList TermSet Nat QidList -> Tuple{TermList,TermSet,Nat,QidList} to <_;_;_;_>) .

  op prepLHS : TermList ClassDeclSet Nat -> Tuple{TermList, TermSet, Nat, QidList} .

  op crtObject : Term Sort AttrDeclSet Tuple{TermList, TermSet, Nat, QidList} -> Tuple{TermList, TermSet, Nat, QidList} .
  op crtObject2 : Term Variable TermList TermList AttrDeclSet TermSet Nat QidList -> Tuple{TermList, TermSet, Nat, QidList} .
  op crtObject3 : Term Qid TermList AttrDeclSet TermSet Nat QidList -> Tuple{TermList, TermSet, Nat, QidList} .

  eq prepLHS(qidError(QIL), CDS, I) = < qidError(QIL) ; emptyTermSet ; I ; nil > .
  eq prepLHS(F, CDS, I) = < F ; emptyTermSet ; I ; nil > .
  eq prepLHS(Ct, CDS, I) = < Ct ; emptyTermSet ; I ; nil > .

*** \texttt{prepLHS} on a list of terms $\texttt{(}T\texttt{,\ }TL\texttt{)}$,
*** with $T$ a term and $TL$ a list of terms, has to make a call to itself with
*** $T$ and with $TL$. The call with $TL$ has to be made with the result of
*** the call with $T$ so that the variables and the index are right.

  ceq prepLHS((T, TL), CDS, I)
    = < (term(prepLHS(T, CDS, I)), 
         term(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) ;
        _|_(objects(prepLHS(T, CDS, I)),
                objects(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) ;
        index(prepLHS(TL, CDS, index(prepLHS(T, CDS, I)))) ;
        (messages(prepLHS(T, CDS, I)) 
         messages(prepLHS(TL, CDS, index(prepLHS(T, CDS, I))))) > 
    if TL =/= empty .
  ceq prepLHS(F[TL], CDS, I)
    = < F[term(prepLHS(TL, CDS, I))] ;
        objects(prepLHS(TL, CDS, I)) ;
        index(prepLHS(TL, CDS, I)) ;
        messages(prepLHS(TL, CDS, I)) >
      if (F =/= '<_:_|_>) /\ (F =/= '<_:_|`>) .

  ceq prepLHS('<_:_|_>[O, Ct, T], ((class C | ADS .) CDS), I)
    = crtObject(O, C, ADS, prepLHS(T, ((class C | ADS .) CDS), I)) 
    if getName(Ct) == C .
  ceq prepLHS('<_:_|`>[O, Ct], ((class C | ADS .) CDS), I)
    = crtObject(O, C, ADS, 
        prepLHS('none.AttributeSet, ((class C | ADS .) CDS), I))       
    if getName(Ct) == C .
  eq prepLHS('<_:_|_>[O, V, T], CDS, I) 
    = < '<_:_|_>[O, V, T] ; emptyTermSet ; I ; nil > .
                                                      *** is this eq necessary?
  eq prepLHS('<_:_|`>[O, T], CDS, I)                                   
    = prepLHS('<_:_|_>[O, T, 'none.AttributeSet], CDS, I) .
                                                      
  eq prepLHS('<_:_|_>[O, T, T'], none, I) 
    = < qidError('Error: 'undefined 'class T '\n) ; emptyTermSet ; I ; nil > .

  eq crtObject(O, C, ADS, < T ; TS ; I ; QIL >) 
    = crtObject2(O, newVar(C, I), T, 'none.AttributeSet, ADS, TS, (I + 1), QIL) .

*** The function \texttt{crtObject2} is called with the metarepresentation of
*** the list of attributes appearing in the current object (third argument)
*** and the set of attribute declarations of the class to which such object
*** belongs + all the attributes declared in its superclasses (fifth
*** argument). The function proceeds recursively removing the attribute
*** declarations from the set of declarations of attributes for those
*** attributes that appear in the object. Each time an attribute is found, it
*** is passed with its actual value to the fourth argument of 
*** \texttt{crtObject2}, which initially has value \verb~'none.AttributeSet~, 
*** composing a list of terms with them.

*** We assume that:
*** \begin{itemize}
*** \item The metarepresentation of a list of attributes is always given with
***       form \verb~'_`,_[F[T], T]~, \verb~F[T]~, or
***       \verb~'none.AttributeSet~, where \texttt{TL} is the
***       metarepresentation of a list of attributes with the same form (this
***       is ensured by the \verb~(e E)~ gathering pattern in the corresponding
***       declaration in the signature in which the parsing is done), and
*** \item that all the attributes appearing in an object have been declared in
***       the corresponding class declaration or in one of its superclasses.  
*** \end{itemize} 

  eq crtObject2(O, V, '_`,_[F[T], TL], TL', ADS, TS, I, QIL)
    = crtObject2(O, V, (F[T], TL), TL', ADS, TS, I, QIL) .

  ceq crtObject2(O, V, (F[T], TL), TL', ((attr A : S), ADS), TS, I, QIL)
    = crtObject2(O, V, TL, (F[T], TL'), ADS, TS, I, QIL)
    if qid(string(A) + "`:_") == F .
  eq crtObject2(O, V, (F[T], TL), TL', ADS, TS, I, QIL)
    = crtObject2(O, V, TL, TL', ADS, TS, I, 
        (QIL '\r 'Warning: '\o 'Attribute F 'not 'valid '\n))
    [owise] .

  ceq crtObject2(O, V, F[T], TL, ((attr A : S), ADS), TS, I, QIL)
    = crtObject3(O, V, (F[T], TL), ADS, TS, I, QIL)
    if qid(string(A) + "`:_") == F .
  eq crtObject2(O, V, F[T], TL, ADS, TS, I, QIL)
    = crtObject3(O, V, TL, ADS, TS, I, 
        (QIL '\r 'Warning: '\o 'Attribute F 'not 'valid '\n))
    [owise] .

  eq crtObject2(O, V, V', TL, ADS, TS, I, QIL) 
    = crtObject3(O, V, TL, ADS, TS, I, 
        QIL '\r 'Warning: '\o 
            'Variables 'are 'not 'allowed 'in 'the 'set 'of 'attributes 
            'of 'an 'object '`( V' '`) '\n) .

  eq crtObject2(O, V, 'none.AttributeSet, TL, ADS, TS, I, QIL) 
    = crtObject3(O, V, TL, ADS, TS, I, QIL) .
  eq crtObject2(O, V, empty, TL, ADS, TS, I, QIL) 
    = crtObject3(O, V, TL, ADS, TS, I, QIL) .

*** When the function \texttt{crtObject2} has gone through all the
*** attributes in the current object, the function \texttt{crtObject3} is
*** in charge of returning the metarepresentation of the current object
*** completed with the attributes that did not appear in it. These attributes
*** are added with new variables not used in the axiom as value.
*** \texttt{crtObject3} returns a pair composed by this resulting object, 
*** and the set of terms representing all the objects in the lefthand 
*** side (the current object is added to this set).

  eq crtObject3(O, V, TL, ((attr A : S), ADS), TS, I, QIL)
    = crtObject3(O, V, (qid(string(A) + "`:_")[newVar(S, I)], TL), 
        ADS, TS, (I + 1), QIL) .

  eq crtObject3(O, V, TL, none, TS, I, QIL)
    = < '<_:_|_>[O, V, '_`,_[TL, newVar('AttributeSet, I)]] ; 
        _|_('<_:_|_>[O, V, '_`,_[TL, newVar('AttributeSet, I)]], TS) ;
        (I + 1) ; 
        QIL > .

*** Once the lefthand side of a rule or equation has been `prepared', the
*** function \texttt{prepRHS} is called with the set of objects returned by
*** \texttt{prepLHS} and the term in the righthand side of such rule or
*** equation. The function \texttt{prepRHS} proceeds recursively throughout the
*** term looking for objects. Each time an object is found, its set of 
*** attributes is completed with those in the modified object of the lefthand 
*** side which do not appear in it.

  op prepRHS : TermSet TermList -> TermList .
  op prepRHS : TermSet Condition -> Condition .

  op adjustObject : TermSet Term -> Term .

  op adjustObjectRHS : TermSet Term -> [Term] .
  op adjustAttrsObjectRHS : Term Term -> [Term] .
  op adjustAttrsObjectRHSAux : TermSet Term -> [Term] .

  op termAttrListToTermSet : TermList -> TermSet .
  op _attrInTermSet_ : Qid TermSet -> Bool .

  eq prepRHS(TS, T = T' /\ Cond)  
    = prepRHS(TS, T) = prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T : S /\ Cond)  = prepRHS(TS, T) : S /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T := T' /\ Cond) 
    = prepRHS(TS, T) := prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, T => T' /\ Cond) 
    = prepRHS(TS, T) => prepRHS(TS, T') /\ prepRHS(TS, Cond) .
  eq prepRHS(TS, (nil).Condition) = nil .

  eq prepRHS(TS, qidError(QIL)) = qidError(QIL) .
  eq prepRHS(TS, F) = F .
  eq prepRHS(TS, Ct) = Ct .
  ceq prepRHS(TS, F[TL])
    = F[prepRHS(TS, TL)]
    if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq prepRHS(TS, '<_:_|_>[O, Ct, T]) 
    = adjustObjectRHS(TS, '<_:_|_>[O, Ct, prepRHS(TS, T)]) .
  eq prepRHS(TS, '<_:_|_>[O, V, T]) = '<_:_|_>[O, V, prepRHS(TS, T)] .
  eq prepRHS(TS, '<_:_|`>[O, Ct])
    = adjustObjectRHS(TS, '<_:_|_>[O, Ct, prepRHS(TS, 'none.AttributeSet)]) .
  eq prepRHS(TS, '<_:_|`>[O, V]) 
    = '<_:_|_>[O, V, prepRHS(TS, 'none.AttributeSet)] .
  ceq prepRHS(TS, (T, TL)) 
    = (prepRHS(TS, T), prepRHS(TS, TL)) 
    if TL =/= empty .

  eq adjustObjectRHS(_|_('<_:_|_>[O, V, T], TS), '<_:_|_>[O', Ct, T'])
    = if O == O'
      then if getType(V) == getType(Ct)
           then '<_:_|_>[O, V, adjustAttrsObjectRHS(T, T')]
           else '<_:_|_>[O', Ct, T']
           fi
      else adjustObjectRHS(TS, '<_:_|_>[O', Ct, T'])
      fi .
  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[O, Ct, T]) = '<_:_|_>[O, Ct, T] .

***  eq adjustObjectRHS(_|_('<_:_|_>[Ct, C, T], TS), '<_:_|_>[O, Ct', T'])
***    = adjustObjectRHS(TS, '<_:_|_>[O, Ct', T']) .
***  eq adjustObjectRHS(
***       _|_('<_:_|_>[Ct, C, T], TS), '<_:_|_>[Ct', Ct'', T'])
***    = if Ct == Ct'
***      then '<_:_|_>[Ct, Ct'', adjustAttrsObjectRHS(T, T')]
***      else adjustObjectRHS(TS, '<_:_|_>[Ct', Ct'', T'])
***      fi .
***  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[Ct, Ct', T]) 
***    = '<_:_|_>[Ct, Ct', T] .

*** The function \texttt{adjustAttrsObjectRHS} completes the set of
*** attributes of an object in the righthand side with those in the object in
*** the lefthand side or in the class not used in the lefthand side, which 
*** have been completed by the function \texttt{crtObject}.

  eq adjustAttrsObjectRHS('_`,_[TL], T)
    = adjustAttrsObjectRHSAux(termAttrListToTermSet(TL), T) .

  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), '_`,_[A[T'], T''])
    = '_`,_[A[T'], adjustAttrsObjectRHSAux(TS, T'')] .
  ceq adjustAttrsObjectRHSAux(TS, '_`,_[A[T], T'])
    = qidError(A 'is 'not 'a 'valid 'attribute) 
    if not A attrInTermSet TS .
  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), A[T'])
    = '_`,_[A[T'], adjustAttrsObjectRHSAux(TS, 'none.AttributeSet)] .
  ceq adjustAttrsObjectRHSAux(TS, A[T])
    = qidError(A 'is 'not 'a 'valid 'attribute)
    if not A attrInTermSet TS .
  eq adjustAttrsObjectRHSAux(_|_(A[T], TS), 'none.AttributeSet)
    = '_`,_[A[T], adjustAttrsObjectRHSAux(TS, 'none.AttributeSet)] .
  eq adjustAttrsObjectRHSAux(V, 'none.AttributeSet) = V .

  eq A attrInTermSet _|_(V, TS) = A attrInTermSet TS .
  eq A attrInTermSet _|_(A'[T], TS) 
    = (A == A') or-else (A attrInTermSet TS) .
  eq A attrInTermSet emptyTermSet = false .

  ceq termAttrListToTermSet((T, TL))
    = if T == 'none.AttributeSet
      then termAttrListToTermSet(TL)
      else _|_(T, termAttrListToTermSet(TL))
      fi 
    if TL =/= empty .
  eq termAttrListToTermSet(T)
    = if T == 'none.AttributeSet
      then emptyTermSet
      else T 
      fi .

*** In the case of equations and rules, the function \texttt{prepAxs} calls the
*** function \texttt{prepLHS} with the term in the lefthand side of the axiom,
*** and then use the generated set of objects to call the \texttt{prepRHS}
*** function. For conditional equations, rules, and membership axioms, this set
*** of terms representing the objects in the lefthand side is also used in the
*** calls to \texttt{prepRHS} with each of the terms in the conditions. The
*** term in the lefthand side of the equation, rule, or membership axiom is 
*** replaced by the term returned by \texttt{prepLHS}. The index is used in 
*** the recursive calls to \texttt{prepAxs}.

*** \texttt{prepLHS} returns as second argument the set of objects (as a set of
*** terms) appearing in it. These objects are returned after extending their
*** set of attributes by those of the class to which they belong not already 
*** specified.

  op prepAxs : Module MembAxSet EquationSet RuleSet ClassDeclSet Nat QidList 
       -> Module .

  eq prepAxs(U, ((mb T : S [AtS] .) MAS), EqS, RlS, CDS, I, QIL)
    = prepAxs(
        addMbs(mb term(prepLHS(T, CDS, I)) : S [AtS] ., U),
        MAS, EqS, RlS, CDS, 
        index(prepLHS(T, CDS, I)), 
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, ((cmb T : S if Cond [AtS] .) MAS), EqS, RlS, CDS, I, QIL)
    = prepAxs(
        addMbs(cmb term(prepLHS(T, CDS, I)) : S 
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS, 
        index(prepLHS(T, CDS, I)), 
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, ((eq T = T' [AtS] .) EqS), RlS, CDS, I, QIL)
    = prepAxs(
        addEqs(eq term(prepLHS(T, CDS, I)) 
                 = prepRHS(objects(prepLHS(T, CDS, I)), T') [AtS] ., U),
        MAS, EqS, RlS, CDS, 
        index(prepLHS(T, CDS, I)), 
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, ((ceq T = T' if Cond [AtS] .) EqS), RlS, CDS, I, QIL)
    = prepAxs(
        addEqs(ceq term(prepLHS(T, CDS, I))
                 = prepRHS(objects(prepLHS(T, CDS, I)), T')
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),
        MAS, EqS, RlS, CDS, 
        index(prepLHS(T, CDS, I)), 
        (QIL messages(prepLHS(T, CDS, I)))) .

  eq prepAxs(U, MAS, EqS, ((rl T => T' [AtS] .) RlS), CDS, I, QIL)
    = prepAxs(
        addRls(rl term(prepLHS(T, CDS, I)) 
                 => prepRHS(objects(prepLHS(T, CDS, I)), T') [AtS] ., U),
        MAS, EqS, RlS, CDS, 
        index(prepLHS(T, CDS, I)), 
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, MAS, EqS, ((crl T => T' if Cond [AtS] .) RlS), CDS, I, QIL)
    = prepAxs(
        addRls(crl term(prepLHS(T, CDS, I))
                 => prepRHS(objects(prepLHS(T, CDS, I)), T')
                 if prepRHS(objects(prepLHS(T, CDS, I)), Cond) [AtS] ., U),  
        MAS, EqS, RlS, CDS, 
        index(prepLHS(T, CDS, I)), 
        (QIL messages(prepLHS(T, CDS, I)))) .
  eq prepAxs(U, none, none, none, CDS, I, nil) = U . 
  eq prepAxs(U, none, none, none, CDS, I, NQIL) = unitError(NQIL) .
  eq prepAxs(unitError(QIL), MAS, EqS, RlS:[RuleSet], CDS, I, QIL':QidList) = unitError(QIL':QidList QIL) .

*** After completing the set of classes in the module with the attributes from
*** their superclasses, the function \texttt{omod2mod} calls the function
*** \texttt{omod2modAux} with the same module and the set of class
*** declarations. The definition of the \texttt{omod2mod} function is given by
*** the five equations below.

  op omod2mod : OModule Database -> SModule .
  op omod2modAux : OModule ClassDeclSet -> SModule .
  op omod2mod : OTheory Database -> SModule .
  op omod2modAux : OTheory ClassDeclSet -> SModule .

  eq omod2mod(
       omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom,
       DB)
    = omod2modAux(
        omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, 
        prepClasses(CDS, SCDS, IL, getParDecls(H), DB)) .
  eq omod2mod(
       oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth,
       DB)
    = omod2modAux(
        oth H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, 
        prepClasses(CDS, SCDS, IL, getParDecls(H), DB)) .

  eq omod2modAux(
       omod H is 
          IL sorts SS . SSDS ((class C | ADS .) CDS) SCDS OPDS MDS MAS EqS RlS 
       endom, 
       CDS')
    = omod2modAux(
        omod H is 
           IL sorts (SS ; C) .
           (subsort C < 'Cid . SSDS)
           CDS SCDS
           ((op C : nil -> C [none] .) 
            ops4Attr(ADS) OPDS)
           MDS MAS EqS RlS
        endom,
        CDS') .
  eq omod2modAux(
       omod H is 
          IL sorts SS . SSDS CDS ((subclass C < C' .) SCDS) 
          OPDS MDS MAS EqS RlS 
       endom, 
       CDS')
    = omod2modAux(
        omod H is 
           IL sorts SS . ((subsort C < C' .) SSDS) 
           CDS SCDS OPDS MDS MAS EqS RlS 
        endom, 
        CDS') .
  eq omod2modAux(
        omod H is 
           IL sorts SS . SSDS CDS SCDS OPDS 
           ((msg F : TyL -> Ty .) MDS) MAS EqS RlS
        endom, 
        CDS')
    = omod2modAux(
         omod H is 
            IL sorts SS . SSDS CDS SCDS 
            ((op F : TyL -> Ty [msg] .) OPDS) MDS MAS EqS RlS
         endom, 
         CDS') .
  eq omod2modAux(
       omod H is IL sorts SS . SSDS none none OPDS none MAS EqS RlS endom, 
       CDS)
    = prepAxs(mod H is IL sorts SS . SSDS OPDS none none none endm, 
        MAS, EqS, RlS, CDS, 0, nil) .

  eq omod2modAux(
       oth H is 
          IL sorts SS . SSDS ((class C | ADS .) CDS) 
          SCDS OPDS MDS MAS EqS RlS 
       endoth, 
       CDS')
    = omod2modAux(
        oth H is 
           IL sorts (SS ; C) .
           (subsort C < 'Cid . SSDS)
           CDS SCDS
           ((op C : nil -> C [none] .) 
            ops4Attr(ADS) OPDS)
           MDS MAS EqS RlS
        endoth,
        CDS') .
  eq omod2modAux(
       oth H is 
          IL sorts SS . SSDS CDS ((subclass C < C' .) SCDS) 
          OPDS MDS MAS EqS RlS 
       endoth, 
       CDS')
    = omod2modAux(
        oth H is 
           IL sorts SS . ((subsort C < C' .) SSDS) 
           CDS SCDS OPDS MDS MAS EqS RlS 
        endoth, 
        CDS') .
  eq omod2modAux(
        oth H is 
           IL sorts SS . SSDS CDS SCDS OPDS 
           ((msg F : TyL -> Ty .) MDS) MAS EqS RlS
        endoth, 
        CDS')
    = omod2modAux(
         oth H is 
            IL sorts SS . SSDS CDS SCDS 
            ((op F : TyL -> Ty [msg] .) OPDS) MDS MAS EqS RlS
         endoth, 
         CDS') .
  eq omod2modAux(
       oth H is IL sorts SS . SSDS none none OPDS none MAS EqS RlS endoth, 
       CDS)
    = prepAxs(
        th H is IL sorts SS . SSDS OPDS none none none endth, 
        MAS, EqS, RlS, CDS, 0, nil) .
endfm
