set include BOOL off .
set include QID off .
set include NAT off .

fth EQ is
    including TRIV .
    protecting TRUTH-VALUE .
    op _==_ : Elt Elt -> Bool .
endfth

fmod VAR{XV :: EQ, X :: TRIV} is
    subsort XV$Elt < X$Elt .
endfm

fmod VAR-NAME is
    protecting BOOL .
    sort Var .
    ops x y z : -> Var [ctor] .
    op ,_ : Var -> Var [ctor] .
endfm

view Var from EQ to VAR-NAME is
    sort Elt to Var .
endv

fmod SUBST{X :: TRIV} is
    protecting META-LEVEL .
    protecting VAR{Var,X} .

    sort Subst{X} .
    sort Var{X} .
    subsort Var < Var{X} .

    op [_:=_]   : Var{X} X$Elt -> Subst{X} .
    op __       : Subst{X} X$Elt -> X$Elt .
    op __       : Subst{X} GroundTermList -> GroundTermList .
    op error    : -> X$Elt [ctor] .

    var S       : Subst{X} .
    vars x1 x2  : Var{X} .
    var X       : X$Elt .
    var GTS     : GroundTermList .
    var GT GT'  : GroundTerm .
    var Q       : Qid .

    ceq [x1 := X] x2 = X    if x1 == x2 .
    ceq [x1 := X] x2 = x2   if not x1 == x2 .

    ceq S X = downTerm(GT, error)
        if Q[GTS] := upTerm(X)
        /\ GT := Q[S GTS] .
    ceq S (GT , GTS) = S GT , S GTS if not GTS == empty .
    ceq S GT = if X == error then GT else upTerm(S X) fi
        if X := downTerm(GT, error) .
    ceq S X = X if upTerm(X) :: Constant .


endfm

fmod FUNCTION{X :: TRIV, Y :: TRIV} is
    protecting SUBST{X} .
    protecting SUBST{Y} .

    sort =>{X,Y} .

    op __   : =>{X,Y} X$Elt -> Y$Elt [prec 40] .
    op _$_  : =>{X,Y} X$Elt -> Y$Elt [prec 60] .

    var f : =>{X,Y} .
    var x : X$Elt .
    eq f $ x = f x .

    op \_._ : Var{X} Y$Elt -> =>{X,Y} .
    var X : Var{X} .
    var Y : Y$Elt .
    eq (\ X . Y) x = [X := x] Y .
endfm

fmod TESTING is
    protecting FUNCTION{Nat,Nat} .
endfm

reduce [,x := 3] ,x .
reduce [,x := 3] ,y .
reduce [,x := ,y] ,y .
reduce [,x := ,y] ,x .
reduce [,x := 3] ,x + ,y .
reduce (\ ,x . ,x) 3 .
reduce (\ ,x . 2 * ,x) 3 .
load full-maude27.maude .

(
view =>{X :: TRIV, Y :: TRIV} from TRIV to FUNCTION{X,Y} is
    sort Elt to =>{X,Y} .
endv
)

(
fmod FUNCTION-CONST{X :: TRIV, Y :: TRIV} is
    extending FUNCTION{X,=>{Y,X}} .

    op const : -> =>{X, =>{Y,X}} .
    var x : X$Elt .
    var y : Y$Elt .
    eq const x y = x .
endfm
)

(
fmod FUNCTION-COMP{X :: TRIV, Y :: TRIV, Z :: TRIV} is
    extending FUNCTION{X,Y} .
    extending FUNCTION{Y,Z} .
    extending FUNCTION{X,Z} .

    op _._ : =>{Y,Z} =>{X,Y} -> =>{X,Z} [gather (E e) prec 44].

    var f : =>{X,Y} .
    var g : =>{Y,Z} .
    var x : X$Elt .
    eq (g . f) x = g (f x) .
endfm
)
(
fmod DATA-MAYBE{a :: TRIV} is
    sort Maybe{a} .
    op Nothing : -> Maybe{a} [ctor] .
    op Just_ : a$Elt -> Maybe{a} [ctor] .
endfm
)

(
view Maybe{a :: TRIV} from TRIV to DATA-MAYBE{a} is
    sort Elt to Maybe{a} .
endv
)

(
fmod DATA-CONS{a :: TRIV} is
    sort Cons{a} .
    op Nil : -> Cons{a} [ctor] .
    op _:|_ : a$Elt Cons{a} -> Cons{a} [ctor] .
endfm
)

(
view Cons{a :: TRIV} from TRIV to DATA-CONS{a} is
    sort Elt to Cons{a} .
endv
)
(
fmod INSTANCE-MAPPABLE-MAYBE{a :: TRIV, b :: TRIV} is
    extending FUNCTION{=>{a,b}, =>{Maybe{a},Maybe{b}}} .

    op map : -> =>{=>{a,b}, =>{Maybe{a},Maybe{b}}} .

    var f : =>{a,b} .
    var a : a$Elt .
    eq map f Nothing = Nothing .
    eq map f (Just a) = Just (f a) .
endfm
)

(
fmod INSTANCE-MAPPABLE-CONS{a :: TRIV, b :: TRIV} is
    extending FUNCTION{=>{a,b}, =>{Cons{a},Cons{b}}} .

    op map : -> =>{=>{a,b}, =>{Cons{a},Cons{b}}} .

    var f   : =>{a,b} .
    var a   : a$Elt .
    var as  : Cons{a} .
    eq map f Nil = Nil .
    eq map f (a :| as) = f a :| map f as .
endfm
)

(
fmod INSTANCE-FOLDABLE-CONS{a :: TRIV, b :: TRIV} is
    extending FUNCTION{=>{b, =>{a,b}}, =>{b, =>{Cons{a}, b}}} .

    op foldl : -> =>{=>{b,=>{a,b}}, =>{b, =>{Cons{a}, b}}} .

    var f   : =>{b, =>{a,b}} .
    var b   : b$Elt .
    var a   : a$Elt .
    var as  : Cons{a} .

    eq foldl f b Nil = b .
    eq foldl f b (a :| as) = foldl f (f b a) as .
endfm
)
(
fmod TESTING is
    extending INSTANCE-MAPPABLE-MAYBE{Nat, Bool} .
    extending INSTANCE-MAPPABLE-CONS{Nat, Nat} .
    extending INSTANCE-MAPPABLE-CONS{Nat, Bool} .
    extending INSTANCE-FOLDABLE-CONS{Bool, Bool} .
    extending INSTANCE-FOLDABLE-CONS{Nat, Nat} .
    protecting FUNCTION-ID{Bool} .
    protecting FUNCTION-ID{Nat} .
    protecting FUNCTION-COMP{Nat,Bool,Bool} .
    protecting FUNCTION-COMP{Nat,Nat,Bool} .
    protecting FUNCTION-COMP{Nat,Nat,Nat} .
    protecting FUNCTION-COMP{Cons{Nat},Cons{Nat},Cons{Bool}} .

    vars N M : Nat .

    --- some constants (combinator-style functions) to play with
    op aanndd : -> =>{Bool, =>{Bool,Bool}} .
    eq aanndd true true     = true .
    eq aanndd true false    = false .
    eq aanndd false true    = false .
    eq aanndd false false   = false .

    op double : -> =>{Nat,Nat} .
    eq double N = 2 * N .

    op + : -> =>{Nat, =>{Nat,Nat}} .
    eq + N M = N + M .

    op even : -> =>{Nat,Bool} .
    eq even 0       = true .
    eq even 1       = false .
    eq even s(s(N)) = even N .

    op odd : -> =>{Nat,Bool} .
    eq odd N = not (even N) .

    --- some constants (data)
    op list1 : -> Cons{Nat} .
    eq list1 = 3 :| 5 :| 8 :| 2 :| 19 :| 20 :| Nil .

    op list2 : -> Cons{Nat} .
    eq list2 = 16 :| 100 :| 0 :| 3 :| 9 :| 19 :| 22 :| 101 :| Nil .
endfm
)
