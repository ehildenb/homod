load full-maude27.maude .

fmod HOFMODS is
    protecting F&S-MODS&THS .

    sorts @HODecl@ @HODeclList@ .
    subsort @HODecl@ < @HODeclList@ .
    sorts @HOTypeVar@ @HOTypeExp@ .
    subsort @HOTypeVar@ < @HOTypeExp@ .
    sorts @CTORName@ @CTORDecl@ @CTORDeclList@ .
    subsort @CTORName@ < @CTORDecl@ < @CTORDeclList@ .
    sorts @DDecl@ .
    subsort @DDecl@ < @HODecl@ .

    op module_where_--endmodule : @Interface@ @HODeclList@ -> @Module@ .
    op __ : @HODeclList@ @HODeclList@ -> @HODeclList@ [assoc] .

    op data_=_  : @HOTypeExp@ @CTORDeclList@ -> @DDecl@ [prec 48].
    op _|_      : @CTORDeclList@ @CTORDeclList@ -> @CTORDeclList@ [assoc prec 44] .
    op __       : @CTORDecl@ @HOTypeExp@ -> @CTORDecl@ [prec 40] .

    op ()       : -> @HOTypeExp@ .
    op __       : @HOTypeExp@ @HOTypeExp@ -> @HOTypeExp@ .
    op _->_     : @HOTypeExp@ @HOTypeExp@ -> @HOTypeExp@ .

    op Maybe : -> @HOTypeExp@ .
    op Just : -> @CTORName@ .
    op Nothing : -> @CTORName@ .
    ops a b : -> @HOTypeVar@ .

endfm

fmod VIEWS2 is
    protecting VIEWS .
    protecting HOFMODS .
endfm


fmod FULL-MAUDE-SIGN2 is
    including FULL-MAUDE-SIGN .
    including VIEWS2 .
endfm

--- Can use Full Maude parameterized views for great benefit/flexibility

--- (view Set{X :: Triv} from Triv to Set{X} is
---     sort Elt to Set{X}
--- endv)

--- This makes it so that if `X :: Triv`, then we also have `Set{X} :: Triv` for
--- free. We can use this to get type-genericism in a `data Maybe a = ...`
--- constructor, where we want `a` to be a base-type, but also some complex one
--- See section 15.3.2 of Maude manual

--- mod HOTESTING is
---     protecting FULL-MAUDE .
---     protecting HOFMODS .
--- 
---     op Maybe : -> @HOTypeExp@ .
---     op Just : -> @CTORName@ .
---     op Nothing : -> @CTORName@ .
--- 
---     ops a b : -> @HOTypeVar@ .
--- 
---     --- op TestMod : -> @Interface@ .
--- endm

(

module TestMod where

data Maybe a = Just a
             | Nothing

--endmodule

)
