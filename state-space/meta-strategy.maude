--- Free programs over sort Command
fmod SIMP is
  extending BOOL .
  protecting NAT .

  sorts BVar Command Program .
  subsort BVar < Bool .
  subsort Command < Program .

  vars P P' : Program . var B : Bool . var N : Nat .

  op .Program : -> Program .
  op _;_ : Program Program -> Program [assoc id: .Program prec 75] .
  ------------------------------------------------------------------

  op {_} : Program -> Program .
  -----------------------------
  eq { P } = P .

  op if_then_else_ : Bool Program Program -> Program [prec 72 strat(1 0)] .
  -------------------------------------------------------------------------
  eq if true  then P else P' = P .
  eq if false then P else P' = P' .

  op while__ : Bool Program -> Program .
  --------------------------------------
  eq while B P = if B then { P ; while B P } else .Program .

  op repeat__ : Nat Program -> Program .
  --------------------------------------
  eq repeat 0    P = .Program .
  eq repeat s(N) P = P ; repeat N P .
endfm

--- Useful data-structures over terms for analysis
fmod CTERM-DATA is
  extending BOOL .
  protecting META-LEVEL .

  sorts CTerm CTermSet NeCTermSet CTermSetMap CTermSetTrace .
  subsorts Term < CTerm < NeCTermSet < CTermSet .

  var N : Nat . vars B B' : Bool .
  vars T T' : Term . vars CT CT' CT'' : CTerm .
  vars CTS CTS' : CTermSet . vars NeCTS NeCTS' : NeCTermSet . vars CTSM CTSM' : CTermSetMap .

  op _|_ : Term Bool -> CTerm [right id: true prec 52] .
  ------------------------------------------------------

  op .CTermSet : -> CTermSet .
  op _;;_ : CTermSet CTermSet   -> CTermSet   [ctor assoc comm id: .CTermSet prec 60] .
  op _;;_ : CTermSet NeCTermSet -> NeCTermSet [ctor ditto] .
  ----------------------------------------------------------
  eq NeCTS ;; NeCTS = NeCTS .

  op _++_ : CTermSet CTermSet -> CTermSet [assoc comm id: .CTermSet prec 61] .
  ----------------------------------------------------------------------------
  ceq (CT ;; CTS) ++ (CT' ;; CTS') = (CT'' ;; CTS) ++ CTS' if CT'' := #mergeCTerms(CT, CT') .
  eq  NeCTS       ++ NeCTS'        = NeCTS ;; NeCTS' [owise] .

  --- TODO: Should union and difference be expressed as operators which also take modules?
  --- Would that mean they should be in a later module?
  --- TODO: What if there are multiple matches?
  --- TODO: Should this be inlined into the defintion on `_++_`?
  op #mergeCTerms : CTerm CTerm -> [CTermSet] [comm] .
  --------------------------------------------------------
---  ceq #mergeCTerms(T | B, CT') = if metaCheck(MOD, T'') then T | B else T | B or (#substAsConstraint(SUBST) and B') fi
---                               if T' | B' := applySubst(make CT' apart-from (T | B), CT')
---                               /\ SUBST   := metaMatch(MOD, T, T', nil, 0)
---                               /\ T''     := applySubst(SUBST, upTerm(B' implies B))
---  eq  #mergeCTerms(CT, CT')    = CT ;; CT' [owise] .
  eq #mergeCTerms(CT, CT') = CT ;; CT' [owise] .

  op _-_ : CTermSet CTermSet -> CTermSet [right id: .CTermSet prec 62] .
  ----------------------------------------------------------------------
  eq .CTermSet - NeCTS     = .CTermSet .
  eq CT ;; NeCTS - NeCTS'  = (CT - NeCTS') ++ (NeCTS - NeCTS') .
  eq (CT - (CT' ;; NeCTS)) = (CT - CT') - NeCTS .

  --- Think of the atomic boolean expressions as variables, and of this as variable substitution.
  op _[_] : Bool CTermSet -> [Bool] .
  -----------------------------------
  eq true           [ CTS ] = true .
  eq false          [ CTS ] = false .
  eq (  not     B') [ CTS ] = not (B' [ CTS ]) .
  eq (B or      B') [ CTS ] = (B [ CTS ]) or      (B' [ CTS ]) .
  eq (B and     B') [ CTS ] = (B [ CTS ]) and     (B' [ CTS ]) .
  eq (B xor     B') [ CTS ] = (B [ CTS ]) xor     (B' [ CTS ]) .
  eq (B implies B') [ CTS ] = (B [ CTS ]) implies (B' [ CTS ]) .

  op empty? : -> Bool .
  ---------------------
  eq empty? [ .CTermSet ] = true .
  eq empty? [ NeCTS     ] = false .

  op .CTermSetMap : -> CTermSetMap .
  op _|->_ : Nat CTermSet -> CTermSetMap [prec 64] .
  op __ : CTermSetMap CTermSetMap -> CTermSetMap [assoc comm id: .CTermSetMap prec 65 format(d n d)] .
  ----------------------------------------------------------------------------------------------------

  op .CTermSetTrace : -> CTermSetTrace .
  op _|_,_ : Nat CTermSetMap CTermSetMap -> CTermSetTrace [prec 66 format(d d n n d d)] .
  ---------------------------------------------------------------------------------------
  eq .CTermSetTrace = 0 | .CTermSetMap , .CTermSetMap .

  op extend : CTermSet CTermSetTrace -> [CTermSetTrace] .
  -------------------------------------------------------
  eq extend(CTS, 0    | .CTermSetMap , .CTermSetMap)     = s(0)    | 0 |-> CTS                  , 0 |-> CTS .
  eq extend(CTS, s(N) | CTSM         , N |-> CTS' CTSM') = s(s(N)) | CTSM s(N) |-> (CTS - CTS') , CTSM' N |-> CTS' s(N) |-> (CTS ++ CTS') .

  --- TODO: what is `unexplored` on input 0? Just a variable of the appropriate sort?
  op unexplored : CTermSetTrace -> CTermSet .
  -----------------------------------------
  eq unexplored(s(N) | N |-> CTS CTSM , CTSM') = CTS .
endfm

fmod CTERM-COMMAND is
  protecting CTERM-DATA .

  sorts CTermCommand CTermModuleCommand .

  var N : Nat . var TC : CTermCommand .
  vars T T' T'' : CTerm . vars NeCTS NeCTS' : NeCTermSet .
  var MOD : Module . var TYPE : Type . var SUBST : Substitution .

  op _[_] : CTermCommand CTermSet -> [CTermSet] [prec 55] .
  ------------------------------------------------------
  eq TC [ .CTermSet      ] = .CTermSet .
  eq TC [ NeCTS ;; NeCTS' ] = TC [ NeCTS ] ;; TC [ NeCTS' ] .

  ops reduce rewrite narrow narrow-smt : -> CTermModuleCommand .
  op _in_ : CTermModuleCommand Module -> CTermCommand [prec 50] .
  -------------------------------------------------------------
  ceq reduce     in MOD [ T ] = T' if { T' , TYPE } := metaReduce(MOD, T) .
  eq  rewrite    in MOD [ T ] = #rewrite(MOD, T, #varAway(MOD, T), 0) .
  eq  narrow     in MOD [ T ] = #narrow(MOD, T, #varAway(MOD, T), 0) .
  eq  narrow-smt in MOD [ T ] = #narrow-smt(MOD, T, #varAway(MOD, T), 0) .

  --- TODO: #varAway needs to actually make the generated variable away from `T`
  op #varAway : Module CTerm -> CTerm .
  -----------------------------------
  eq #varAway(MOD, T) = qid("X:" + string(getKind(MOD, leastSort(MOD, T)))) .

  op #rewrite : Module CTerm CTerm Nat -> CTermSet .
  -----------------------------------------------
  ceq #rewrite(MOD, T, T', N) = T'' ;; #rewrite(MOD, T, T', s(N)) if { T'' , TYPE , SUBST } := metaSearch(MOD, T, T', nil, '+, 1, N) .
  eq  #rewrite(MOD, T, T', N) = .CTermSet [owise] .

  --- TODO: If the term passed to `#narrow` is ground, is it a safe optimization to
  --- pass it to `#rewrite` instead?
  op #narrow : Module CTerm CTerm Nat -> CTermSet .
  ----------------------------------------------
  ceq #narrow(MOD, T, T', N) = T'' ;; #narrow(MOD, T, T', s(N)) if { T'' , TYPE , SUBST } := metaNarrow(MOD, T, T', '+, 1, N) .
  eq  #narrow(MOD, T, T', N) = .CTermSet [owise] .

  op #narrow-smt : Module CTerm CTerm Nat -> CTerm .
endfm

fmod META-STRATEGY is
  extending SIMP .
  protecting CTERM-COMMAND .

  sort Analysis .
  subsorts CTermCommand CTermModuleCommand < Command .

  var N : Nat . vars A B : Bool .
  var TC : CTermCommand . var TMC : CTermModuleCommand . vars P P1 P2 : Program .
  var H : Header . var SUBST : Substitution . var TYPE : Type . var MOD : Module .
  vars T T' T'' : CTerm . var CTS : CTermSet . var NeCTS : NeCTermSet . var CTST : CTermSetTrace .

  op .Analysis : -> Analysis .
  op __        : Analysis Analysis -> Analysis [assoc comm id: .Analysis prec 95 format(d n d)] .
  -----------------------------------------------------------------------------------------------

  op strategy       <_> : Program      -> Analysis [prec 85] .
  op current-module <_> : Module       -> Analysis [prec 85] .
  op state          <_> : CTermSet      -> Analysis [prec 85] .
  op trace          <_> : CTermSetTrace -> Analysis [prec 85] .
  ------------------------------------------------------------
  eq strategy < TC ; P > state < CTS >
   = strategy < P >      state < TC [ CTS ] > .

  eq strategy < TMC        ; P > current-module < MOD >
   = strategy < TMC in MOD ; P > current-module < MOD > .

  op set-module : Header -> Command .
  -----------------------------------
  eq strategy < set-module(H) ; P > current-module < MOD >
   = strategy < P >                 current-module < upModule(H, true) >
   .
  eq strategy < set-module(H) ; P >
   = strategy < P >                 current-module < upModule(H, true) > [owise]
   .

  ops record load : -> Command .
  ------------------------------
  eq strategy < record ; P > state < CTS >              trace < CTST >
   = strategy < P >          state < CTS >              trace < extend(CTS, CTST) > .
  eq strategy < load   ; P > state < CTS >              trace < CTST >
   = strategy < P >          state < unexplored(CTST) > trace < CTST > .

  eq strategy < if B        then P1 else P2 ; P > state < CTS >
   = strategy < if B [ CTS ] then P1 else P2 ; P > state < CTS > .

  --- Use this operator to throw away the noise in the output
  op summarize : -> Command .
  ---------------------------
  eq strategy < summarize > current-module < MOD >
   = strategy < summarize > .

  --- Macro Strategies
  --- ----------------

  op explore-all : -> Program .
  -----------------------------
  eq explore-all = record
                 ; while (not empty?) { narrow
                                      ; record
                                      ; load
                                      } .

endfm
