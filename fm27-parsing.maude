load fm27-meta.maude

*******************************************************************************

***
*** 8.3 Input Processing
***

*** The processing functions presented in the following modules are in charge
*** of taking each term generated by the \texttt{metaParse} function and,
*** after transforming it into an element of the data types \texttt{Module} or
*** \texttt{View}, or generating some output, returning the database resulting
*** from introducing in it such a term. We shall see in
*** Section~\ref{database-handling} how the appropriate function is called
*** after having performed a first analysis of the term, in which it is
*** detected whether the input corresponds to a unit, view, or command. In the
*** cases of units and views the processing is quite similar. After a 
*** preprocessing of the term, the function \texttt{parseDecl} is called with 
*** each of the subterms representing declarations, resulting in units or 
*** views with the parsed declarations in it.

***
*** 8.3.1 Module Processing
***

*** The processing of a term resulting from the parsing of some input
*** corresponding to a unit is accomplished by the \texttt{procModule} function.
*** This function takes as arguments a term of sort \texttt{Term}, which
*** represents some preunit, and a database. The function then enters into the
*** given database the unit obtained from the transformation of such term 
*** into a term of sort \texttt{Module}.

fmod UNIT-PROCESSING is
  pr DATABASE .
  pr UNIT-DECL-PARSING .
  pr EVALUATION .
  pr RENAMING-SET-APPL-ON-UNIT .
  pr META-FULL-MAUDE-SIGN .
  pr MOD-EXP-PARSING .

  vars QI F X : Qid .
  var  M : Module .
  vars PU PU' U U' : Module .
  vars DB DB' : Database .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  vars PL PL' PL'' : ParameterList .
  var  PDL : ParameterDeclList .
  var  IL IL' : ImportList .
  var  ME : ModuleExpression .
  var  S : Sort .
  var  SS : SortSet .
  var  ME' : ModuleExpression .
  var  VMAPS : RenamingSet .
  var  B : Bool .
  var  VDS : OpDeclSet .
  var  QIL : QidList .
  var  PDR : ParseDeclResult .
  var  DT : Default{Term} .

*** The \texttt{parseParList} takes a term representing a list of parameters
*** and returns the corresponding list.

  op parseParList : Term -> ParameterDeclList .
  eq parseParList('_::_['token[T], T']) = downQid(T) :: parseModExp(T') .
  eq parseParList('_`,_[T, T']) = (parseParList(T), parseParList(T')) .

*** All the operators declared as constructors of sort \texttt{PreModule} in 
*** the signature of Full Maude, given in Appendix~\ref{signature-full-maude}, 
*** are declared with two arguments, namely, the name, or name and interface, 
*** of the unit, and the list of declarations of such units. The function
*** \texttt{procModule3} is called with the term corresponding to the name, or
*** name and interface, of the module as first argument, the term corresponding
*** to the set of declarations as second argument, and an empty module of the 
*** appropriate type, in which the different declarations will be accumulated, 
*** as third argument.

*** The task of the function \texttt{procModule4} is then to make a second 
*** level parsing of the input, building up, simultaneously, the preunit 
*** represented in the term passed as argument, and the unit resulting from the
*** declarations without bubbles. This unit without bubbles will be used by the
*** \texttt{evalPreModule} function to build the signature with which to 
*** analyze the bubbles in the preunit (see Section~\ref{evaluation}).

*** The case of parameterized modules requires a special treatment of the
*** parameters. These parameters are evaluated and are added as submodules in 
*** the appropriate way.

*** When the last declaration is parsed, the function \texttt{evalPreModule} is
*** called with the preunit (the top module with bubbles) as first argument,
*** the empty copy of it as second argument, the top module without bubbles as 
*** third argument, and the database.

*** Note that the \texttt{procModule} function adds a declaration importing the
*** module \texttt{CONFIGURATION+}, presented in
*** Section~\ref{non-built-in-predefined}, to the object-oriented modules, and
*** that \texttt{procModule4} adds a declaration importing the built-in module 
*** \texttt{BOOL} to all modules.

  op procModule : Term Database -> Database .
  ***  moved to MOD-EXPR-EVAL to solve dependency
  ***  op procModule : Qid Database -> Database .
  op procModule2 : Term Term Database -> Database .
  op procModule2 : Term Database -> Database .
  op procModule3 : Term Term Term Module Database -> Database .
  op procModule3 : Term Term Module Database -> Database .
  op procModule4 : Term Term Module Module OpDeclSet Database -> Database .
  op procModule4 : Term Module Module OpDeclSet Database -> Database .

  *** When recompiling a module, it's called with a Qid, and it's 
  *** not reentered into the database.

  ceq procModule(QI, DB) 
    = if DT == null
      then evalModule(U, VDS, DB)
      else procModule2(DT, DB) 
      fi 
    if < DT ; VDS ; U > := getTermModule(QI, DB) .
  eq procModule(T, DB) = procModule2(T, T, DB) .

  *** procModule2 just calls procModule3 with the name and the declarations of 
  *** the module, and an empty unit of the right type.

  eq procModule2(T, 'fmod_is_endfm[T', T''], DB) 
    = procModule3(T, T', T'', emptyFModule, DB) .
  eq procModule2(T, 'obj_is_endo[T', T''], DB) 
    = procModule3(T, T', T'', emptyFModule, DB) .
  eq procModule2(T, 'obj_is_jbo[T', T''], DB) 
    = procModule3(T, T', T'', emptyFModule, DB) .
  eq procModule2(T, 'mod_is_endm[T', T''], DB) 
    = procModule3(T, T', T'', emptySModule, DB) .
  eq procModule2(T, 'omod_is_endom[T', T''], DB)
    = procModule3(T, T', T'', 
        addImports((including 'CONFIGURATION . including 'CONFIGURATION+ .), 
          emptyOModule), 
        DB) .
  eq procModule2(T, 'fth_is_endfth[T', T''], DB) 
    = procModule3(T, T', T'', emptyFTheory, DB) .
  eq procModule2(T, 'th_is_endth[T', T''], DB) 
    = procModule3(T, T', T'', emptySTheory, DB) .
  eq procModule2(T, 'oth_is_endoth[T', T''], DB)
    = procModule3(T, T', T'', 
        addImports((including 'CONFIGURATION . including 'CONFIGURATION+ .), 
          emptyOTheory), 
        DB) .

  eq procModule2('fmod_is_endfm[T, T'], DB) 
    = procModule3(T, T', emptyFModule, DB) .
  eq procModule2('obj_is_endo[T, T'], DB) 
    = procModule3(T, T', emptyFModule, DB) .
  eq procModule2('obj_is_jbo[T, T'], DB) 
    = procModule3(T, T', emptyFModule, DB) .
  eq procModule2('mod_is_endm[T, T'], DB) 
    = procModule3(T, T', emptySModule, DB) .
  eq procModule2('omod_is_endom[T, T'], DB)
    = procModule3(T, T', 
        addImports((including 'CONFIGURATION+ .), 
          emptyOModule), 
        DB) .
  eq procModule2('fth_is_endfth[T, T'], DB) 
    = procModule3(T, T', emptyFTheory, DB) .
  eq procModule2('th_is_endth[T, T'], DB) 
    = procModule3(T, T', emptySTheory, DB) .
  eq procModule2('oth_is_endoth[T, T'], DB)
    = procModule3(T, T', 
        addImports((including 'CONFIGURATION+ .), 
          emptyOTheory), 
        DB) .

  *** procModule3 evaluates the name of the module and calls procModule4 
  *** with the declarations, two empty units (one to contain the declarations
  *** with bubbles and another one the declarations without bubbles), and
  *** a set of op decls initialy empty in which to store the variables

  ceq procModule3(T, 'token[T'], T'', U, DB)
    = procModule4(T, T'', setName(U, QI), setName(U, QI), none, DB) 
    if QI := downQid(T') .
  ceq procModule3(T, '_`{_`}['token[T'], T''], T3, U, DB)
    = procModule4(T, T3, setPars(setName(U, QI), parseParList(T'')), 
        setName(U, QI), none, DB)
    if QI := downQid(T') .

  ceq procModule3('token[T], T', U, DB)
    = procModule4(T', setName(U, QI), setName(U, QI), none, DB) 
    if QI := downQid(T) .
  ceq procModule3('_`{_`}['token[T], T'], T'', U, DB)
    = procModule4(T'', setPars(setName(U, QI), parseParList(T')), 
        setName(U, QI), none, DB)
    if QI := downQid(T) .

  *** procModule4 parses one by one each of the declarations in the module.
  *** Note that is parseDecl that adds the parsed declaration to the right 
  *** place. When it is done, it calls evalPreModule with the resulting 
  *** preModule-unit-vars triple.

  ceq procModule4(T, '__[T', T''], PU, U, VDS, DB)
    = procModule4(T, T'', preModule(PDR), unit(PDR), vars(PDR), DB) 
    if PDR := parseDecl(T', PU, U, VDS) .
  ceq procModule4(T, F[TL], PU, U, VDS, DB)
    = evalPreModule(preModule(PDR), unit(PDR), vars(PDR), 
        insTermModule(getName(U), T, DB))
    if F =/= '__ 
       /\ PDR := parseDecl(F[TL], PU, U, VDS) .
  eq procModule4(T, T', unitError(QIL), V:[Module], V:[OpDeclSet], DB) 
    = warning(DB, QIL) .
  eq procModule4(T, T', V:[Module], unitError(QIL), V:[OpDeclSet], DB) 
    = warning(DB, QIL) .
  eq procModule4(T, T', V:[Module], V':[Module], opDeclError(QIL), DB) 
    = warning(DB, QIL) .
  eq procModule4(T, F[TL], PU, U, VDS, DB)
    = warning(DB,'Error: 'no 'parse 'for F 'declaration) 
    [owise] .

  ceq procModule4('__[T, T'], PU, U, VDS, DB)
    = procModule4(T', preModule(PDR), unit(PDR), vars(PDR), DB) 
    if PDR := parseDecl(T, PU, U, VDS) .
  ceq procModule4(F[TL], PU, U, VDS, DB)
    = evalPreModule(preModule(PDR), unit(PDR), vars(PDR), DB)
    if F =/= '__ 
       /\ PDR := parseDecl(F[TL], PU, U, VDS) .
  eq procModule4(T, unitError(QIL), U, VDS, DB) = warning(DB, QIL) .
  eq procModule4(T, PU, unitError(QIL), VDS, DB) = warning(DB, QIL) .
  eq procModule4(T, PU, U, opDeclError(QIL), DB) = warning(DB, QIL) .
  eq procModule4(F[TL], PU, U, VDS, DB)
    = warning(DB,'Error: 'no 'parse 'for F 'declaration) 
    [owise] .

endfm

*******************************************************************************

***
*** 8.3.2 View Processing
***

*** A similar process is followed for views. Note that in case of operator
*** maps going to derived terms we have bubbles, which will have to be treated
*** using the signatures of the appropriate modules.

fmod VIEW-PROCESSING is
  pr UNIT-PROCESSING .
  pr VIEW-DECL-PARSING .
  pr VIEW-BUBBLE-PARSING .

  vars QI X F : Qid .
  var  QIL : QidList .
  vars T T' T'' T3 T4 : Term .
  var  M : Module .
  var  VE : ViewExp .
  var  V : View .
  vars PV PV' : PreView .
  vars ME ME' : ModuleExpression .
  vars DB DB' : Database .
  vars OPDS VDS VDS' VDS'' : OpDeclSet .
  var  MDS : MsgDeclSet .
  var  TL : TermList .
  vars PDL PDL' : ParameterDeclList .
  var  H : Header .
  var  IL : ImportList .
  var  SMS : SortMappingSet .
  var  OMS : OpMappingSet .

*** As the functions \texttt{getThSorts} and \texttt{getThClasses}
*** presented in Section~\ref{instantiation}, the functions
*** \texttt{getThOpDeclSet} and \texttt{getThMsgDeclSet} return, respectively,
*** the set of declarations of operators, and the set of declarations of 
*** messages in the theory part of the structure of the module given as 
*** argument.

  op getThOpDeclSet : Header Database -> OpDeclSet .
  op getThMsgDeclSet : Header Database -> MsgDeclSet .

  op getThOpDeclSetAux : ImportList Database -> OpDeclSet .
  op getThMsgDeclSetAux : ImportList Database -> MsgDeclSet .

  eq getThOpDeclSet(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThOpDeclSetAux(getImports(getTopModule(ME, DB)), DB) 
            getOps(getTopModule(ME, DB)))
      else none
      fi .

  eq getThOpDeclSetAux(((including ME .) IL), DB)
    = (getThOpDeclSet(ME, DB) getThOpDeclSetAux(IL, DB)) .
  eq getThOpDeclSetAux(((extending ME .) IL), DB)
    = (getThOpDeclSet(ME, DB) getThOpDeclSetAux(IL, DB)) .
  eq getThOpDeclSetAux(((protecting ME .) IL), DB)
    = (getThOpDeclSet(ME, DB) getThOpDeclSetAux(IL, DB)) .
  eq getThOpDeclSetAux(nil, DB) = none .

  eq getThMsgDeclSet(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThMsgDeclSetAux(getImports(getTopModule(ME, DB)), DB)  
            getMsgs(getTopModule(ME, DB)))
      else none
      fi .

  eq getThMsgDeclSetAux(((including ME .) IL), DB)
    = (getThMsgDeclSet(ME, DB) getThMsgDeclSetAux(IL, DB)) .
  eq getThMsgDeclSetAux(((extending ME .) IL), DB)
    = (getThMsgDeclSet(ME, DB) getThMsgDeclSetAux(IL, DB)) .
  eq getThMsgDeclSetAux(((protecting ME .) IL), DB)
    = (getThMsgDeclSet(ME, DB) getThMsgDeclSetAux(IL, DB)) .
  eq getThMsgDeclSetAux(nil, DB) = none .

*** The processing of terms representing previews accomplished by the function
*** \texttt{procView} is quite similar to the one accomplished by
*** \texttt{procModule} on terms representing preunits. The algorithms followed
*** are also quite similar. Both proceed recursively on the list of 
*** declarations, accumulating them in a preunit or in a preview.

*** The solving of bubbles in views requires the signatures of the source and
*** target units extended, respectively, with the declarations of variables in
*** the view and with the mappings of these declarations. As we shall see in
*** Section~\ref{databaseADT}, the signatures of the built-in modules are not
*** accesible at the metalevel, and thus built-in modules cannot be used
*** directly as arguments of built-in functions. Thus, to be able to use them
*** as targTS of views, a `dummy' module is created importing the 
*** corresponding predefined module. The source and target module expressions 
*** of the view are evaluated before the view processing itself starts.

*** As we saw in Section~\ref{view-decl-parsing}, parsing of terms representing
*** operator and message maps requires the set of operator and message
*** declarations in the theory part of the source theory.

  op procPars : ParameterDeclList Database -> Database .

  eq procPars((X :: ME, PDL), DB)
    = procPars(PDL, createCopy((X :: ME), database(evalModExp(ME, DB)))) .
  eq procPars((nil).ParameterDeclList, DB) = DB .

  op procView : Term Database -> Database .
  op procView2 : Term Database -> Database .
  op procView : Term PreView Database -> Database .
  op procViewAux : Term PreView OpDeclSet MsgDeclSet Module Database -> Database .

  eq procView(QI, DB) 
    = procView2(getTermView(QI, DB), DB) .

  eq procView2('view_from_to_is_endv['token[T], T', T'', T3], DB)
    = procView(T3, 
          emptyPreView(downQid(T), parseModExp(T'), parseModExp(T'')), 
          DB) .
  eq procView2('view_from_to_is_endv['_`{_`}['token[T], T'], T'', T3, T4], DB)
    = procView(T4, 
        setPars(
          emptyPreView(downQid(T), parseModExp(T''), parseModExp(T3)), 
          parseParList(T')),
        procPars(parseParList(T'), DB)) .

  eq procView('view_from_to_is_endv['token[T], T', T'', T3], DB)
    = procView(T3, 
        emptyPreView(downQid(T), parseModExp(T'), parseModExp(T'')), 
          insertTermView(downQid(T), 
            'view_from_to_is_endv['token[T], T', T'', T3], DB)) .
  eq procView('view_from_to_is_endv['_`{_`}['token[T], T'], T'', T3, T4], DB)
    = procView(T4, 
        setPars(
          emptyPreView(downQid(T), parseModExp(T''), parseModExp(T3)), 
          parseParList(T')),
        procPars(parseParList(T'), 
          insertTermView(downQid(T), 
            'view_from_to_is_endv['_`{_`}['token[T], T'], T'', T3, T4], 
            DB))) .

  ceq procView(V, DB)
    = insertView(V, DB')
    if DB' := database(evalModExp(getFrom(V), nil, database(evalModExp(getTo(V), nil, DB)))) .

  ceq procView(T, PV, DB)
    = procViewAux(T, PV, 
        getThOpDeclSet(ME, DB'),
        getThMsgDeclSet(ME, DB'),
        getFlatModule(ME, DB'),
        DB')
    if preview_from_to_is___endpv(VE, ME, ME', none, none, none) := PV 
    /\ DB' := database(evalModExp(ME', nil, database(evalModExp(ME, nil, DB)))) .
  ceq procView(T, PV, DB)
    = procViewAux(T, PV, 
        getThOpDeclSet(ME, DB':[Database]),
        getThMsgDeclSet(ME, DB':[Database]),
        getFlatModule(ME, DB':[Database]),
        DB':[Database])
    if preview_from_to_is___endpv(VE{PDL}, ME, ME', none, none, none) := PV 
    /\ DB':[Database] := database(evalModExp(ME', PDL, database(evalModExp(ME, PDL, DB)))) .

  eq procViewAux('none.ViewDeclSet, preview_from_to_is___endpv(VE{PDL}, ME, ME', VDS, SMS, OMS), OPDS, MDS, M, DB)
    = insertView(view VE{PDL} from ME to ME' is none none endv, DB) .
  eq procViewAux('none.ViewDeclSet, preview_from_to_is___endpv(VE, ME, ME', VDS, SMS, OMS), OPDS, MDS, M, DB)
    = insertView(view VE from ME to ME' is none none endv, DB) .
  eq procViewAux('__[T, T'], PV, OPDS, MDS, M, DB)
  *** - OPDS and MDS are, respectively, the set of operation and 
  ***   message declarations in the theory part of the source. 
  *** - M is the signature of the source theory.
    = procViewAux(T', parseDecl(T, PV, OPDS, MDS, M), OPDS, MDS, M, DB) .
  ceq procViewAux(F[TL], PV, OPDS, MDS, M, DB)
    = insertView(
        view VE{PDL} from ME to ME' is
          SMS
          solveBubbles(
            OMS, 
            VDS, VDS', 
            addOps(VDS, M),
            addOps(VDS', getFlatModule(ME', DB)))
        endv,
        DB)
    if F =/= '__ 
       /\ preview_from_to_is___endpv(VE{PDL}, ME, ME', VDS, SMS, OMS) := parseDecl(F[TL], PV, OPDS, MDS, M)
       /\ VDS' := applyMapsToOps(maps2rens(SMS), none, VDS, M) .
  ceq procViewAux(F[TL], PV, OPDS, MDS, M, DB)
    = insertView(
        view VE from ME to ME' is
          SMS
          solveBubbles(
            OMS, 
            VDS, VDS', 
            addOps(VDS, M),
            addOps(VDS', getFlatModule(ME', DB)))
        endv,
        DB)
    if F =/= '__ 
       /\ preview_from_to_is___endpv(VE, ME, ME', VDS, SMS, OMS) := parseDecl(F[TL], PV, OPDS, MDS, M)
       /\ VDS' := applyMapsToOps(maps2rens(SMS), none, VDS, M) .
  eq procViewAux(T, PV, OPDS, MDS, unitError(QIL), DB) = warning(DB, QIL) .
endfm

*******************************************************************************

***
*** 8.3.3 Command Processing
***

*** The function \texttt{procCommand} only handles the \texttt{reduce},
*** \texttt{rewrite}, and \texttt{down} commands. The other commands are
*** directly evaluated by the rules for the top-level handling of the
*** database (see Section~\ref{database-handling}). The \texttt{procCommand}
*** function takes a term, which represents one of these commands, the name of
*** the default module, and a database. The result is a list of quoted
*** identifiers representing the result of the evaluation of the command that 
*** will be placed in the read-eval-print loop to be printed in the terminal.

*** The \texttt{reduce} and \texttt{rewrite} commands are basically evaluated
*** calling the built-in functions \texttt{metaReduce} and
*** \texttt{metaRewrite}, respectively. These functions are called with the
*** appropriate modules. In the case of commands in which an explicit module 
*** is not specified the default module is used.

*** The preparation of the output for these functions becomes more complex
*** when the \texttt{down} command is used. To deal with the \texttt{down}
*** command, an auxiliary function \texttt{procCommand2} is introduced,
*** returning the term resulting from the evaluation of the command.

fmod COMMAND-PROCESSING is
  pr AX-COHERENCE-COMPLETION .
  pr UNIT-PROCESSING .
  pr UNIT-META-PRETTY-PRINT .
  inc (2TUPLE * (op `(_`,_`) to <<_;_>>, 
                 op p1_ to getDatabase, 
                 op p2_ to getQidList)) {Database, QidList} .
  pr META-FULL-MAUDE-SIGN .
  pr META-NARROWING-SEARCH * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) . 
  
  eq getDatabase(<< DB ; qidError(QIL) >>) = warning(DB, QIL) . 
  eq getQidList(<< DB ; qidError(QIL) >>) = QIL . 

  op {_,_} : Term Type ~> ResultPair [ctor] .
  op {_,_,_} : Term Type Substitution ~> ResultTriple [ctor] .
  op {_,_,_,_} : Term Type Substitution Context ~> Result4Tuple [ctor] .
  op {_,_} : Substitution Context ~> MatchPair [ctor] .

*** projection functions (from prelude.maude)
  op getTerm : ResultPair ~> Term .
  eq getTerm({T:[Term], T':[Type]}) = T:[Term] .
  op getType : ResultPair ~> Type .
  eq getType({T:[Term], T':[Type]}) = T':[Type] .

  op getTerm : ResultTriple ~> Term .
  eq getTerm({T:[Term], T':[Type], S:[Substitution]}) = T:[Term] .
  op getType : ResultTriple ~> Type .
  eq getType({T:[Term], T':[Type], S:[Substitution]}) = T':[Type] .
  op gTSubstitution : ResultTriple ~> Substitution .
  eq gTSubstitution({T:[Term], T':[Type], S:[Substitution]}) 
    = S:[Substitution] .

  op getTerm : Result4Tuple ~> Term .
  eq getTerm({T:[Term], T':[Type], S:[Substitution], C:[Context]}) = T:[Term] .
  op getType : Result4Tuple ~> Type .
  eq getType({T:[Term], T':[Type], S:[Substitution], C:[Context]}) = T':[Type] .
  op gTSubstitution : Result4Tuple ~> Substitution .
  eq gTSubstitution({T:[Term], T':[Type], S:[Substitution], C:[Context]}) 
    = S:[Substitution] .
  op getContext : Result4Tuple ~> Context .
  eq getContext({T:[Term], T':[Type], S:[Substitution], C:[Context]}) 
    = C:[Context] .

  op gTSubstitution : MatchPair ~> Substitution .
  eq gTSubstitution({S:[Substitution], C:[Context]}) = S:[Substitution] .
  op getContext : MatchPair ~> Context .
  eq getContext({S:[Substitution], C:[Context]}) = C:[Context] .



  vars T T' T'' T''' : Term .
  var  TL : TermList .
  vars DB DB' DB'' : Database .
  var  DB? : [Database] .
  vars M M' : Module .
  var  M? : [Module] .
  vars ME ME' : ModuleExpression .
  vars H H' : Header .
  vars MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  var  VE : ViewExp .
  var  VES : Set{ViewExp} .
  vars N I J : Nat .
  var  I? : [Nat] .
  vars D D' : Bound .
  var  D? : [Bound] .
  var  B : Bool .
  var  B? : [Bool] .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars PDS PDS' : Set{ParameterDecl} .
  var  QIL : QidList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  vars VS VDS OPDS : OpDeclSet .
  var  OPDS? : [OpDeclSet] .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  vars QI QI' F V O : Qid .
  var  Ct : Constant .
  var  IL : ImportList .
  var  TM : [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  var  TMVB : [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .
  var  TMVBN : [Tuple{Term,Module,OpDeclSet,Bound,Nat}] .
  var  T? : [Term] .
  var  RP : [ResultPair] .
  var  RT : [ResultTriple] .
  var  Sb? : [Substitution] .
  var  MP? : [MatchPair] .
  var  CD : Condition .
  var  Sb : Substitution .
  var  UP? : [UnificationPair] .
  var  UP : UnificationProblem .

----  sorts Tuple{Term,Module,Bool,OpDeclSet,Database} 
----        Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} 
----        Tuple{Term,Module,OpDeclSet,Bound,Nat} .
----  op `{_`,_`,_`,_`,_`} : Term Module Bool OpDeclSet Database 
----       -> Tuple{Term,Module,Bool,OpDeclSet,Database} .
----  op `{_`,_`,_`,_`,_`,_`} : Term Module Bool OpDeclSet Bound Database 
----       -> Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} .
----  op `{_`,_`,_`,_`,_`} : Term Module OpDeclSet Bound Nat 
----       -> Tuple{Term,Module,OpDeclSet,Bound,Nat} .
  op tupleTMBODerror : QidList -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op tupleTMBOBDerror : QidList -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .
  op tupleTMOBNerror : QidList -> [Tuple{Term,Module,OpDeclSet,Bound,Nat}] .
       
  pr 5TUPLE{Term,Module,Bool,OpDeclSet,Database} 
       * (op ((_,_,_,_,_)) to `{_`,_`,_`,_`,_`}, 
          op p1_ to getTerm, 
          op p2_ to getModule, 
          op p3_ to getBool, 
          op p4_ to getVars, 
          op p5_ to getDatabase) .
  pr 6TUPLE{Term,Module,Bool,OpDeclSet,Bound,Database}  
       * (op ((_,_,_,_,_,_)) to `{_`,_`,_`,_`,_`,_`}, 
          op p1_ to getTerm, 
          op p2_ to getModule, 
          op p3_ to getBool, 
          op p4_ to getVars, 
          op p5_ to getBound,
          op p6_ to getDatabase) . 
  pr 5TUPLE{Term,Module,OpDeclSet,Bound,Nat}  
       * (op ((_,_,_,_,_)) to `{_`,_`,_`,_`,_`}, 
          op p1_ to getTerm, 
          op p2_ to getModule, 
          op p3_ to getVars, 
          op p4_ to getBound, 
          op p5_ to getNat) .
    
  op boundError  : QidList -> [Bound] .
----  op getTerm     : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> Term .
----  op getModule   : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> Module .
----  op getVars     : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> OpDeclSet .
----  op getBool     : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> Bool .
----  op getDatabase : Tuple{Term,Module,Bool,OpDeclSet,Database} ~> Database .
  
----  op getTerm     : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Term .
----  op getModule   : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Module .
----  op getVars     : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> OpDeclSet .
----  op getBound    : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Bound .
----  op getBool     : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Bool .
----  op getDatabase : Tuple{Term,Module,Bool,OpDeclSet,Bound,Database} ~> Database .
  
----  op getTerm     : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> Term .
----  op getModule   : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> Module .
----  op getVars     : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> OpDeclSet .
----  op getBound    : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> Bound .
----  op getNat      : Tuple{Term,Module,OpDeclSet,Bound,Nat} ~> Nat .

----  eq {qidError(QIL), M?, B?, OPDS?, DB?} = tupleTMBODerror(QIL) .
----  eq {qidError(QIL), M?, B?, OPDS?, D?, DB?} = tupleTMBOBDerror(QIL) .
----  eq {qidError(QIL), M?, OPDS?, D?, I?} = tupleTMOBNerror(QIL) .

  eq getTerm({T, M, B, VDS, DB}) = T .
  eq getTerm(tupleTMBODerror(QIL)) = qidError(QIL) .
  eq getModule({T, M, B, VDS, DB}) = M .
  eq getModule(tupleTMBODerror(QIL)) = unitError(QIL) .
  eq getVars({T, M, B, VDS, DB}) = VDS .
  eq getVars(tupleTMBODerror(QIL)) = opDeclError(QIL) .
  eq getBool({T, M, B, VDS, DB}) = B .
  eq getBool(tupleTMBODerror(QIL)) = false .
  eq getDatabase({T, M, B, VDS, DB}) = DB .
  eq getDatabase(tupleTMBODerror(QIL)) = emptyDatabase .

  eq getTerm({T, M, B, VDS, D, DB}) = T .
----  eq getTerm(error(QIL)) = qidError(QIL) .
  eq getModule({T, M, B, VDS, D, DB}) = M .
----  eq getModule(error(QIL)) = unitError(QIL) .
  eq getVars({T, M, B, VDS, D, DB}) = VDS .
----  eq getVars(error(QIL)) = opDeclError(QIL) .
  eq getBound({T, M, B, VDS, D, DB}) = D .
----  eq getBound(error(QIL)) = boundError(QIL) .
  eq getBool({T, M, B, VDS, D, DB}) = B .
----  eq getBool(error(QIL)) = false .
  eq getDatabase({T, M, B, VDS, D, DB}) = DB .
----  eq getDatabase(error(QIL)) = emptyDatabase .

  eq getTerm({T, M, VDS, D, I}) = T .
----  eq getTerm(error(QIL)) = qidError(QIL) .
  eq getModule({T, M, VDS, D, I}) = M .
----  eq getModule(error(QIL)) = unitError(QIL) .
  eq getVars({T, M, VDS, D, I}) = VDS .
----  eq getVars(error(QIL)) = opDeclError(QIL) .
  eq getBound({T, M, VDS, D, I}) = D .
----  eq getBound(error(QIL)) = boundError(QIL) .
  eq getNat({T, M, VDS, D, I}) = I .
----  eq getNat(error(QIL)) = numberError(QIL) .
 
  ---- procLoad
  
  op procLoad : Term ModuleExpression Database -> Tuple{Database,QidList} .
  op procLoad : Term ModuleExpression Module OpDeclSet Database -> Tuple{Database,QidList} .

  eq procLoad(T, ME, DB)
   = if compiledModule(ME, DB)
     then procLoad(T, ME, getFlatModule(ME, DB), getVars(ME, DB), DB)
     else procLoad(T, modExp(evalModExp(ME, DB)), 
               getFlatModule(modExp(evalModExp(ME, DB)), 
                 database(evalModExp(ME, DB))), 
               getVars(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB))), 
               database(evalModExp(ME, DB)))
     fi .

  ceq procLoad(T, ME, M, VDS, DB)
    = if downTerm(T:[Term], emptyFModule) =/= emptyFModule
      then << evalModule(downModule(T:[Term]), none, DB) ; 
              'Introduced 'module header2Qid(getName(downModule(T:[Term]))) '\n >> 
      else << DB ; '\r 'Error: '\o 'Incorrect 'metamodule. '\n >>
      fi 
    if T:[Term] := getTerm(metaReduce(M, solveBubbles(T, M, true, VDS, DB))) .  
  
  ---- procCommand
  
  op procCommand : Term ModuleExpression Database -> Tuple{Database,QidList} .
  op procCommand : Term ModuleExpression Module OpDeclSet Database -> QidList .
  op procDownCommand : Term ModuleExpression Database -> Tuple{Database,QidList} .

  op procParse : ModuleExpression Module Term OpDeclSet Database -> QidList .

  op procRed : ModuleExpression Module Term OpDeclSet Database -> QidList .
  op solveBubblesRed : Term Module Bool OpDeclSet Database 
       -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op solveBubblesRed2 : Term Database -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op solveBubblesRed3 : Term Module ModuleExpression OpDeclSet Database -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .

  op procRew : ModuleExpression Module Term OpDeclSet Database -> QidList .
  op solveBubblesRew : Term Module Bool Bound OpDeclSet Database -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .
  op solveBubblesRew2 : Term Module Bool OpDeclSet Database -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .

  op procFrew : ModuleExpression Module Term Bound Nat OpDeclSet Database -> QidList .
  op solveBubblesFrew : Term Module Bool Bound Nat OpDeclSet Database -> [Tuple{Term,Module,OpDeclSet,Bound,Nat}] .
  op solveBubblesFrew2 : Term Module Bool Nat OpDeclSet Database -> [Tuple{Term,Module,OpDeclSet,Bound,Nat}] .

  op procSearch : ModuleExpression Module Term Term Qid Bound Bound OpDeclSet Database -> QidList .
  op solveBubblesSearchL : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesSearchL1 : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesSearchR : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesSearchR1 : Module Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesSearchR2 : Module Term Term Qid Bound Bound OpDeclSet -> QidList .
  op procSearch2 : Module Term Term Condition Qid Bound Bound -> QidList .
  op procSearch3 : Module Term Term Condition Qid Bound Nat Bound -> QidList .

  op procNarrowSearch : ModuleExpression Module Term Term Qid Bound Bound OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchL : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchL1 : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchR : Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchR1 : Module Module Term Term Qid Bound Bound Bool OpDeclSet Database -> QidList .
  op solveBubblesNarrowSearchR2 : Module Term Term Qid Bound Bound OpDeclSet -> QidList .
  op procNarrowSearch2 : Module Term Term Condition Qid Bound Bound -> QidList .
  op procNarrowSearch3 : Module Nat TermList ResultTripleSet -> QidList .

  op procMatch : ModuleExpression Module Term Term Qid Bound OpDeclSet Database -> QidList .
  op procMatch2 : Module Term Term Condition Qid Bound -> QidList .
  op procMatch3 : Module Term Term Condition Qid Bound Nat -> QidList .
  op solveBubblesMatch : Module Module Term Term Qid Bound Bool OpDeclSet Database ~> QidList .
  op solveBubblesMatch2 : Module Term Term Qid Bound OpDeclSet ~> QidList .

  op procUnify : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op procUnify2 : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op addInfoUnify : Module -> [Module] .
  op parseUnify : Term OpDeclSet -> UnificationProblem .
  op procUnify2 : Module UnificationProblem Bound -> QidList .
  op eMetaPrettyPrint : Module UnificationProblem -> QidList .
  op procUnify3 : Module UnificationProblem Bound Nat -> QidList .
  op procUnify3Aux : Module UnificationPair Nat -> QidList .
  op unificationProblemError : QidList -> [UnificationProblem] .

  op procIdUnify : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op procIdUnify2 : Module UnificationProblem Bound -> QidList .
  op procIdUnify3 : Module UnificationProblem Nat SubstitutionSet -> QidList .

  op procVariantUnify : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op procVariantUnify2 : Module UnificationProblem Bound -> QidList .
  op procVariantUnify3 : Module UnificationProblem Nat SubstitutionSet -> QidList .

  op procAsymmetricVariantUnify : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op procAsymmetricVariantUnify2 : Module UnificationProblem Bound -> QidList .
  op procAsymmetricVariantUnify3 : Module UnificationProblem Nat SubstitutionSet -> QidList .

  op procGetVariants : ModuleExpression Module Term Bound OpDeclSet Database -> QidList .
  op parseGetVariants : Term OpDeclSet -> Term .
  op procGetVariants2 : Module Term Bound -> QidList .
  op procGetVariants3 : Module Term Nat VariantFourSet -> QidList .

  op solveBubblesUnify : Module Term OpDeclSet ~> UnificationProblem .
  op solveBubblesRedUnify : Term Module Bool OpDeclSet Database 
       -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op solveBubblesRedUnify2 : Term Database -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op solveBubblesRedUnify3 : Term Module ModuleExpression OpDeclSet Database 
       -> [Tuple{Term,Module,Bool,OpDeclSet,Database}] .
  op procRewUnify : ModuleExpression Module Term OpDeclSet Database -> QidList .
  op solveBubblesRewUnify : Term Module Bool Bound OpDeclSet Database 
       -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .
  op solveBubblesRewUnify2 : Term Module Bool OpDeclSet Database 
       -> [Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}] .

  op eMetaPrettyPrint : Module Substitution -> QidList .

  eq eMetaPrettyPrint(M, V <- T ; Sb:Substitution)
    = V '--> '\s eMetaPrettyPrint(M, T) 
      if eMetaPrettyPrint(M, Sb:Substitution) == nil
      then nil
      else '; '\n eMetaPrettyPrint(M, Sb:Substitution)
      fi .
  eq eMetaPrettyPrint(M, (none).Substitution) = nil . 

  op procCommandUp : ModuleExpression Module Term OpDeclSet Database -> Term .
  op procRedUp : ModuleExpression Module Term OpDeclSet Database -> Term .
  op procRewUp : ModuleExpression Module Term Bound OpDeclSet Database -> Term .
  op procFrewUp : ModuleExpression Module Term Bound Nat OpDeclSet Database -> Term .

*** Processing of commands.

  ceq procDownCommand('down_:_[T, T'], ME, DB)
    = if T'':[Term] :: Term 
      then << DB'' ; 
              ('\b 'result '\o
               '\s eMetaPrettyPrint(leastSort(M, T'':[Term]))
               '\s '\b ': '\o '\n '\s '\s 
               eMetaPrettyPrint(M, T'':[Term]) '\n) >>
      else << DB ; ('\r 'Error: '\o 'Incorrect 'input. '\n) >>
      fi
    if DB' := database(evalModExp(ME, DB))  
    /\ < DB'' ; ME' > := evalModExp(parseModExp(T), DB')  
    /\ M := getFlatModule(ME', DB'') 
    /\ T'':[Term] := procCommandUp(ME, getFlatModule(ME, DB''), T', getVars(ME, DB''), DB'').

  eq procCommand(T, ME, DB)
   = if compiledModule(ME, DB)
     then << DB ; procCommand(T, ME, getFlatModule(ME, DB), getVars(ME, DB), DB) >>
     else << database(evalModExp(ME, DB)) ;
             procCommand(T, modExp(evalModExp(ME, DB)), 
               getFlatModule(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB))), 
               getVars(modExp(evalModExp(ME, DB)), database(evalModExp(ME, DB))), 
               database(evalModExp(ME, DB))) >>
     fi 
     [owise] .

----  eq procCommand(T, ME, unitError(QIL), VS, DB) = qidError(QIL) .
  eq procCommand(T, ME, unitError(QIL), VS, DB) = QIL .

  eq procCommand('parse_.['bubble[T]], ME, M, VS, DB)
   = procParse(ME, M, 'bubble[T], VS, DB) .

  eq procCommand('reduce_.['bubble[T]], ME, M, VS, DB)
    = procCommand('red_.['bubble[T]], ME, M, VS, DB) .
  eq procCommand('red_.['bubble[T]], ME, M, VS, DB)
    = procRed(ME, M, 'bubble[T], VS, DB) .

  eq procCommand('rewrite_.['bubble[T]], ME, M, VS, DB) 
    = procCommand('rew_.['bubble[T]], ME, M, VS, DB) . 
  eq procCommand('rew_.['bubble[T]], ME, M, VS, DB)
    = procRew(ME, M, 'bubble[T], VS, DB) .

  eq procCommand('frewrite_.['bubble[T]], ME, M, VS, DB) 
    = procCommand('frew_.['bubble[T]], ME, M, VS, DB) . 
  eq procCommand('frew_.['bubble[T]], ME, M, VS, DB)
    = procFrew(ME, M, 'bubble[T], unbounded, 1, VS, DB) .

  eq procCommand('search_=>1_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procSearch(ME, M, 'bubble[T], 'bubble[T'], '+, unbounded, 1, VS, DB) .
  eq procCommand('search_=>*_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procSearch(ME, M, 'bubble[T], 'bubble[T'], '*, unbounded, unbounded, VS, DB) .
  eq procCommand('search_=>+_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procSearch(ME, M, 'bubble[T], 'bubble[T'], '+, unbounded, unbounded, VS, DB) .
  eq procCommand('search_=>!_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procSearch(ME, M, 'bubble[T], 'bubble[T'], '!, unbounded, unbounded, VS, DB) .

  eq procCommand('search_~>1_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procNarrowSearch(ME, M, 'bubble[T], 'bubble[T'], '+, unbounded, 1, VS, DB) .
  eq procCommand('search_~>*_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procNarrowSearch(ME, M, 'bubble[T], 'bubble[T'], '*, unbounded, unbounded, VS, DB) .
  eq procCommand('search_~>+_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procNarrowSearch(ME, M, 'bubble[T], 'bubble[T'], '+, unbounded, unbounded, VS, DB) .
  eq procCommand('search_~>!_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procNarrowSearch(ME, M, 'bubble[T], 'bubble[T'], '!, unbounded, unbounded, VS, DB) .

  eq procCommand('match_<=?_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procMatch(ME, M, 'bubble[T], 'bubble[T'], 'match, 0, VS, DB) .
  eq procCommand('xmatch_<=?_.['bubble[T], 'bubble[T']], ME, M, VS, DB) 
    = procMatch(ME, M, 'bubble[T], 'bubble[T'], 'xmatch, 0, VS, DB) .

  eq procCommand('unify_.['bubble[T]], ME, M, VS, DB) 
    = procUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('id-unify_.['bubble[T]], ME, M, VS, DB) 
    = procIdUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('variant`unify_.['bubble[T]], ME, M, VS, DB) 
    = procVariantUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('asymmetric`variant`unify_.['bubble[T]], ME, M, VS, DB) 
    = procAsymmetricVariantUnify(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommand('get`variants_.['bubble[T]], ME, M, VS, DB) 
    = procGetVariants(ME, M, 'bubble[T], unbounded, VS, DB) .

  eq procCommandUp(ME, M, 'down_:_[T, T'], VDS, DB) 
    = downTerm(procCommandUp(ME, M, T', VDS, DB)) .
  eq procCommandUp(ME, M, 'red_.['bubble[T]], VDS, DB) 
    = downTerm(procRedUp(ME, M, 'bubble[T], VDS, DB)) .
  eq procCommandUp(ME, M, 'reduce_.['bubble[T]], VDS, DB)
    = downTerm(procRedUp(ME, M, 'bubble[T], VDS, DB)) .
  eq procCommandUp(ME, M, 'rew_.['bubble[T]], VDS, DB) 
    = downTerm(procRewUp(ME, M, 'bubble[T], unbounded, VDS, DB)) .
  eq procCommandUp(ME, M, 'rewrite_.['bubble[T]], VDS, DB)
    = downTerm(procRewUp(ME, M, 'bubble[T], unbounded, VDS, DB)) .
  eq procCommandUp(ME, M, 'frew_.['bubble[T]], VDS, DB) 
    = downTerm(procFrewUp(ME, M, 'bubble[T], unbounded, 0, VDS, DB)) .
  eq procCommandUp(ME, M, 'frewrite_.['bubble[T]], VDS, DB)
    = downTerm(procFrewUp(ME, M, 'bubble[T], unbounded, 0, VDS, DB)) .

  ceq procRedUp(ME, M, T, VDS, DB) 
    = if metaReduce(getModule(TM), getTerm(TM)) :: ResultPair
      then getTerm(metaReduce(getModule(TM), getTerm(TM)))
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TM := solveBubblesRed(T, M, 
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB), 
               VDS, DB) .

  ceq procRewUp(ME, M, T, D, VDS, DB) 
    = if metaRewrite(getModule(TMVB), getTerm(TMVB), getBound(TMVB)) 
           :: ResultPair
      then getTerm(metaRewrite(getModule(TMVB), getTerm(TMVB), getBound(TMVB)))
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TMVB := solveBubblesRew(T, M, 
                included('META-MODULE, getImports(getTopModule(ME, DB)), DB), 
                D, VDS, DB) .

  ceq procFrewUp(ME, M, T, D, I, VDS, DB) 
    = if metaFrewrite(
           getModule(TMVBN), getTerm(TMVBN), getBound(TMVBN), getNat(TMVBN))
         :: ResultPair
      then getTerm(
             metaFrewrite(getModule(TMVBN), getTerm(TMVBN), 
               getBound(TMVBN), getNat(TMVBN)))
      else qidError('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi
    if TMVBN := solveBubblesFrew(T, M, 
                 included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                 D, I, VDS, DB) .

  ceq procParse(ME, M, T, VDS, DB)
    = if leastSort(getModule(TM), getTerm(TM)) :: Type
      then (eMetaPrettyPrint(leastSort(getModule(TM), getTerm(TM)))
            '\s '\b ': '\o '\n '\s '\s 
            eMetaPrettyPrint(getModule(TM), getTerm(TM)) '\n)
      else getMsg(getTerm(TM))
      fi
    if TM := solveBubblesRed(T, M, 
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB), 
               VDS, DB) .
  eq procParse(ME, unitError(QIL), T, VDS, DB) = QIL .
  eq procParse(ME, noModule, T, VDS, DB) = getMsg(DB) .

  ceq procRed(ME, M, T, VDS, DB)
    = if metaReduce(getModule(TM), getTerm(TM)) :: ResultPair
      then ('\b 'reduce 'in 
            '\o eMetaPrettyPrint(getName(getModule(TM))) '\b ': '\o '\n '\s '\s
            eMetaPrettyPrint(getModule(TM), getTerm(TM)) '\n 
            '\b 'result '\o '\s 
            eMetaPrettyPrint(getType(metaReduce(getModule(TM), getTerm(TM))))
            '\s '\b ': '\o '\n '\s '\s 
            eMetaPrettyPrint(getModule(TM), 
              getTerm(metaReduce(getModule(TM), getTerm(TM))))
            '\n)
      else getMsg(getTerm(metaReduce(getModule(TM), getTerm(TM))))
      fi 
    if TM := solveBubblesRed(T, M, 
               included('META-MODULE, getImports(getTopModule(ME, DB)), DB), 
               VDS, DB) .
  eq procRed(ME, unitError(QIL), T, VDS, DB) = QIL .
  eq procRed(ME, noModule, T, VDS, DB) = getMsg(DB) .

  eq metaReduce(unitError(QIL), T) = {qidError(QIL), '`[Term`]} .
  eq metaReduce(U:[Module], qidError(QIL)) = {qidError(QIL), '`[Term`]} .

  ceq solveBubblesRed('bubble[QI], M, B, VDS, DB) 
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else tupleTMBODerror('\r 'Error: '\o 'no 'parse 'for downQidList(QI) '\n)
      fi 
    if T? := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesRed('bubble['__[TL]], M, B, VDS, DB) 
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else if metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@) :: ResultPair
           then solveBubblesRed2(
                  getTerm(metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@)), 
                  DB) 
           else tupleTMBODerror(
                  '\r 'Warning: '\o 
                    printSyntaxError(
                      metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), 
                       '@RedInPart@), downQidList('__[TL, ''..Qid])) '\n
                    '\r 'Error: '\o 
                    'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n)
           fi
      fi 
    if T? := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .
  *** There is some problem parsing 'in_:_ in solveBubblesRed, but it 
  *** seems to work with the additional '.

  ceq solveBubblesRed2('in_:_.[T, T'], DB) 
    = if unitInDb(ME, DB')
      then solveBubblesRed3(T', getFlatModule(ME, DB'), ME, getVars(ME, DB'), DB')
      else tupleTMBODerror('\r 'Error: '\o 'It 'is 'not 'possible 'to 'compile eMetaPrettyPrint(ME) '. '\n)
      fi 
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesRed2('in_:_.[T, T'], DB) 
    = tupleTMBODerror('\r 'Error: '\o 'It 'isn't 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n)
    [owise] .

  eq solveBubblesRed3(T, M, ME, VDS, DB) 
    = {solveBubbles(T, M, 
         included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
         VDS, DB),
       M, 
       included('META-MODULE, getImports(getTopModule(ME, DB)), DB), 
       VDS, 
       DB} .

  op GRAMMAR-RED : -> FModule [memo] .
  eq GRAMMAR-RED
    = addImports((including 'MOD-EXPRS .),
        addSorts('@RedInPart@,
          addOps((op 'in_:_. : '@ModExp@ '@Bubble@ -> '@RedInPart@ [none] .),
            BUBBLES))) .

  ceq procRew(ME, M, T, VDS, DB)
    = if RP :: ResultPair
      then ('\b 'rewrite 'in '\o eMetaPrettyPrint(getName(getModule(TMVB))) 
            '\b ': '\o '\n '\s '\s 
            eMetaPrettyPrint(getModule(TMVB), getTerm(TMVB)) '\n 
            '\b 'result '\o '\s 
            eMetaPrettyPrint(getType(RP))
            '\s '\b ': '\o '\n '\s '\s 
            eMetaPrettyPrint(getModule(TMVB), getTerm(RP))
            '\n)
      else getMsg(getTerm(TMVB))
      fi 
    if TMVB := solveBubblesRew(T, M, 
                included('META-MODULE, getImports(getTopModule(ME, DB)), DB),
                unbounded, VDS, DB) 
       /\ RP  := metaRewrite(getModule(TMVB), getTerm(TMVB), getBound(TMVB)) .
  eq procRew(ME, unitError(QIL), T, VDS, DB) = qidError(QIL) .

  eq solveBubblesRew('bubble[QI], M, B, D, VDS, DB) 
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble[QI], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else tupleTMBOBDerror(
             '\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB) 
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble['__[TL]], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else if metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@)
                :: ResultPair
           then solveBubblesRew2(
                  getTerm(
                    metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), 
                      '@RewNuPart@)), 
                  M, B, VDS, DB) 
           else {getTerm(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)), 
                 getModule(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)), 
                 getBool(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)), 
                 getVars(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 unbounded, 
                 getDatabase(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB))}
           fi
      fi .

  eq solveBubblesRew2('`[_`]_.['token[T], T'], M, B, VDS, DB) 
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB) 
                    :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then {getTerm(solveBubblesRed(T', M, B, VDS, DB)), 
            getModule(solveBubblesRed(T', M, B, VDS, DB)),
            getBool(solveBubblesRed(T', M, B, VDS, DB)),
            getVars(solveBubblesRed(T', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            getDatabase(solveBubblesRed(T', M, B, VDS, DB))}
      else tupleTMBOBDerror(
             '\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  op GRAMMAR-REW : -> FModule [memo] .
  eq GRAMMAR-REW
    = addSorts('@RewNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ; '@NeTokenList@ ; '@Bubble@,
        addOps((op '`[_`]_. : '@Token@ '@Bubble@ -> '@RewNuPart@ [none] .),
          BUBBLES)) .

----  eq metaRewrite(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T, D)
----    = metaReduce(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T) .
----  eq metaRewrite(M, T, 0) = {T, leastSort(M, T)} .

  *** FREW

  ceq procFrew(ME, M, T, D, I, VDS, DB)
    = if RP :: ResultPair
      then ('\b 'frewrite 'in '\o eMetaPrettyPrint(getName(getModule(TMVBN))) 
            '\b ': '\o  '\n '\s '\s 
            eMetaPrettyPrint(getModule(TMVBN), getTerm(TMVBN)) '\n 
            '\b 'result '\o '\s eMetaPrettyPrint(getType(RP)) 
            '\s '\b ': '\o '\n '\s '\s 
            eMetaPrettyPrint(getModule(TMVBN), getTerm(RP)) '\n)
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi 
    if TMVBN := solveBubblesFrew(T, M, 
                 included('META-MODULE, getImports(getTopModule(ME, DB)), DB), 
                 D, I, VDS, DB) 
       /\ RP   := metaFrewrite(getModule(TMVBN), getTerm(TMVBN), 
                               getBound(TMVBN),  getNat(TMVBN)) .
  eq procFrew(ME, unitError(QIL), T, D, I, VDS, DB) = qidError(QIL) .

  eq solveBubblesFrew('bubble[QI], M, B, D, I, VDS, DB) 
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble[QI], M, B, VDS, DB), M, VDS, unbounded, I}
      else tupleTMOBNerror(
             '\r 'Error: '\o 'no 'parse 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesFrew('bubble['__[TL]], M, B, D, I, VDS, DB) 
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble['__[TL]], M, B, VDS, DB), 
              M, VDS, unbounded, I}
      else if metaParse(GRAMMAR-FREW, downQidList('__[TL, ''..Qid]), 
                '@FrewNuPart@)
                :: ResultPair
           then solveBubblesFrew2(
                  getTerm(
                    metaParse(GRAMMAR-FREW, downQidList('__[TL, ''..Qid]), 
                      '@FrewNuPart@)), 
                  M, B, I, VDS, DB) 
           else {getTerm(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)), 
                 getModule(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 getVars(solveBubblesRed('bubble['__[TL]], M, B, VDS, DB)),
                 unbounded, I}
           fi
      fi .
  *** There is some problem parsing _ in solveBubblesRed, but it 
  *** seems to work with the additional '.

  eq solveBubblesFrew2('`[_`]_.['token[T], T'], M, B, I, VDS, DB) 
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB) 
                    :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then {getTerm(solveBubblesRed(T', M, B, VDS, DB)), 
            getModule(solveBubblesRed(T', M, B, VDS, DB)),
            getVars(solveBubblesRed(T', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            I}
      else tupleTMOBNerror(
             '\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesFrew2('`[_`,_`]_.['token[T], 'token[T'], T''], 
       M, B, I, VDS, DB) 
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB) 
                    :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then {getTerm(solveBubblesRed(T'', M, B, VDS, DB)), 
            getModule(solveBubblesRed(T'', M, B, VDS, DB)),
            getVars(solveBubblesRed(T'', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            downNat(downMetaNat(T'))}
      else tupleTMOBNerror('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  op GRAMMAR-FREW : -> FModule [memo] .
  eq GRAMMAR-FREW
    = addSorts('@FrewNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ; '@NeTokenList@ ; '@Bubble@,
        addOps(
          (op '`[_`]_. : '@Token@ '@Bubble@ -> '@FrewNuPart@ [none] .
           op '`[_`,_`]_. : '@Token@ '@Token@ '@Bubble@ -> '@FrewNuPart@ [none] .),
          BUBBLES)) .

  eq metaFrewrite(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T, D, I)
    = metaReduce(fmod QI is IL sorts SS . SSDS OPDS MAS EqS endfm, T) .
  eq metaFrewrite(M, T, 0, I) = {T, leastSort(M, T)} .
  eq metaFrewrite(M, T, D, 0) = {T, leastSort(M, T)} .

  *** SEARCH 

  op GRAMMAR-SEARCH : -> FModule [memo] .
  eq GRAMMAR-SEARCH
    = addSorts('@SearchNuPart@ ; '@Token@ ; '@SortToken@ ; '@ViewToken@ ; '@NeTokenList@ ; '@Bubble@,
        addOps((op '`[_`,_`]_. : '@Token@ '@Token@ '@Bubble@ -> '@SearchNuPart@ [none] .)
               (op '`[`,_`]_. : '@Token@ '@Bubble@ -> '@SearchNuPart@ [none] .),
          BUBBLES)) .

  ceq procSearch(ME, M, T, T', QI, D, D', VDS, DB)
    *** D is a bound on the number of solutions, and D' is a bound on the depth of the search
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procSearch2(addOps(VDS, M), 
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)), 
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, D, D')
      else solveBubblesSearchL(M, T, T', QI, D, D', B, VDS, DB)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq solveBubblesSearchL(M, 'bubble[QI], T, QI', D, D', B, VDS, DB) 
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then solveBubblesSearchR(M, solveBubbles('bubble[QI], M, B, VDS, DB), T, QI', D, D', B, VDS, DB)
      else ('\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesSearchL(M, 'bubble['__[TL]], T, QI, D, D', B, VDS, DB) 
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then solveBubblesSearchR(M, solveBubbles('bubble['__[TL]], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else if metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@) :: ResultPair
           then solveBubblesSearchL1(
                  M,
                  getTerm(metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@)), 
                  T, QI, D, D', B, VDS, DB) 
           else solveBubblesSearchR(
                  getModule(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)), 
                  getTerm(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)), 
                  T,
                  QI, 
                  getBound(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  D',
                  getBool(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getVars(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getDatabase(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)))
           fi
      fi .

  eq solveBubblesSearchL1(M, '`[`,_`]_.['token[T], T'], T'', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then solveBubblesSearchR(
             getModule(solveBubblesRed(T', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T', M, B, VDS, DB)), 
             T'', QI, D,  
             downNat(downMetaNat(T)), 
             B, 
             getVars(solveBubblesRed(T', M, B, VDS, DB)), 
             DB) 
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesSearchL1(M, '`[_`,_`]_.['token[T], 'token[T'], T''], T''', QI, D, D', B, VDS, DB) 
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then solveBubblesSearchR(
             getModule(solveBubblesRed(T'', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T'', M, B, VDS, DB)), 
             T''', QI,  
             downNat(downMetaNat(T)), 
             downNat(downMetaNat(T')), 
             B, 
             getVars(solveBubblesRed(T'', M, B, VDS, DB)), 
             DB) 
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  eq solveBubblesSearchR(M, T, T', QI, D, D', B, VDS, DB)
    = solveBubblesSearchR1(
        M, 
        addOps(
          op '_s.t._. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .
          op '_such`that_. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .,
          addSorts('PatternCondition, addInfoConds(M))),
        T, 
        T', 
        QI, 
        D, 
        D', 
        B, 
        VDS, 
        DB) .
  eq solveBubblesSearchR(M:[Module], T:[Term], T':[Term], QI:[Qid], D:[Bound], D':[Bound], B:[Bool], VDS:[OpDeclSet], DB:[Database])
    = ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n) .
    
  ceq solveBubblesSearchR1(M, M', T, 'bubble[QI], QI', D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procSearch2(M, T, T?:[Term], nil, QI', D, D')
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n) 
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) . 
  ceq solveBubblesSearchR1(M, M', T, 'bubble['__[TL]], QI, D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procSearch2(M, T, T?:[Term], nil, QI, D, D')
      else if metaParse(M', downQidList('__[TL, ''..Qid]), 'PatternCondition) 
                :: ResultPair
           then solveBubblesSearchR2(M, T, 
                  getTerm(
                    metaParse(M', downQidList('__[TL, ''..Qid]), 
                      'PatternCondition)), 
                  QI, D, D', VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
           fi
      fi 
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesSearchR2(M, T, QI, QI', D, D', VDS)
    = procSearch2(M, T, constsToVars(QI, VDS), nil, QI', D, D') .
  eq solveBubblesSearchR2(M, T, F[T], QI, D, D', VDS)
    = procSearch2(M, T, constsToVars(F[T], VDS), nil, QI, D, D') .
  eq solveBubblesSearchR2(M, T, F[T', T''], QI, D, D', VDS)
    = if F == '_s.t._. or F == '_such`that_. 
      then procSearch2(M, T, T', parseCond(T'', VDS), QI, D, D')
      else procSearch2(M, T, constsToVars(F[T', T''], VDS), nil, QI, D, D')
      fi .
  eq solveBubblesSearchR2(M, T, F[T', T'', TL], QI, D, D', VDS)
    = procSearch2(M, T, constsToVars(F[T', T'', TL], VDS), nil, QI, D, D') .

  ceq procSearch2(M, T, T', CD, QI, D, D')
    = if RT :: ResultTriple
      then ('search 
            if D == unbounded and D' == unbounded
            then nil
            else '\s '`[ 
                 if D == unbounded 
                 then nil 
                 else qid(string(D, 10)) 
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))  
                 fi
                 '`] '\s
            fi 
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T) '\s qid("=>" + string(QI)) '\s 
            eMetaPrettyPrint(M, T'') '. '\n '\n
            'Solution '1 '\n
            if gTSubstitution(RT) == none
            then 'empty 'substitution '\n '\n
            else eMetaPrettyPrint(M, gTSubstitution(RT)) '\n '\n
            fi
            procSearch3(M, T, T'', CD, QI, D, 1, D'))
      else if RT == failure
           then ('search 
           if D == unbounded and D' == unbounded
            then nil
            else '\s '`[ 
                 if D == unbounded 
                 then nil 
                 else qid(string(D, 10)) 
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))  
                 fi
                 '`] '\s
            fi 
            'in eMetaPrettyPrint(getName(M)) ':
                 eMetaPrettyPrint(M, T) 
                 '\s qid("=>" + string(QI)) '\s 
                 eMetaPrettyPrint(M, T'') '. '\n '\n 
                'No 'solution. '\n) 
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n 
           fi
      fi 
    if T'' := prepSearchPattern(T')
       /\ RT := metaSearch(M, T, T'', CD, QI, D', 0) .


  eq procSearch3(M, T, T', CD, QI, D, I, D')
    = if D == unbounded or-else (D == 0 or-else I < D) 
      then if metaSearch(M, T, T', CD, QI, D', I) :: ResultTriple
           then ('Solution qid(string(I + 1, 10)) '\n
                 if gTSubstitution(metaSearch(M, T, T', CD, QI, D', I)) == none
                 then 'empty 'substitution '\n '\n 
                 else eMetaPrettyPrint(M, 
                            gTSubstitution(
                              metaSearch(M, T, T', CD, QI, D', I))) '\n '\n 
                 fi
                 procSearch3(M, T, T', CD, QI, D, I + 1, D'))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .  

-------------------
*** Equal to procSearch except replacing metaSearch by metaNarrowSearch

  ceq procNarrowSearch(ME, M, T, T', QI, D, D', VDS, DB)
    *** D is a bound on the number of solutions, and D' is a bound on the depth of the search
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procNarrowSearch2(addOps(VDS, M), 
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)), 
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, D, D')
      else solveBubblesNarrowSearchL(M, T, T', QI, D, D', B, VDS, DB)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq solveBubblesNarrowSearchL(M, 'bubble[QI], T, QI, D, D', B, VDS, DB) 
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then solveBubblesNarrowSearchR(M, solveBubbles('bubble[QI], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else ('\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesNarrowSearchL(M, 'bubble['__[TL]], T, QI, D, D', B, VDS, DB) 
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then solveBubblesNarrowSearchR(M, solveBubbles('bubble['__[TL]], M, B, VDS, DB), T, QI, D, D', B, VDS, DB)
      else if metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), '@SearchNuPart@) :: ResultPair
           then solveBubblesNarrowSearchL1(
                  M,
                  getTerm(
                    metaParse(GRAMMAR-SEARCH, downQidList('__[TL, ''..Qid]), 
                      '@SearchNuPart@)), 
                  T, QI, D, D', B, VDS, DB) 
           else solveBubblesNarrowSearchR(
                  getModule(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)), 
                  getTerm(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)), 
                  T,
                  QI, 
                  getBound(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  D',
                  getBool(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getVars(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)),
                  getDatabase(solveBubblesRew('bubble['__[TL]], M, B, D, VDS, DB)))
           fi
      fi .

  eq solveBubblesNarrowSearchL1(M, '`[`,_`]_.['token[T], T'], T'', QI, D, D', B, VDS, DB)
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRed(T', M, B, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then solveBubblesNarrowSearchR(
             getModule(solveBubblesRed(T', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T', M, B, VDS, DB)), 
             T'', QI, D,  
             downNat(downMetaNat(T)), 
             B, 
             getVars(solveBubblesRed(T', M, B, VDS, DB)), 
             DB) 
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .
  eq solveBubblesNarrowSearchL1(M, '`[_`,_`]_.['token[T], 'token[T'], T''], T''', QI, D, D', B, VDS, DB) 
    = if downNat(downMetaNat(T)) :: Nat
         and-then downNat(downMetaNat(T')) :: Nat
         and-then solveBubblesRed(T'', M, B, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then solveBubblesNarrowSearchR(
             getModule(solveBubblesRed(T'', M, B, VDS, DB)),
             getTerm(solveBubblesRed(T'', M, B, VDS, DB)), 
             T''', QI,  
             downNat(downMetaNat(T)), 
             downNat(downMetaNat(T')), 
             B, 
             getVars(solveBubblesRed(T'', M, B, VDS, DB)), 
             DB) 
      else ('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  eq solveBubblesNarrowSearchR(M, T, T', QI, D, D', B, VDS, DB)
    = solveBubblesNarrowSearchR1(
        M, 
        addOps(
          op '_s.t._. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .
          op '_such`that_. : leastSort(M, T) '@Condition@ -> 'PatternCondition [none] .,
          addSorts('PatternCondition, addInfoConds(M))),
        T, 
        T', 
        QI, 
        D, 
        D', 
        B, 
        VDS, 
        DB) .
  eq solveBubblesNarrowSearchR(M:[Module], T:[Term], T':[Term], QI:[Qid], D:[Bound], D':[Bound], B:[Bool], VDS:[OpDeclSet], DB:[Database])
    = qidError('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n) .
    
  ceq solveBubblesNarrowSearchR1(M, M', T, 'bubble[QI], QI', D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procNarrowSearch2(M, T, T?:[Term], nil, QI', D, D')
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n) 
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) . 
  ceq solveBubblesNarrowSearchR1(M, M', T, 'bubble['__[TL]], QI, D, D', B, VDS, DB)
    = if T?:[Term] :: Term
      then procNarrowSearch2(M, T, T?:[Term], nil, QI, D, D')
      else if metaParse(M', downQidList('__[TL, ''..Qid]), 'PatternCondition) 
                :: ResultPair
           then solveBubblesNarrowSearchR2(M, T, 
                  getTerm(
                    metaParse(M', downQidList('__[TL, ''..Qid]), 
                      'PatternCondition)), 
                  QI, D, D', VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n
           fi
      fi 
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesNarrowSearchR2(M, T, QI, QI', D, I, VDS)
    = procNarrowSearch2(M, T, constsToVars(QI, VDS), nil, QI', D, I) .
  eq solveBubblesNarrowSearchR2(M, T, F[T], QI, D, I, VDS)
    = procNarrowSearch2(M, T, constsToVars(F[T], VDS), nil, QI, D, I) .
  eq solveBubblesNarrowSearchR2(M, T, F[T', T''], QI, D, I, VDS)
    = if F == '_s.t._. or F == '_such`that_. 
      then procNarrowSearch2(M, T, T', parseCond(T'', VDS), QI, D, I)
      else procNarrowSearch2(M, T, constsToVars(F[T', T''], VDS), nil, QI, D, I)
      fi .
  eq solveBubblesNarrowSearchR2(M, T, F[T', T'', TL], QI, D, I, VDS)
    = procNarrowSearch2(M, T, constsToVars(F[T', T'', TL], VDS), nil, QI, D, I) .

----  op axCohComplete : SModule -> SModule .       ---- Defined later in module AX-COHERENCE-COMPLETION

  sort IdsToRemove .                             ---- moved from VARIANTS
  ops all non-handled : -> IdsToRemove .         ---- moved from VARIANTS
  op removeIds : Module IdsToRemove ~> Module .  ---- moved from VARIANTS
  
  ceq procNarrowSearch2(M, T, T', CD, QI, D, D')
    = if RTS:[ResultTripleSet] :: ResultTripleSet
      then ('search 
            if D == unbounded and D' == unbounded
            then nil
            else '\s '`[ 
                 if D == unbounded 
                 then nil 
                 else qid(string(D, 10)) 
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))  
                 fi
                 '`] '\s
            fi 
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T) '\s qid("~>" + string(QI)) '\s 
            eMetaPrettyPrint(M, T'') '.
            procNarrowSearch3(M, 0, Vars((T,T')), RTS:[ResultTripleSet])
            if D =/= unbounded and-then D' == unbounded and-then | RTS:[ResultTripleSet] | < D
            then procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS:[ResultTripleSet],1)
            else nil
            fi 
            ('\n '\n 'No 'more 'solutions. '\n))
      else if RTS:[ResultTripleSet] == empty
           then ('search 
           if D == unbounded and D' == unbounded
            then nil
            else '\s '`[ 
                 if D == unbounded 
                 then nil 
                 else qid(string(D, 10)) 
                 fi
                 if D' == unbounded
                 then nil
                 else '`, qid(string(D', 10))  
                 fi
                 '`] '\s
            fi 
            'in eMetaPrettyPrint(getName(M)) ':
                 eMetaPrettyPrint(M, T) 
                 '\s qid("~>" + string(QI)) '\s 
                 eMetaPrettyPrint(M, T'') '. '\n '\n
                 'No 'solution. '\n) 
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'search 'command. '\n 
           fi
      fi 
    if T'' := prepSearchPattern(T')
       /\ RTS:[ResultTripleSet]
          := upDown(M,
              metaNarrowSearchGen(
                 removeIds(axCohComplete(M), non-handled),
                 T,
                 T'', 
                 none, 
                 typeOfRelation(QI), 
                 D', 
                 D, 
                 unbounded,
                 full E-ACU-unify noStrategy E-normalize-terms) 
              |> (T,T'') 
             ) .

  var RTS' : ResultTripleSet .

  op procNarrowSearch2RT : Module Term Term Condition Qid Bound Bound ResultTripleSet Nat -> QidList .
  ceq procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS',J)
    = nil
   if | RTS' | == D .
  ceq procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS',J)
    = if RTS:[ResultTripleSet] :: ResultTripleSet
      then (procNarrowSearch3(M, | RTS' |, Vars((T,T')), RTS:[ResultTripleSet])
            procNarrowSearch2RT(M, T, T', CD, QI, D, D',RTS' | RTS:[ResultTripleSet],J + 1) )
      else nil 
      fi 
    if | RTS' | < D
       /\ T'' := prepSearchPattern(T')
       /\ (RTS' | RTS:[ResultTripleSet])
          := upDown(M,
              metaNarrowSearchGen(
                 removeIds(axCohComplete(M), non-handled),
                 T,
                 T'', 
                 none, 
                 typeOfRelation(QI), 
                 D', 
                 D + J, 
                 unbounded,
                 full E-ACU-unify noStrategy E-normalize-terms) 
              |> (T,T'') 
             ) .

  eq procNarrowSearch3(M, I, TL:TermList, empty)
   = nil .
  eq procNarrowSearch3(M, I, TL:TermList, {T:Term,TP:Type,S:Substitution} | RTS:ResultTripleSet)
    = ('\n '\n 'Solution qid(string(I + 1, 10))
       if (S:Substitution |> TL:TermList) == none
       then '\n 'empty 'substitution
       else '\n eMetaPrettyPrint(M, S:Substitution |> TL:TermList)
       fi
       procNarrowSearch3(M, I + 1, TL:TermList, RTS:ResultTripleSet)) .

-------------------

  sort Tuple{TermList, Nat} .
  op <_;_> : Term Nat -> Tuple{TermList, Nat} .
  op term : Tuple{TermList, Nat} -> TermList .
  op index : Tuple{TermList, Nat} -> Nat .
  eq term(< TL:[TermList] ; I:[Nat] >) = TL:[TermList] .
  eq index(< TL:[TermList] ; I:[Nat] >) = I:[Nat] .

  op prepSearchPattern : Term -> Term .
  op prepSearchPattern : TermList Nat -> Tuple{TermList, Nat} .

  eq prepSearchPattern(T) = term(prepSearchPattern(T, 0)) .

  eq prepSearchPattern('<_:_|_>[O, Ct, T], I)
    = < '<_:_|_>[O, qid("V#" + string(I, 10) + ":" + string(getName(Ct))),
           '_`,_[term(prepSearchPattern(T, s s I)), 
                 qid("V#" + string(s I, 10) + ":AttributeSet")]] ;
        index(prepSearchPattern(T, s s I)) > .
  eq prepSearchPattern('<_:_|`>[O, Ct], I)
    = < '<_:_|_>[O, qid("V#" + string(I, 10) + ":" + string(getName(Ct))),
           qid("V#" + string(s I, 10) + ".AttributeSet")] ;
        s I > .
  eq prepSearchPattern(F[TL], I)
    = < F[term(prepSearchPattern(TL, I))] ;
        index(prepSearchPattern(TL, I)) >
    [owise] .

  eq prepSearchPattern(F, I) = < F ; I > .
  eq prepSearchPattern(Ct, I) = < Ct ; I > .

  ceq prepSearchPattern((T, TL), I)
    = < (term(prepSearchPattern(T, I)), 
         term(prepSearchPattern(TL, index(prepSearchPattern(T, I))))) ;
        index(prepSearchPattern(TL, index(prepSearchPattern(T, I)))) > 
    if TL =/= empty .

  *** MATCH 

  ceq procMatch(ME, M, T, T', QI, I, VDS, DB)
    *** the number I the number of solutions
    = if solveBubblesRl(T, T', M, B, VDS, DB) :: Term
      then procMatch2(addOps(VDS, M), 
             lhs(solveBubblesRl(T, T', M, B, VDS, DB)), 
             rhs(solveBubblesRl(T, T', M, B, VDS, DB)), nil, QI, I)
      else if solveBubblesRew(T, M, B, I, VDS, DB)
                :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
           then solveBubblesMatch(
                  getModule(solveBubblesRew(T, M, B, I, VDS, DB)), 
                  addOps(
                    op '_s.t._. : 
                       leastSort(
                         getModule(solveBubblesRew(T, M, B, I, VDS, DB)),
                         getTerm(solveBubblesRew(T, M, B, I, VDS, DB)))
                       '@Condition@ -> 'PatternCondition [none] .
                    op '_such`that_. : 
                       leastSort(
                         getModule(solveBubblesRew(T, M, B, I, VDS, DB)),
                         getTerm(solveBubblesRew(T, M, B, I, VDS, DB)))
                       '@Condition@ -> 'PatternCondition [none] .,
                    addSorts('PatternCondition, 
                      addInfoConds(
                        getModule(solveBubblesRew(T, M, B, I, VDS, DB))))),
                  getTerm(solveBubblesRew(T, M, B, I, VDS, DB)), 
                  T', 
                  QI, 
                  (if getBound(solveBubblesRew(T, M, B, I, VDS, DB)) 
                         == unbounded
                   then 0
                   else getBound(solveBubblesRew(T, M, B, I, VDS, DB))
                   fi), 
                  B, 
                  getVars(solveBubblesRew(T, M, B, I, VDS, DB)), 
                  DB)
           else getMsg(getTerm(solveBubblesRew(T, M, B, I, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'match 'command. '\n)
           fi
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ceq solveBubblesMatch(M, M', T, 'bubble[QI], QI', I, B, VDS, DB)
    = if T?:[Term] :: Term
      then procMatch2(M, T, T?:[Term], nil, QI', I)
      else ('\r 'Error: '\o 'Incorrect 'use 'of 'the 'match 'command. '\n) 
      fi
    if T?:[Term] := solveBubbles('bubble[QI], M, B, VDS, DB) . 
  ceq solveBubblesMatch(M, M', T, 'bubble['__[TL]], QI, I, B, VDS, DB)
    = if T?:[Term] :: Term
      then procMatch2(M, T, T?:[Term], nil, QI, I)
      else if metaParse(M', downQidList('__[TL, ''..Qid]), 'PatternCondition) 
                :: ResultPair
           then solveBubblesMatch2(M, T, 
                  getTerm(
                    metaParse(M', downQidList('__[TL, ''..Qid]), 
                      'PatternCondition)), 
                  QI, I, VDS)
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'match 'command. '\n
           fi
      fi 
    if T?:[Term] := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .

  eq solveBubblesMatch2(M, T, QI, QI', I, VDS)
    = procMatch2(M, T, constsToVars(QI, VDS), nil, QI', I) .
  eq solveBubblesMatch2(M, T, F[T], QI, I, VDS)
    = procMatch2(M, T, constsToVars(F[T], VDS), nil, QI, I) .
  eq solveBubblesMatch2(M, T, F[T', T''], QI, I, VDS)
    = if F == '_s.t._. or F == '_such`that_. 
      then procMatch2(M, T, T', parseCond(T'', VDS), QI, I)
      else procMatch2(M, T, constsToVars(F[T', T''], VDS), nil, QI, I)
      fi .
  eq solveBubblesMatch2(M, T, F[T', T'', TL], QI, I, VDS)
    = procMatch2(M, T, constsToVars(F[T', T'', TL], VDS), nil, QI, I) .

  ceq procMatch2(M, T, T', CD, 'match, I)
    = if Sb? :: Substitution
      then ('match 
            if I == 0 then nil else '\s '`[ qid(string(I, 10)) '`] '\s fi 
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T) '\s '<=? '\s eMetaPrettyPrint(M, T') '. '\n '\n
            'Solution '1 '\n
            if Sb? == none
            then 'empty 'substitution
            else eMetaPrettyPrint(M, Sb?)
            fi '\n '\n
            procMatch3(M, T, T', CD, 'match, I, 1))
      else if Sb? == noMatch
           then ('match 
                 if I == 0
                 then nil
                 else '\s '`[ qid(string(I, 10)) '`] '\s 
                 fi 
                 'in eMetaPrettyPrint(getName(M)) ':
                       eMetaPrettyPrint(M, T) '\s '<=? '\s 
                       eMetaPrettyPrint(M, T') '. '\n '\n
                       'No 'solution. '\n) 
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'match 'command. '\n 
           fi
      fi 
    if Sb? := metaMatch(M, T, T', CD, 0) .
  ceq procMatch2(M, T, T', CD, 'xmatch, I)
    = if MP? :: MatchPair
      then ('xmatch 
            if I == 0 then nil else '\s '`[ qid(string(I, 10)) '`] '\s fi 
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T) '\s '<=? '\s eMetaPrettyPrint(M, T') '. '\n '\n
            'Solution '1 '\n
            if gTSubstitution(MP?) == none
            then 'empty 'substitution
            else eMetaPrettyPrint(M, gTSubstitution(MP?))
            fi '\n '\n 
            procMatch3(M, T, T', CD, 'xmatch, I, 1))
      else if MP? == noMatch
           then ('xmatch 
                 if I == 0
                 then nil
                 else '\s '`[ qid(string(I, 10)) '`] '\s 
                 fi 
                 'in eMetaPrettyPrint(getName(M)) ':
                      eMetaPrettyPrint(M, T) '\s '<=? '\s 
                      eMetaPrettyPrint(M, T') '. '\n '\n
                      'No 'solution. '\n) 
           else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'xmatch 'command. '\n 
           fi
      fi 
    if MP? := metaXmatch(M, T, T', CD, 0, unbounded, 0) .

  eq procMatch3(M, T, T', CD, 'match, I, J)
    = if I == 0 or J < I 
      then if metaMatch(M, T, T', CD, J) :: Substitution
           then ('Solution qid(string(J + 1, 10)) '\n
                 if metaMatch(M, T, T', CD, J) == none
                 then 'empty 'substitution
                 else eMetaPrettyPrint(M, metaMatch(M, T, T', CD, J))
                 fi '\n '\n 
                 procMatch3(M, T, T', CD, 'match, I, J + 1))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .
  eq procMatch3(M, T, T', CD, 'xmatch, I, J)
    = if I == 0 or J < I 
      then if metaXmatch(M, T, T', CD, 0, unbounded, J) :: MatchPair
           then ('Solution qid(string(J + 1, 10)) '\n
                 if gTSubstitution(metaXmatch(M, T, T', CD, 0, unbounded, J))
                      == none
                 then 'empty 'substitution
                 else eMetaPrettyPrint(M, 
                            gTSubstitution(
                               metaXmatch(M, T, T', CD, 0, unbounded, J)))
                 fi '\n '\n 
                 procMatch3(M, T, T', CD, 'xmatch, I, J + 1))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .

  *** UNIFY 
  
  ceq procUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)
           :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)), 
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))), 
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'match 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq addInfoUnify(M) 
    = addOps(op '_/\_ : '@UnificationProblem@ '@UnificationProblem@ -> '@UnificationProblem@ 
                               [ctor assoc prec(73)] .
             op '_=?_  : 'Universal 'Universal -> '@UnificationProblem@ 
                               [ctor poly(1 2) prec(71)] .,
        addSorts('@UnificationProblem@, M)) .

  eq parseUnify('_/\_[T, T'], VDS) = parseUnify(T, VDS) /\ parseUnify(T', VDS) .
  eq parseUnify('_=?_[T, T'], VDS) = constsToVars(T, VDS) =? constsToVars(T', VDS) .

  ceq procUnify2(M, UP, D)
    = if UP? :: UnificationPair?
      then ('unify 
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi 
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, UP) '\n '\n
            if UP? == noUnifier
            then 'No 'unifier
            else procUnify3Aux(M, UP?, 0) '\n '\n
                 procUnify3(M, UP, D, 1)
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'unify 'command. '\n 
      fi 
    if UP? := metaUnify(M, UP, 0, 0) .
  eq procUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .
    
  eq eMetaPrettyPrint(M, T =? T')
    = eMetaPrettyPrint(M, T) '\s '=? '\s eMetaPrettyPrint(M, T') '. .
  eq eMetaPrettyPrint(M, T =? T' /\ UP)
    = eMetaPrettyPrint(M, T =? T') '\s '/\ '\s eMetaPrettyPrint(M, UP) '. .

  eq procUnify3Aux(M, {Sb, N}, I)
    = 'Solution qid(string(I + 1, 10)) '\n
      if Sb == none
      then 'empty 'substitution '\n '\n
      else eMetaPrettyPrint(M, Sb) '\n '\n
      fi .

  eq procUnify3(M, UP, D, I)
    = if D == unbounded or-else I < D 
      then if metaUnify(M, UP, 0, I) :: UnificationPair
           then (procUnify3Aux(M, metaUnify(M, UP, 0, I), I)
                 procUnify3(M, UP, D, I + 1))
           else ('No 'more 'solutions. '\n)
           fi
      else nil
      fi .
      
  ceq solveBubblesUnify(M, 'bubble[T], VDS)
    = if metaParse(M, QIL, '@UnificationProblem@) :: ResultPair
      then parseUnify(getTerm(metaParse(M, QIL, '@UnificationProblem@)), VDS)
      else unificationProblemError('\r 'Warning: '\o 
             printSyntaxError(metaParse(M, QIL, '@UnificationProblem@), QIL) '\n)
      fi 
    if QIL := downQidList(T) .

  eq solveBubblesRewUnify('bubble[QI], M, B, D, VDS, DB) 
    = if solveBubbles('bubble[QI], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble[QI], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else tupleTMBOBDerror(
             '\r 'Error: '\o 'no 'parsing 'for downQidList(QI) '\n)
      fi .
  eq solveBubblesRewUnify('bubble['__[TL]], M, B, D, VDS, DB) 
    = if solveBubbles('bubble['__[TL]], M, B, VDS, DB) :: Term
      then {solveBubbles('bubble['__[TL]], M, B, VDS, DB), M, B, VDS, unbounded, DB}
      else if metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), '@RewNuPart@)
                :: ResultPair
           then solveBubblesRewUnify2(
                  getTerm(
                    metaParse(GRAMMAR-REW, downQidList('__[TL, ''..Qid]), 
                      '@RewNuPart@)), 
                  M, B, VDS, DB) 
           else {getTerm(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)), 
                 getModule(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)), 
                 getBool(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)), 
                 getVars(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB)),
                 unbounded, 
                 getDatabase(solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB))}
           fi
      fi .

  eq solveBubblesRewUnify2('`[_`]_.['token[T], T'], M, B, VDS, DB) 
    = if downNat(downMetaNat(T)) :: Nat
         and-then solveBubblesRedUnify(T', M, B, VDS, DB) 
                    :: Tuple{Term,Module,Bool,OpDeclSet,Database}
      then {getTerm(solveBubblesRedUnify(T', M, B, VDS, DB)), 
            getModule(solveBubblesRedUnify(T', M, B, VDS, DB)),
            getBool(solveBubblesRedUnify(T', M, B, VDS, DB)),
            getVars(solveBubblesRedUnify(T', M, B, VDS, DB)),
            downNat(downMetaNat(T)),
            getDatabase(solveBubblesRedUnify(T', M, B, VDS, DB))}
      else tupleTMBOBDerror('\r 'Error: '\o 'Incorrect 'command. '\n)
      fi .

  ceq solveBubblesRedUnify('bubble[QI], M, B, VDS, DB) 
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else tupleTMBODerror('\r 'Error: '\o 'no 'parse 'for downQidList(QI) '\n)
      fi 
    if T? := solveBubbles('bubble[QI], M, B, VDS, DB) .
  ceq solveBubblesRedUnify('bubble['__[TL]], M, B, VDS, DB) 
    = if T? :: Term
      then {T?, M, B, VDS, DB}
      else if metaParse(GRAMMAR-RED, 
                downQidList('__[TL, ''..Qid]), '@RedInPart@)
                :: ResultPair
           then solveBubblesRedUnify2(
                  getTerm(
                    metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), '@RedInPart@)), 
                  DB) 
           else tupleTMBODerror('\r 'Warning: '\o 
                      printSyntaxError(
                        metaParse(GRAMMAR-RED, downQidList('__[TL, ''..Qid]), 
                        '@RedInPart@), downQidList('__[TL, ''..Qid])) '\n
                      '\r 'Error: '\o 
                      'no 'parse 'for downQidList('__[TL, ''..Qid]) '\n)
           fi
      fi 
    if T? := solveBubbles('bubble['__[TL]], M, B, VDS, DB) .
  *** There is some problem parsing 'in_:_ in solveBubblesRed, but it 
  *** seems to work with the additional '.

  ceq solveBubblesRedUnify2('in_:_.[T, T'], DB) 
    = if unitInDb(ME, DB')
      then solveBubblesRed3(T', addInfoUnify(getFlatModule(ME, DB')), ME, getVars(ME, DB'), DB')
      else tupleTMBODerror('\r 'Error: '\o 'The 'module eMetaPrettyPrint(ME) 'is 'not 'in 'the 'database '. '\n)
      fi 
    if < DB' ; ME > := evalModExp(parseModExp(T), DB) .
  eq solveBubblesRedUnify2('in_:_.[T, T'], DB) 
    = tupleTMBODerror('\r 'Error: '\o 'It 'isn't 'possible 'to 'compile eMetaPrettyPrint(parseModExp(T)) '. '\n)
    [owise] .

  *** ID-UNIFY 
  
  ceq procIdUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procIdUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)), 
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))), 
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'id-unify 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ceq procIdUnify2(M, T =? T', D)
    = if X:[SubstitutionSet] :: SubstitutionSet
      then ('id-unify 
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi 
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T =? T')
            if X:[SubstitutionSet] == empty
            then '\n 'No 'unifier
            else procIdUnify3(M, T =? T', 0, X:[SubstitutionSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'id-unify 'command. '\n 
      fi 
    if X:[SubstitutionSet] := metaACUUnify(M, T, T') .
  eq procIdUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .
    
  eq procIdUnify3(M, UP, I, empty)
   = ('\n '\n 'No 'more 'solutions. '\n) .
  eq procIdUnify3(M, UP, I, S:Substitution | SS:SubstitutionSet)
   = '\n '\n 'Solution qid(string(I + 1, 10))
      if S:Substitution == none
      then '\n 'empty 'substitution
      else '\n eMetaPrettyPrint(M, S:Substitution)
      fi
     procIdUnify3(M, UP, I + 1, SS:SubstitutionSet) .
      
  *** VARIANT-UNIFY 
  
  ceq procVariantUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procVariantUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)), 
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))), 
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'variant 'unify 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ceq procVariantUnify2(M, T =? T', D)
    = if X:[SubstitutionSet] :: SubstitutionSet
      then ('variant 'unify 
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi 
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T =? T')
            if X:[SubstitutionSet] == empty
            then '\n 'No 'variant 'unifier
            else procVariantUnify3(M, T =? T', 0, X:[SubstitutionSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'variant 'unify 'command. '\n 
      fi 
    if X:[SubstitutionSet] 
       := toSubstitution(
            metaVariantUnify(
               removeIds(axCohComplete(M), non-handled),
               T,
               T',
               highestVar((T,T')) + 1,
               minimal-unifiers reducible
            )
          ) .
  eq procVariantUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .
    
  eq procVariantUnify3(M, UP, I, empty)
   = ('\n '\n 'No 'more 'solutions. '\n) .
  eq procVariantUnify3(M, UP, I, S:Substitution | SS:SubstitutionSet)
   = '\n '\n 'Solution qid(string(I + 1, 10))
      if S:Substitution == none
      then '\n 'empty 'substitution
      else '\n eMetaPrettyPrint(M, S:Substitution)
      fi
     procVariantUnify3(M, UP, I + 1, SS:SubstitutionSet) .

  *** ASYMMETRIC-VARIANT-UNIFY 
  
  ceq procAsymmetricVariantUnify(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procAsymmetricVariantUnify2(
             getModule(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)),
             parseUnify(
               getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)), 
               getVars(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB))), 
             getBound(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, addInfoUnify(M), B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'asymmetric 'variant 'unify 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  ---op axCohComplete : SModule -> SModule . --- Defined later in module AX-COHERENCE-COMPLETION
  ---op removeIds : Module ~> Module . ---Defined later in module VARIANTS

  ceq procAsymmetricVariantUnify2(M, T =? T', D)
    = if X:[SubstitutionSet] :: SubstitutionSet
      then ('variant 'unify 
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi 
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T =? T')
            if X:[SubstitutionSet] == empty
            then '\n 'No 'asymmetric 'unifier
            else procAsymmetricVariantUnify3(M, T =? T', 0, X:[SubstitutionSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'asymmetric 'variant 'unify 'command. '\n 
      fi 
    if X:[SubstitutionSet] 
       := toSubstitution(
            metaVariantUnify(
               removeIds(axCohComplete(M), non-handled),
               T,
               T',
               highestVar((T,T')) + 1,
               minimal-unifiers irreducible
            )
          ) .
  eq procAsymmetricVariantUnify2(M?, UP??:[UnificationProblem], D?) = getMsg(M?) [owise] .
    
  eq procAsymmetricVariantUnify3(M, UP, I, empty)
   = ('\n '\n 'No 'more 'solutions. '\n) .
  eq procAsymmetricVariantUnify3(M, UP, I, S:Substitution | SS:SubstitutionSet)
   = '\n '\n 'Solution qid(string(I + 1, 10))
      if S:Substitution == none
      then '\n 'empty 'substitution
      else '\n eMetaPrettyPrint(M, S:Substitution)
      fi
     procAsymmetricVariantUnify3(M, UP, I + 1, SS:SubstitutionSet) .

  *** GET-VARIANTS 

  ceq procGetVariants(ME, M, T, D, VDS, DB)
    *** D is a bound on the number of solutions
    = if solveBubblesRewUnify(T, M, B, D, VDS, DB) :: Tuple{Term,Module,Bool,OpDeclSet,Bound,Database}
      then procGetVariants2(
             getModule(solveBubblesRewUnify(T, M, B, D, VDS, DB)),
             parseGetVariants(
               getTerm(solveBubblesRewUnify(T, M, B, D, VDS, DB)), 
               getVars(solveBubblesRewUnify(T, M, B, D, VDS, DB))), 
             getBound(solveBubblesRewUnify(T, M, B, D, VDS, DB)))
      else getMsg(getTerm(solveBubblesRewUnify(T, M, B, D, VDS, DB)))
                ----('\r 'Error: '\o 'Incorrect 'get 'variants 'command. '\n)
      fi
    if B := included('META-MODULE, getImports(getTopModule(ME, DB)), DB) .

  eq parseGetVariants(T, VDS) = constsToVars(T, VDS) .

  ceq procGetVariants2(M, T, D)
    = if X:[VariantFourSet] :: VariantFourSet
      then ('get 'variants 
            if D == unbounded then nil else '\s '`[ qid(string(D, 10)) '`] '\s fi 
            'in eMetaPrettyPrint(getName(M)) ':
            eMetaPrettyPrint(M, T)
            if X:[VariantFourSet] == empty
            then '\n 'No 'variant
            else procGetVariants3(M, T, 0, X:[VariantFourSet])
            fi)
      else '\r 'Error: '\o 'Incorrect 'use 'of 'the 'get 'variants 'command. '\n 
      fi 
    if X:[VariantFourSet] 
         := getVariants(
              removeIds(axCohComplete(M), non-handled),
              T,
              highestVar(T) + 1,
              ACUUnify irreducible minimal-unifiers
            ) .
  eq procGetVariants2(M?, UP??:[Term], D?) = getMsg(M?) [owise] .
    
  eq procGetVariants3(M, T, I, (empty).VariantFourSet)
   = ('\n '\n 'No 'more 'variants. '\n) .
  eq procGetVariants3(M, T, I, {T1:Term,S:Substitution,S*:Substitution,NextVar:Nat} | VS:VariantFourSet)
   = '\n '\n 'Variant qid(string(I + 1, 10))
      '\n 
      '`{ 
      eMetaPrettyPrint(M, T1:Term) '`, 
      if S:Substitution == none
      then 'empty 'substitution
      else eMetaPrettyPrint(M, S:Substitution)
      fi
      '`}
     procGetVariants3(M, T, I + 1, VS:VariantFourSet) .
endfm

----load check-input-module.maude

---- Input modules are assumed not to have:
---- - idem
---- - assoc without comm
---- - variable alone in lhs
---- - owise
---- - iter
---- - built-ins
---- - something else? 

fmod CHECK-INPUT-MODULE is
  inc EXT-TERM .
  inc MODULE-HANDLING  * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .
  inc COMMAND-PROCESSING .
  
  op checkModule : Module -> Bool .
  op attr : OpDeclSet Attr -> Bool .
  ops assocWithoutComm specialAttr : OpDeclSet -> Bool .
  op nonValidAttrs : OpDeclSet AttrSet -> Bool .
  op singleVbleInLHSs : RuleSet -> Bool .
  op singleVbleInLHSs : EquationSet -> Bool .
  
  var  M : Module .
  var  F : Qid .
  var  TpL : TypeList .
  vars Tp Tp' Tp'' Tp''' : Type .
  var  TpS : TypeSet .
  var  At : Attr .
  vars AtS AtS' : AttrSet .
  vars ODS ODS' : OpDeclSet .
  var  V : Variable .
  var  VS : QidSet .
  var  RlS : RuleSet .
  var  EqS : EquationSet .
  vars T LHS RHS : Term .
  var  Cond : Condition .
  
  eq attr(op F : TpL -> Tp [owise AtS] . ODS, At AtS) = true .
  eq attr(op F : TpL -> Tp [idem AtS] . ODS, idem) = true .
  eq attr(op F : TpL -> Tp [iter AtS] . ODS, iter) = true .
  eq attr(ODS, At) = false [owise] .
  
  eq nonValidAttrs(op F : TpL -> Tp [At AtS] . ODS, At AtS') = true .
  eq nonValidAttrs(ODS, AtS) = false [owise] .
  
  ---- special attributes only allowed for constants
  eq specialAttr(op F : TpL -> Tp [special(NEHL:NeHookList) AtS] . ODS) = TpL =/= nil .
  eq specialAttr(ODS) = false [owise] .
  
  eq assocWithoutComm(op F : TpL -> Tp [assoc AtS] . ODS) 
    = (not comm in AtS) or-else assocWithoutComm(ODS) .
  eq assocWithoutComm(ODS) = false [owise] .
  
  eq singleVbleInLHSs(rl V => RHS [AtS] . RlS) = true .
  eq singleVbleInLHSs(crl V => RHS if Cond [AtS] . RlS) = true .
  eq singleVbleInLHSs(RlS) = false [owise] .

  eq singleVbleInLHSs(eq V = RHS [AtS] . EqS) = true .
  eq singleVbleInLHSs(ceq V = RHS if Cond [AtS] . EqS) = true .
  eq singleVbleInLHSs(EqS) = false [owise] .
  
  op isRegular : EquationSet -> Bool .
  op isRegular : RuleSet -> Bool .
  eq isRegular(eq LHS = RHS [AtS] . EqS) = (vars(LHS) == vars(RHS)) and isRegular(EqS) .
  eq isRegular(ceq LHS = RHS if Cond [AtS] . EqS) = (vars(LHS) == vars(RHS)) and isRegular(EqS) .
  eq isRegular(rl LHS => RHS [AtS] . RlS) = (vars(LHS) == vars(RHS)) and isRegular(RlS) .
  eq isRegular(crl LHS => RHS if Cond [AtS] . RlS) = (vars(LHS) == vars(RHS)) and isRegular(RlS) .

  ---- We say that a term l is linear iff all its variables appear only once in it. 
  
  op linear : Term -> Bool .
  eq linear(T) = | vars(T) | == size(varlist(T)) .

  ---- We say that a term l is C-nonlinear iff all its variables are c-nonlinear. 
  ---- A variable x : s in vars(l) is c-nonlinear if it is nonlinear in l and
  ---- there is a \Sigma-subterm t with ls[t]_B <= s with a position p such that 
  ---- t|_p = f(u,v) with B_f = {C_f}. 
  
  op c-nonlinear : Qid Term Module -> Bool . ---- the variable (1st arg.) is c-linear in the term (2nd arg.)  
  op c-nonlinear : Term Module -> Bool . ---- no repeated variables and all such varaibles are c-linear 
  op c-nonlinearAux : QidSet Module -> Bool .
  op c-nonlinearAux : Type Module -> Bool .
  op c-nonlinearAux : Type TypeSet OpDeclSet OpDeclSet Module -> Bool .
  op c-nonlinearAux2 : TypeList TypeSet OpDeclSet Module -> Bool .
  
  eq c-nonlinear(V, T, M) = occurrences(V, T) > 1 and-then c-nonlinearAux(V, M) .
  
  eq c-nonlinear(T, M) = not linear(T) and-then c-nonlinearAux(vars(T), M) .
  
  eq c-nonlinearAux(V ; VS, M) = c-nonlinearAux(getType(V), M) or-else c-nonlinearAux(VS, M) .
  eq c-nonlinearAux(none, M) = false .
  
  eq c-nonlinearAux(Tp, M) = c-nonlinearAux(Tp, Tp, getOps(M), getOps(M), M) .
  
  ceq c-nonlinearAux(Tp, TpS, op F : Tp' Tp'' -> Tp''' [comm AtS] . ODS, ODS', M)
    = true 
    if sortLeq(M, Tp''', Tp) .  
  eq c-nonlinearAux(Tp, TpS, op F : TpL -> Tp' [AtS] . ODS, ODS', M)  
    = if not comm in AtS and-then (not Tp in TpS and-then sortLeq(M, Tp', Tp)) 
      then c-nonlinearAux2(TpL, TpS, ODS', M) ---- all the sorts in that declarations have already been checked
      else c-nonlinearAux(Tp, TpS, ODS, ODS', M)
      fi
    [owise] .
  eq c-nonlinearAux(Tp, TpS, none, ODS, M)  
    = false .
     
  eq c-nonlinearAux2(Tp TpL, TpS, ODS, M)
    = if Tp in TpS 
      then false
      else c-nonlinearAux(Tp, Tp ; TpS, ODS, ODS, M)
      fi 
      or-else c-nonlinearAux2(TpL, TpS, ODS, M) .
  eq c-nonlinearAux2(nil, TpS, ODS, M) = false .
  
---(
  eq c-permute(C, M) = C .
  eq c-permute(V, M) = V .
  ceq c-permute(F[T, T'], M) 
    = c-combine(F, c-permute((T, T'), M)) # c-combine(F, c-permute((T', T), M))
    if isCommutative(M, F, getTypes(M, (T, T'))) .
  eq c-permute(F[TL], M) 
    = c-combine(F, c-permute(TL, M))
    [owise] .
    
  eq c-permute((T, T'), M) 
    = c-permute(T, M) .
---)
endfm

--------------------------------------------------------------------------------

view SubstitutionSet from TRIV to SUBSTITUTIONSET is
  sort Elt to SubstitutionSet .
endv

fmod MODULE-VARIANTS is 
  inc CHECK-INPUT-MODULE .
  inc META-NARROWING-SEARCH * (op addOps to addOpsSE, op addEqs to addEqsSE, op addSorts to addSortsSE) .
  inc UNIT .
  pr 2TUPLE{SubstitutionSet, Nat} 
      * (op `(_`,_`) : SubstitutionSet Nat -> Tuple{SubstitutionSet, Nat} to <_;_>, 
         op p1_ : Tuple{SubstitutionSet, Nat} -> SubstitutionSet to getSubst, 
         op p2_ : Tuple{SubstitutionSet, Nat} -> Nat to getIndex) .
  pr CONVERSION .
  pr EXT-TERM .
  pr EXT-DECL .
  pr 2TUPLE{Module,Module}
      * (op `(_`,_`) : Module Module -> Tuple{Module, Module} to <_;_>) .
  
  vars V W : Variable .
  var  C : Constant .
  vars M M' M'' : Module .
  var  N : Nat .
  vars T T' T'' LHS RHS : Term .
  var  F : Qid .
  var  TL : TermList .
  var  AtS : AttrSet .
  var  VFS : VariantFourSet .
  var  VtS : VariantTripleSet .
  vars Tp Tp' Tp'' : Type .
  var  TpL : TypeList .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  Eq : Equation .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  Cond : Condition .
  var  S : Sort .
  var  VS : QidSet .
  vars Subst Subst' : Substitution .
  vars SubstS SubstS' : SubstitutionSet .
  var  H : Header .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  vars OPDS OPDS' : OpDeclSet .
  var  MAS : MembAxSet .
  var  IL : ImportList .

  ------------------------------------------------------------------------------
  ---- Given a module \mathcal{R} = (\Sigma, E, R) 
  ---- removeIds(\mathcal{R}) = removeIds((\widehat{\Sigma}, B, \widetilde{U}), R)
  ---- where 
  ---- - \widehat{\Sigma} is obtained by 
  ----   - adding to $\Sigma$ a fresh new sort [Tuple] and 
  ----   - a tupling operator <_,...,_> : [s] [s_1] ... [s_n] -> [Tuple]
  ----     for each rule l -> r if u_1 -> v_1 /\ ... /\ u_n -> v_n in R, 
  ----     where l has sort s and v_i has sort s_i, 1 <= i <= n,
  ---- - B_f = E_f \cap {A_f, C_f} 
  ---- - U_f = E_f \cap {LU_f, RU_f}, 
  ----   with LU_f and RU_f rewrite rules f(e,x) -> x and f(x,e) -> x, and 
  ----   where \widetilde{U} is the B-coherence completion of U, 
  ----   which is described as \widetilde{U} = \bigcup_{f:[s_1]...[s_n] -> [s] \in \Sigma} \widetilde{U}_f.
  ----   If A_f \not \in B_f, or A_f, C_f \in B_f, then \widetilde{U}_f = U_f.
  ----   Otherwise, if A_f \in B_f, but C_f \not \in B_f, then, 
  ----     if LU_f \in U_f, then we add the rule f(x,f(e,y)) -> f(x,y) and 
  ----     if RU_f \in U_f, then we add the rule f(f(x,e'),y) -> f(x,y).
  ---- makeIdsModule computes (\widehat{\Sigma}, B, \widetilde{U})
  ------------------------------------------------------------------------------
  
  sort VariantProcedure .
  ops narrowing ad-hoc built-in : -> VariantProcedure .
  var VP : VariantProcedure .
----  sort IdsToRemove .                             ---- moved to COMMAND-PROCESSING
----  ops all non-handled : -> IdsToRemove .         ---- moved to COMMAND-PROCESSING
  var Which : IdsToRemove .  
  
  op removeIds : Module IdsToRemove ~> Module .  ---- moved to COMMAND-PROCESSING
  ---- given a module returns an equivalent module without ids but with variants of eqs and rls
  ---- the second argument may be either all (all id attributes are removed) or non-handled (only those not directly handled by Maude's unification are removed)
  op removeIds : Module IdsToRemove VariantProcedure ~> Module . 
  ---- given a module returns an equivalent module without ids but with variants 
  ---- of eqs and rls using the specified procedure for calculating variants
  op getVariants : Module Module RuleSet VariantProcedure -> RuleSet .
  ---- given a (\widehat{\Sigma}, B, \widetilde{U}) returns the variants of the given set of rules
  ---- It takes the modules without and with ids. The module with id attributes is used to normalize.
  op getVariants : Module Module EquationSet VariantProcedure -> EquationSet .
  ---- given a (\widehat{\Sigma}, B, \widetilde{U}) returns the variants of the given set of equations
  ---- It takes the modules without and with ids. The module with id attributes is used to normalize.
  op getVariants# : Module Module Term VariantProcedure -> VariantTripleSet .
  ---- given a (\widehat{\Sigma}, B, \widetilde{U}) returns the variants of a term (a tuple)
  op getRlVariants : Module VariantTripleSet Term Condition AttrSet -> RuleSet .
  ---- given the variants of a tuple < LHS, target terms in condition >, a RHS, a condition, and an attribute set,
  ---- it constructs the corresponding variant rules
  op getEqVariants : Module VariantTripleSet Term Condition AttrSet -> EquationSet .
  ---- given the variants of a tuple < LHS, target terms in condition >, a RHS, a condition, and an attribute set,
  ---- it constructs the corresponding variant equations
  
  eq removeIds(M, Which) ---- Which may be either all or non-handled 
    = if nonValidAttrs(getOps(M), owise idem iter)
      then unitError('The 'module 'uses 'non-supported 'attributes '`(owise`, 'idem`, 'or 'iter '`). '\n)
      else if singleVbleInLHSs(getRls(M))
           then unitError('The 'module 'contains 'rules 'with 'single 'variables 'in 'their 'left-hand 'sides. '\n)
           else if singleVbleInLHSs(getEqs(M))
                then unitError('The 'module 'contains 'equations 'with 'single 'variables 'in 'their 'left-hand 'sides. '\n)
                else if assocWithoutComm(getOps(M))
                     then moreGeneralEqs(moreGeneralRls(removeIds(M, Which, ad-hoc))) 
                     else moreGeneralEqs(moreGeneralRls(removeIds(M, Which, narrowing))) ---- built-in
                     fi 
                fi
           fi
      fi .
  
  eq removeIds(M, Which, VP) 
    ---- the narrowing based getVariant function requires a module with id attributes turned into eqs 
    ---- and sort Tuple and tuple operators in; the ad-hoc getVariant (FroCos th 2) only needs the 
    ---- tuple declarations.
    = setRls(
        addEqs(
          getVariants(makeIdsTuplingModule(M, Which), addTupling(M, M), getEqs(M), VP),
          makeIdsModule(M, Which)),
        getVariants(makeIdsTuplingModule(M, Which), addTupling(M, M), getRls(M), VP)) .
  
  eq getVariants(M, M', Rl RlS, VP) 
    = getRlVariants(M', getVariants#(M, M', makeTuple(lhs(Rl), cond(Rl)), VP), rhs(Rl), cond(Rl), atts(Rl)) 
      getVariants(M, M', RlS, VP) .
  eq getVariants(M, M', (none).RuleSet, VP) = none .
    
  eq getVariants(M, M', Eq EqS, VP) 
    = getEqVariants(M', getVariants#(M, M', makeTuple(lhs(Eq), cond(Eq)), VP), rhs(Eq), cond(Eq), atts(Eq)) 
      getVariants(M, M', EqS, VP) .
  eq getVariants(M, M', (none).EquationSet, VP) = none .
    
  eq getVariants#(M, M', T, narrowing) = makeVariantSet(getVariants(M, T, 1, irreducible ACUUnify minimal-unifiers)) .
  
  op makeVariantSet : VariantFourSet -> VariantTripleSet .
  eq makeVariantSet({T, Subst, Subst', N} | VFS) = {T, Subst, N} | makeVariantSet(VFS) .
  eq makeVariantSet(empty) = empty .
  
---- PD: pre alpha96
----  eq getVariants#(M, M', T, built-in) = getVariants#(M, T, 0) .
----
----  op getVariants# : Module Term Nat -> VariantTripleSet .  
----  eq getVariants#(M, T, N) 
----    = if metaGenerateVariant(M, T, 0, N) == noVariant
----      then empty
----      else metaGenerateVariant(M, T, 0, N), getVariants#(M, T, s N)
----      fi .
  
  eq getRlVariants(M, ({'@<@_@>@[T], Subst, N} | VtS), T', nil, AtS)
    = (rl getTerm(metaNormalize(M, T)) => getTerm(metaNormalize(M, _<<_(T', Subst))) [AtS] .)
      getRlVariants(M, VtS, T', nil, AtS) .
  eq getRlVariants(M, ({F[T, TL], Subst,N} | VtS), T', Cond, AtS)
    = (crl getTerm(metaNormalize(M, T)) => getTerm(metaNormalize(M, _<<_(T', Subst))) if makeCond(TL, Cond, Subst) [AtS] .)
      getRlVariants(M, VtS, T', Cond, AtS) .
  eq getRlVariants(M, empty, T', Cond, AtS) = none .

  eq getEqVariants(M, ({'@<@_@>@[T], Subst, N} | VtS), T', nil, AtS)
    = (eq getTerm(metaNormalize(M, T)) = getTerm(metaNormalize(M, _<<_(T', Subst))) [AtS] .)
      getEqVariants(M, VtS, T', nil, AtS) .
  eq getEqVariants(M, ({F[T, TL], Subst, N} | VtS), T', Cond, AtS)
    = (ceq getTerm(metaNormalize(M, T)) = getTerm(metaNormalize(M, _<<_(T', Subst))) if makeCond(TL, Cond, Subst) [AtS] .)
      getEqVariants(M, VtS, T', Cond, AtS) .
  eq getEqVariants(M, empty, T', Cond, AtS) = none .

  ------------------------------------------------------------------------------

  op makeTuple : Term Condition -> Term .
  op tupleTermList : Condition -> TermList .
  eq makeTuple(T, Cond) 
    = if Cond == nil
      then qid("@<@_@>@")[T]
      else qid("@<@_" + tupleId(Cond) + "@>@")[T, tupleTermList(Cond)]
      fi .
  eq tupleTermList(T' => T'' /\ Cond) = (T'', tupleTermList(Cond)) . 
  eq tupleTermList(T' = T'' /\ Cond) = tupleTermList(Cond) . 
  eq tupleTermList(T' : S /\ Cond) = tupleTermList(Cond) . 
  eq tupleTermList(T' := T'' /\ Cond) = (T', tupleTermList(Cond)) . 
  eq tupleTermList(nil) = empty .

  op makeCond : TermList Condition Substitution -> Condition .
  eq makeCond((T, TL), T' => T'' /\ Cond, Subst)
    = (T' << Subst) => T /\ makeCond(TL, Cond, Subst) .
  eq makeCond((T, TL), T' := T'' /\ Cond, Subst)
    = T := (T'' << Subst) /\ makeCond(TL, Cond, Subst) .
  eq makeCond(TL, T' = T'' /\ Cond, Subst)
    = (T' << Subst) = (T'' << Subst) /\ makeCond(TL, Cond, Subst) .
  eq makeCond(TL, T' : S /\ Cond, Subst)
    = (T' << Subst) : S /\ makeCond(TL, Cond, Subst) .
  eq makeCond(empty, nil, Subst) = nil .
    
  ------------------------------------------------------------------------------
  ---- makeIdsTuplingModule((\Sigma, E, R)) computes (\widehat{\Sigma}, B, \widetilde{U})
  ------------------------------------------------------------------------------
  op makeIdsTuplingModule : Module IdsToRemove -> Module .
  op makeIdsModule : Module IdsToRemove -> Module .
  op addTupling : Module Module -> Module . 
  ---- addTupling is called after makeIdsModule, which removes the eqs in it
  ---- the first module is the oiginal one, with the original eqs and rls
  
  eq makeIdsTuplingModule(M, Which) = addTupling(M, makeIdsModule(M, Which)) .
  
  eq makeIdsModule(M, Which) 
    = setEqs(
        setOps(
          setRls(M, none),
          removeIds(getOps(M), Which)),
        idEqs(M, getOps(M), Which)) .
  
  eq addTupling(M, M') 
    = addOps(
        tuplingOps(M, getEqs(M), getRls(M)),
        addSorts('Tuple, M')) .
  
  op idEqs : Module OpDeclSet IdsToRemove -> EquationSet .
  ---- the 3rd arguments indicates whether all the id attributes are to be removed (all), or only those not handled by the Maude unification algorithm (non-handled)
  eq idEqs(M, op F : Tp Tp' -> Tp'' [left-id(T) AtS] . ODS, Which)
    = (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('lIdEq1) 
      if assoc in AtS and not comm in AtS 
      then (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), F[T, qid("Y:" + string(type2qid(getKind(M, Tp))))]] 
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))] 
              [variant] .) ---- label('lIdEq2) 
      else none 
      fi
      idEqs(M, ODS, Which) . 
  eq idEqs(M, op F : Tp Tp' -> Tp'' [right-id(T) AtS] . ODS, Which)
    = (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), T] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('rIdEq1) 
      if assoc in AtS and not comm in AtS 
      then (eq F[F[qid("X:" + string(type2qid(getKind(M, Tp)))), T], qid("Y:" + string(type2qid(getKind(M, Tp))))] 
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))] 
              [variant] .) ---- label('rIdEq2) 
      else none 
      fi
      idEqs(M, ODS, Which) . 
  eq idEqs(M, op F : Tp Tp' -> Tp'' [id(T) AtS] . ODS, all)
    = if comm in AtS
      then (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq1) 
      else (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), T] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq2) 
           (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq3) 
      fi 
      if assoc in AtS and not comm in AtS 
      then (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), F[T, qid("Y:" + string(type2qid(getKind(M, Tp))))]] 
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))] 
              [variant] .)
           (eq F[F[qid("X:" + string(type2qid(getKind(M, Tp)))), T], qid("Y:" + string(type2qid(getKind(M, Tp))))] 
              = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))] 
              [variant] .)
      else none 
      fi
      idEqs(M, ODS, all) . 
  eq idEqs(M, op F : Tp Tp' -> Tp'' [id(T) AtS] . ODS, non-handled)
    ---- modified on Jan 13th, 2011
    ---- The ACU case is now handled, the id attributes are left if also AC
    = if assoc in AtS and comm in AtS 
      then none 
      else if comm in AtS
           then (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq1) 
           else (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), T] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq2) 
                (eq F[T, qid("X:" + string(type2qid(getKind(M, Tp))))] = qid("X:" + string(type2qid(getKind(M, Tp)))) [variant] .) ---- label('idEq3) 
           fi 
           if assoc in AtS and not comm in AtS 
           then (eq F[qid("X:" + string(type2qid(getKind(M, Tp)))), F[T, qid("Y:" + string(type2qid(getKind(M, Tp))))]] 
                   = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))] 
                   [variant] .)
                (eq F[F[qid("X:" + string(type2qid(getKind(M, Tp)))), T], qid("Y:" + string(type2qid(getKind(M, Tp))))] 
                   = F[qid("X:" + string(type2qid(getKind(M, Tp)))), qid("Y:" + string(type2qid(getKind(M, Tp))))] 
                   [variant] .)
           else none 
           fi
      fi
      idEqs(M, ODS, non-handled) . 
  eq idEqs(M, ODS, Which) = none [owise] . 

  op removeIds : OpDeclSet IdsToRemove -> OpDeclSet .
  eq removeIds(op F : TpL -> Tp [id(T) AtS] . ODS, all)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, all) .
 ceq removeIds(op F : TpL -> Tp [id(T) AtS] . ODS, non-handled)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, non-handled) 
    if not (assoc in AtS and comm in AtS) .
  eq removeIds(op F : TpL -> Tp [left-id(T) AtS] . ODS, Which)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, Which) .
  eq removeIds(op F : TpL -> Tp [right-id(T) AtS] . ODS, Which)
    = removeIds(op F : TpL -> Tp [AtS] . ODS, Which) .
  eq removeIds(ODS, Which) = ODS [owise] .
  
  op tuplingOps : Module EquationSet RuleSet -> OpDeclSet .
  op tuplingOps : Module EquationSet -> OpDeclSet .
  op tuplingOps : Module RuleSet -> OpDeclSet .
  eq tuplingOps(M, EqS, RlS) = tuplingOps(M, EqS) tuplingOps(M, RlS) .
  eq tuplingOps(M, eq LHS = RHS [AtS] . EqS)
    = (op qid("@<@_@>@") : getKind(M, leastSort(M, LHS)) -> '`[Tuple`] [none] .)
      tuplingOps(M, EqS) .
  eq tuplingOps(M, ceq LHS = RHS if Cond [AtS] . EqS)
    = (op qid("@<@_" + tupleId(Cond) + "@>@") : getKind(M, leastSort(M, LHS)) arityCond(M, Cond) -> '`[Tuple`] [none] .)
      tuplingOps(M, EqS) .
  eq tuplingOps(M, (none).EquationSet) = none .
  eq tuplingOps(M, rl LHS => RHS [AtS] . RlS)
    = (op qid("@<@_@>@") : getKind(M, leastSort(M, LHS)) -> '`[Tuple`] [none] .)
      tuplingOps(M, RlS) .
  eq tuplingOps(M, crl LHS => RHS if Cond [AtS] . RlS)
    = (op qid("@<@_" + tupleId(Cond) + "@>@") : getKind(M, leastSort(M, LHS)) arityCond(M, Cond) -> '`[Tuple`] [none] .)
      tuplingOps(M, RlS) .
  eq tuplingOps(M, (none).RuleSet) = none .
  
  op arityCond : Module Condition -> TypeList .
  eq arityCond(M, T => T' /\ Cond) = getKind(M, leastSort(M, T')) arityCond(M, Cond) .
  eq arityCond(M, T := T' /\ Cond) = getKind(M, leastSort(M, T)) arityCond(M, Cond) .
  eq arityCond(M, T = T' /\ Cond) = arityCond(M, Cond) .
  eq arityCond(M, T : S /\ Cond) = arityCond(M, Cond) .
  eq arityCond(M, nil) = nil .
  
  op tupleId : Condition -> String .
  eq tupleId(T => T' /\ Cond) = ",_" + tupleId(Cond) .
  eq tupleId(T := T' /\ Cond) = ",_" + tupleId(Cond) .
  eq tupleId(T = T' /\ Cond) = tupleId(Cond) .
  eq tupleId(T : S /\ Cond) = tupleId(Cond) .
  eq tupleId(Cond) = "" .

  ------------------------------------------------------------------------------
  ---- See Th. 2, FroCos'09
  ---- TO DO: it doesn't give the minimal set of variants
  
  op getVariants : Module Term SubstitutionSet -> VariantTripleSet .
  op getSubstitutions : Module QidSet OpDeclSet Nat -> Tuple{SubstitutionSet,Nat} .
  op getSubstitutions1 : Module Variable OpDeclSet Nat -> Tuple{SubstitutionSet,Nat} .
  op combineSubsts : SubstitutionSet SubstitutionSet -> SubstitutionSet .
  
  eq getVariants#(M, M', T, ad-hoc) 
    = getVariants(M', T, getSubst(getSubstitutions(M', vars(T), getOps(M'), 0))) .

  eq getVariants(M, T, Subst | SubstS)
    = {getTerm(metaNormalize(M, T << Subst)), Subst, 0} | getVariants(M, T, SubstS) .
  eq getVariants(M, T, empty) = {T, none, 0} .
  
  eq getSubstitutions(M, V ; VS, ODS, N)
    = < combineSubsts(
          getSubst(getSubstitutions1(M, V, ODS, N)), 
          getSubst(getSubstitutions(M, VS, ODS, getIndex(getSubstitutions1(M, V, ODS, N))))) ;
        getIndex(getSubstitutions(M, VS, ODS, getIndex(getSubstitutions1(M, V, ODS, N)))) > .
  eq getSubstitutions(M, none, ODS, N) = < empty ; N > .
    
  eq combineSubsts(Subst | SubstS, Subst' | SubstS')  
    = (Subst ; Subst') | combineSubsts(SubstS, Subst' | SubstS') | combineSubsts(Subst, SubstS') .
  eq combineSubsts(SubstS, empty) = SubstS .  
  eq combineSubsts(empty, SubstS) = SubstS .  
  
  ceq getSubstitutions1(M, V, op F : TpL -> Tp [id(T) AtS] . ODS, N) 
    = < (V <- T) |
        if (assoc in AtS and-then not comm in AtS)
           and-then sortLeq(M, leastSort(M, F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]), getType(V))
        then (V <- (F[qid("X@" + string(N, 10) + ":" + string(Tp)), T])) 
           | (V <- (F[T, qid("X@" + string(s N, 10) + ":" + string(Tp))]))
        else empty
        fi |
        getSubst(getSubstitutions1(M, V, ODS, s s N)) ;
        getIndex(getSubstitutions1(M, V, ODS, s s N)) > 
    if sortLeq(M, leastSort(M, T), getType(V)) . ----  ls[e] <= s ls[f(y,e)] <= s
  ceq getSubstitutions1(M, V, op F : TpL -> Tp [right-id(T) AtS] . ODS, N) 
    = < (V <- T) |
        if (assoc in AtS and-then not comm in AtS)
           and-then sortLeq(M, leastSort(M, F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]), getType(V))
        then (V <- F[T, qid("X@" + string(N, 10) + ":" + string(Tp))])
        else empty
        fi |
        getSubst(getSubstitutions1(M, V, ODS, s s N)) ;
        getIndex(getSubstitutions1(M, V, ODS, s s N)) > 
    if sortLeq(M, leastSort(M, T), getType(V)) . ----  ls[e] <= s ls[f(y,e)] <= s
  ceq getSubstitutions1(M, V, op F : TpL -> Tp [left-id(T) AtS] . ODS, N) 
    = < (V <- T) |
        if (assoc in AtS and-then not comm in AtS)
           and-then sortLeq(M, leastSort(M, F[qid("X@" + string(N, 10) + ":" + string(Tp)), T]), getType(V))
        then (V <- F[qid("X@" + string(s N, 10) + ":" + string(Tp)), T])
        else empty
        fi |
        getSubst(getSubstitutions1(M, V, ODS, s s N)) ;
        getIndex(getSubstitutions1(M, V, ODS, s s N)) > 
    if sortLeq(M, leastSort(M, T), getType(V)) . ----  ls[e] <= s ls[f(y,e)] <= s
  eq getSubstitutions1(M, V, ODS, N) = < empty ; N > [owise] . 

  ------------------------------------------------------------------------------
  ---- Given a module with axioms B where for each f we have B_f \in {A_f,C_f},
  ---- we now define a rewrite theory (\Sigma, B', A), where for each f we have
  ---- B'_f = B_f if B_f =/= {A_f}, and B'_f = \emptyset if B_f == {A_f}, and 
  ---- where A consists of rules of either the form 
  ----  f(f(x, y), z) -> f(x, f(y, z))
  ---- or the form
  ----  f(x, f(y, z)) -> f(f(x, y), z)
  ---- for each f such that B_f == {A_f}. That is, for any such f we "choose" a 
  ---- rule asociating f to the right or to the left (but only "one" of these possibilities).
  
  ---- TO DO: I cannot set a timeout. If the first one doesn't work it hangs up!
  ---- TO DO: All terms are in their flatten form, when removing the assoc atributes I get error messages.
  
  op removeLonelyAssocs : Module -> Module .
  ---- removes all assoc with no comm, returning an equivalent module 
  op $removeLonelyAssocs : OpDeclSet -> OpDeclSet .
  ---- removes those assoc attributes that are not with the comm one
  op $removeLonelyAssocs : Module OpDeclSet OpDeclSet EquationSet ~> Module .
  ---- arg. 1 (Module): the module with assoc attribute removed
  ---- arg. 2 (OpDeclSet): initially all op. decls.; they are evaluated one by one, 
  ----   adding the corresponding equation to the 4th arg. in the recursive call
  ---- arg. 3 (OpDeclSet): initially empty; evaluated op. decls. are added to this set
  ---- arg. 4 (EquationSet): assoc. eq. to be added to the module
  op $checkAEq : Module Equation -> Bool .
  ---- checks whether the assoc. eq. given as argument unifies with any lhs in the module
  ---- arg. 1 (Module): the module with assoc attribute removed
  ---- arg. 2 (Equation): tentative assoc. eq. to evaluate
  op $checkAEqAux : Module EquationSet -> Bool .
  ---- tries to narrow with the assoc. eq. (as a rule) on each lhs in the module.
  ---- arg. 1 (Module): module with assoc attribute removed, with the assoc. eq.
  ----   turned into a rule as single rule (no eqs.) 
  ---- arg. 2 (EquationSet): eqs. in the original module
  op $anyLonelyAssoc : OpDeclSet -> Bool .
  ---- checks whether the module contains an operator with assoc and no comm

  eq removeLonelyAssocs(M) 
    = if $anyLonelyAssoc(getOps(M))
      then if nonValidAttrs(getOps(M), owise idem iter)
           then unitError('The 'module 'uses 'non-supported 'attributes '`(owise`, 'idem`, 'or 'iter '`). '`))
           else if singleVbleInLHSs(getRls(M))
                then unitError('The 'module 'contains 'rules 'with 'single 'variables 'in 'their 'left-hand 'sides. '`))
                else if singleVbleInLHSs(getEqs(M))
                     then unitError('The 'module 'contains 'equations 'with 'single 'variables 'in 'their 'left-hand 'sides. '`))
                     else $removeLonelyAssocs(setOps(M, $removeLonelyAssocs(getOps(M))), getOps(M), none, none)
                     fi
                fi
           fi
      else M
      fi .
  
  ceq $removeLonelyAssocs(op F : Tp Tp -> Tp [assoc AtS] . OPDS)
    = op F : Tp Tp -> Tp [AtS] . $removeLonelyAssocs(OPDS)
    if not comm in AtS .
  eq $removeLonelyAssocs(OPDS) = OPDS [owise] . 

  ceq $removeLonelyAssocs(M, op F : TpL -> Tp [AtS] . OPDS, OPDS', EqS)
    = $removeLonelyAssocs(M, OPDS, op F : TpL -> Tp [AtS] . OPDS', EqS) 
    if size(TpL) =/= 2 or not assoc in AtS or comm in AtS .
  ceq $removeLonelyAssocs(M, op F : Tp Tp -> Tp [assoc AtS] . OPDS, OPDS', EqS)
    = $removeLonelyAssocs(M, OPDS, op F : Tp Tp -> Tp [AtS] . OPDS', Eq EqS) 
    if not comm in AtS 
    /\ Str:String := string(type2qid(getKind(M, Tp)))
    /\ Eq := (eq F[F[qid("X:" + Str:String), qid("Y:" + Str:String)], qid("Z:" + Str:String)] 
                = F[qid("X:" + Str:String), F[qid("Y:" + Str:String), qid("Z:" + Str:String)]] [label('assocEq)] .) 
    /\ $checkAEq(M, Eq) .
  ceq $removeLonelyAssocs(M, op F : Tp Tp -> Tp [assoc AtS] . OPDS, OPDS', EqS)
    = $removeLonelyAssocs(M, OPDS, op F : Tp Tp -> Tp [AtS] . OPDS', Eq EqS) 
    if not comm in AtS 
    /\ Str:String := string(type2qid(getKind(M, Tp))) 
    /\ Eq := (eq F[qid("X:" + Str:String), F[qid("Y:" + Str:String), qid("Z:" + Str:String)]] 
                = F[F[qid("X:" + Str:String), qid("Y:" + Str:String)], qid("Z:" + Str:String)] [label('assocEq)] .) 
    /\ $checkAEq(M, Eq) .
  eq $removeLonelyAssocs(M, none, OPDS', EqS) = addEqs(EqS, M) .
  eq $removeLonelyAssocs(M, op F : TpL -> Tp [AtS] . OPDS, OPDS', EqS) = unitError('assoc 'attributes 'cannot 'be 'removed 'for F) [owise] .
  
  eq $checkAEq(M, Eq) = $checkAEqAux(setRls(setEqs(M, none), rulify(Eq)), getEqs(M)) .
  
  ceq $checkAEqAux(M, Eq EqS)
    = T:Term == lhs(Eq) ---- the assoc eq doesn't unify with the equation's lhs
      and
      Subst:Substitution == none
      and-then 
      $checkAEqAux(M, EqS) 
    if {T:Term, Tp:Type, Subst:Substitution} := metaNarrow(M, lhs(Eq), 1) .
  eq $checkAEqAux(M, none) = true .

  ceq $anyLonelyAssoc(op F : Tp Tp -> Tp [assoc AtS] . OPDS)
    = true
    if not comm in AtS .
  eq $anyLonelyAssoc(OPDS) = false [owise] .
endfm

*******************************************************************************

***
*** Interaction with the Persistent Database
***

*** In the case of Full Maude, the persistent state of the system is given by
*** a single object which maintains the database of the system. This object
*** has an attribute \texttt{db}, to keep the actual database in which all the
*** modules being entered are stored, an attribute \texttt{default}, to keep
*** the identifier of the current module by default, and attributes
*** \texttt{input} and \texttt{output} to simplify the communication of the
*** read-eval-print loop given by the \texttt{LOOP-MODE} module with the
*** database. Using the notation for classes in object-oriented modules (see 
*** Section~\ref{object-oriented-modules}) we can declare the class 
*** \texttt{database} as follows:
*** 
***   class database | db : Database, input : TermList, 
***                    output : QidList, default : ModId .
*** 
*** Since we assume that \texttt{database} is the only object class that has
*** been defined---so that the only objects of sort \texttt{Object} will
*** belong to the \texttt{database} class---to specify the admissible states
*** in the persistent state of \texttt{LOOP-MODE} for Full Maude, it is enough 
*** to give the subsort declaration
*** 
***   subsort Object < State .

*** 
*** \subsection{The \texttt{CONFIGURATION+} Module}
*** 

*** change (2/20/2002): CONFIGURATION is now part of the prelude
***
*** fmod CONFIGURATION is
***   sort Oid Cid Attribute AttributeSet Configuration Object Msg .
*** 
***   subsort Attribute < AttributeSet .
***   subsorts Object Msg < Configuration .
*** 
***   op none : -> AttributeSet .
***   op _,_ : AttributeSet AttributeSet -> AttributeSet 
***       [assoc comm id: none] .
***   op none : -> Configuration .
***   op __ : Configuration Configuration -> Configuration 
***       [assoc comm id: none] .
***   op <_:_|_> : Oid Cid AttributeSet -> Object .
***   op <_:_| > : Oid Cid -> Object .
*** 
***   var O : Oid .
***   var C : Cid .
*** 
***   eq < O : C | > = < O : C | none > .
*** endfm

*******************************************************************************

***
*** Top Level Handling of the Persistent Database
***

*** Note that, since the Full Maude specification is given as a system module
***Core Maude, object-oriented declarations cannot be given directly.
*** Instead, the equivalent declarations desugaring the desired
*** object-oriented declarations have to be specified. We use also the same
*** conventions discussed in Section~\ref{omod2mod} regarding the use of
*** variables instead of class names in the objects and in the addition of
*** variables of sort \texttt{AttributeSet} to range over the additional 
*** attributes. As we shall see in Chapter~\ref{crc}, this convention will 
*** allow us to extend the Full Maude system in a very simple and clean way.

*** To allow the use of the object-oriented notation the predefined module
*** \texttt{CONFIGURATION}, presented in Section~\ref{omod2mod}, is included
*** in the following module \texttt{DATABASE-HANDLING}.


mod DATABASE-HANDLING is
---  inc META-LEVEL + PRE-VARIANT .
  inc META-LEVEL .
  inc CONFIGURATION .
  pr VIEW-META-PRETTY-PRINT .
  pr VIEW-PROCESSING .
  pr COMMAND-PROCESSING .
  pr PREDEF-UNITS .
  pr MODULE-VARIANTS .
  pr AX-COHERENCE-COMPLETION .
  pr HELP .

  var  F : Qid .
  var  QIL : QidList .
  var  NQIL NQIL' NQIL'' : NeQidList .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  var  DB DB' : Database .
  vars ME ME' ME'' : ModuleExpression .
  vars QIL' QIL'' : QidList .
  vars MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  var  VE : ViewExp .
  var  VES : Set{ViewExp} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars PDS PDS' : Set{ParameterDecl} .
  var  B : Bool .
  var  I : Import .
  var  IL : ImportList .
  var  MN : ModuleName .

  op initialDatabase : -> Database .
  eq initialDatabase
    = insTermModule('META-MODULE, 
        addOps(getOps(#UP#),
          addSorts(getSorts(#UP#), 
            addImports(getImports(#UP#), upModule('META-MODULE, false)))),
        emptyDatabase) . 
---(
  eq initialDatabase
    = insTermModule('META-MODULE, 
        addOps(getOps(#UP#),
          addSorts(getSorts(#UP#), 
            addImports(getImports(#UP#), upModule('META-MODULE, false)))),
      insertTermView('TRIV,
        ('view_from_to_is_endv['token[''TRIV.Qid],'token[''TRIV.Qid],'token[
         ''TRIV.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Elt.Qid]]]),
      insertTermView('Bool,
        ('view_from_to_is_endv['token[''Bool.Qid],'token[''TRIV.Qid],'token[
         ''BOOL.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Bool.Qid]]]),
      insertTermView('Nat,
        ('view_from_to_is_endv['token[''Nat.Qid],'token[''TRIV.Qid],'token[
         ''NAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Nat.Qid]]]),
      insertTermView('Int,
        ('view_from_to_is_endv['token[''Int.Qid],'token[''TRIV.Qid],'token[
         ''INT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Int.Qid]]]),
      insertTermView('Rat,
        ('view_from_to_is_endv['token[''Rat.Qid],'token[''TRIV.Qid],'token[
         ''RAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Rat.Qid]]]),
      insertTermView('Float,
        ('view_from_to_is_endv['token[''Float.Qid],'token[''TRIV.Qid],'token[
         ''FLOAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Float.Qid]]]),
      insertTermView('String,
        ('view_from_to_is_endv['token[''String.Qid],'token[''TRIV.Qid],'token[
         ''STRING.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''String.Qid]]]),
      insertTermView('Qid,
        ('view_from_to_is_endv['token[''Qid.Qid],'token[''TRIV.Qid],'token[
         ''QID.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Qid.Qid]]]),
      insertTermView('STRICT-WEAK-ORDER,
        ('view_from_to_is_endv['token[''STRICT-WEAK-ORDER.Qid],'token[''TRIV.Qid],
         'token[''STRICT-WEAK-ORDER.Qid],'sort_to_.['sortToken[''Elt.Qid],
         'sortToken[''Elt.Qid]]]),
      insertTermView('STRICT-TOTAL-ORDER,
        ('view_from_to_is_endv['token[''STRICT-TOTAL-ORDER.Qid],
         'token[''STRICT-WEAK-ORDER.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Elt.Qid]]]),
      insertTermView('Nat<,
        ('view_from_to_is_endv['token[''Nat<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'token[''NAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Nat.Qid]]]),
      insertTermView('Int<,
        ('view_from_to_is_endv['token[''Int<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'token[''INT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Int.Qid]]]),
      insertTermView('Rat<,
        ('view_from_to_is_endv['token[''Rat<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],'token[
         ''RAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Rat.Qid]]]),
      insertTermView('Float<,
        ('view_from_to_is_endv['token[''Float<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'token[''FLOAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Float.Qid]]]),
      insertTermView('String<,
        ('view_from_to_is_endv['token[''String<.Qid],'token[''STRICT-TOTAL-ORDER.Qid],
         'token[''STRING.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''String.Qid]]]),
      insertTermView('TOTAL-PREORDER,
        ('view_from_to_is_endv['token[''TOTAL-PREORDER.Qid],'token[''TRIV.Qid],'token[
         ''TOTAL-PREORDER.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Elt.Qid]]]),
      insertTermView('TOTAL-ORDER,
        ('view_from_to_is_endv['token[''TOTAL-ORDER.Qid],'token[''TOTAL-PREORDER.Qid],
         'token[''TOTAL-ORDER.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Elt.Qid]]]),
      insertTermView('Nat<=,
        ('view_from_to_is_endv['token[''Nat<=.Qid],'token[''TOTAL-ORDER.Qid],
         'token[''NAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Nat.Qid]]]),
      insertTermView('Int<=,
        ('view_from_to_is_endv['token[''Int<=.Qid],'token[''TOTAL-ORDER.Qid],
         'token[''INT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Int.Qid]]]),
      insertTermView('Rat<=,
        ('view_from_to_is_endv['token[''Rat<=.Qid],'token[''TOTAL-ORDER.Qid],'token[
         ''RAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Rat.Qid]]]),
      insertTermView('Float<=,
        ('view_from_to_is_endv['token[''Float<=.Qid],'token[''TOTAL-ORDER.Qid],
         'token[''FLOAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Float.Qid]]]),
      insertTermView('String<=,
        ('view_from_to_is_endv['token[''String<=.Qid],'token[''TOTAL-ORDER.Qid],
         'token[''STRING.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''String.Qid]]]),
      insertTermView('DEFAULT,
        ('view_from_to_is_endv['token[''DEFAULT.Qid],'token[''TRIV.Qid],'token[
         ''DEFAULT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Elt.Qid]]]),
      insertTermView('Nat0,
        ('view_from_to_is_endv['token[''Nat0.Qid],'token[''DEFAULT.Qid],'token[
         ''NAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Nat.Qid]]]),
      insertTermView('Int0,
        ('view_from_to_is_endv['token[''Int0.Qid],'token[''DEFAULT.Qid],'token[
         ''INT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Int.Qid]]]),
      insertTermView('Rat0,
        ('view_from_to_is_endv['token[''Rat0.Qid],'token[''DEFAULT.Qid],'token[
         ''RAT.Qid],'sort_to_.['sortToken[''Elt.Qid],'sortToken[''Rat.Qid]]]),
      insertTermView('Float0,
        ('view_from_to_is_endv['token[''Float0.Qid],'token[''DEFAULT.Qid],
         'token[''FLOAT.Qid],'__['sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''Float.Qid]], 'op_to`term_.['bubble[''0.Qid],'bubble[''0.0.Qid]]]]),
      insertTermView('String0,
        ('view_from_to_is_endv['token[''String0.Qid],'token[''DEFAULT.Qid],
         'token[''STRING.Qid],'__['sort_to_.['sortToken[''Elt.Qid],'sortToken[
         ''String.Qid]],'op_to`term_.['bubble[''0.Qid],'bubble[''"".Qid]]]]),
      insertTermView('Qid0,
        ('view_from_to_is_endv['token[''Qid0.Qid],'token[''DEFAULT.Qid],'token[
         ''QID.Qid],'__['sort_to_.['sortToken[''Elt.Qid],'sortToken[''Qid.Qid]],
         'op_to`term_.['bubble[''0.Qid],'bubble['''.Qid]]]]),
      emptyDatabase)))))))))))))))))))))))))))))) .
---)

*** We start by introducing a subsort \texttt{DatabaseClass} of sort
*** \texttt{Cid}, the operator declarations necessary for representing objects
*** in class \texttt{DatabaseClass} as defined above, and variables to range
*** over subclasses of class \texttt{DatabaseClass} and over attributes.

  sort DatabaseClass .
  subsort DatabaseClass < Cid .
  op Database : -> DatabaseClass .
  op db :_ : Database -> Attribute .
  op input :_ : TermList -> Attribute .
  op output :_ : QidList -> Attribute .
  op default :_ : Header -> Attribute .

  var Atts : AttributeSet .
  var X@DatabaseClass : DatabaseClass .
  var O : Oid .

*** Next, we introduce an auxiliary function \texttt{parseHeader} to parse
*** names of user-defined modules, and a constant \texttt{nilTermList} of sort
*** \texttt{TermList}. Note that the name of a user-defined module must be a
*** single identifier (a token) or, for parameterized modules, its name---a 
*** single identifier---and its interface.

  op parseHeader : Term -> Qid .
  eq parseHeader('token[T]) = downQid(T) .
  ----eq parseHeader('_`(_`)['token[T], T']) = downQid(T) .
  eq parseHeader('_`{_`}['token[T], T']) = downQid(T) .

  op nilTermList : -> TermList .

*** Finally, we present the rules processing the inputs of the database. These
*** rules define the behavior of the system for the different commands,
*** modules, theories, and views entered into the system. For example, the
*** first rule processes the different types of modules entered to the system.
*** Note that the operators declared as constructors of sort \texttt{PreModule}
*** in the signature of Full Maude, given in
*** Appendix~\ref{signature-full-maude}, are declared with two arguments, 
*** namely the name of the unit, or its name + its interface, and the list 
*** of declarations of such a unit.

  crl [module] :
     < O : X@DatabaseClass | db : DB, input : (F[T, T']), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : procModule(F[T, T'], DB), input : nilTermList, 
           output : ('Introduced 'module header2Qid(parseHeader(T)) '\n),
           default : parseHeader(T), Atts > 
     if  (F == 'fmod_is_endfm) or-else 
        ((F == 'obj_is_endo)   or-else 
        ((F == 'obj_is_jbo)    or-else 
        ((F == 'mod_is_endm)   or-else 
         (F == 'omod_is_endom)))) .

*** Notice the message placed in the output channel, and the change in the
*** current module by default, which is now the new module just processed.
*** Since the name of the module \texttt{T} can be complex---a parameterized
*** module---some extra parsing has to be performed by the auxiliary function
*** \texttt{parseHeader}. Similar rules are given for the processing of 
*** theories and views.

  crl [theory] :
     < O : X@DatabaseClass | db : DB, input : (F[T, T']), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : procModule(F[T, T'], DB), input : nilTermList, 
           output : ('Introduced 'theory header2Qid(parseHeader(T)) '\n),
           default : parseHeader(T), Atts > 
     if  (F == 'fth_is_endfth) or-else 
        ((F == 'th_is_endth)   or-else 
         (F == 'oth_is_endoth)) .

  rl [view] :
     < O : X@DatabaseClass | db : DB, 
        input : ('view_from_to_is`endv[T, T', T'']), 
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : procView('view_from_to_is_endv[T, T', T'', 'none.ViewDeclSet], DB),
           input : nilTermList, 
           output : ('Introduced 'view header2Qid(parseHeader(T)) '\n),
           default : ME, Atts > .
  rl [view] :
     < O : X@DatabaseClass | db : DB, 
        input : ('view_from_to_is_endv[T, T', T'', T3]), 
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : procView('view_from_to_is_endv[T, T', T'', T3], DB),
           input : nilTermList, 
           output : ('Introduced 'view header2Qid(parseHeader(T)) '\n),
           default : ME, Atts > .

*** Commands are handled by rules as well. For example, the \texttt{down},
*** \texttt{reduce}, and \texttt{rewrite} commands are handled by the 
*** following rules.

  rl [down] :
     < O : X@DatabaseClass | db : DB, input : ('down_:_[T, T']), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : getDatabase(procDownCommand('down_:_[T, T'], ME, DB)), 
           input : nilTermList, 
           output : getQidList(procDownCommand('down_:_[T, T'], ME, DB)), 
           default : ME, Atts > .

  crl [red/rew/frew] :
     < O : X@DatabaseClass | db : DB, input : (F[T]), output : QIL, default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : getDatabase(procCommand(F[T], ME, DB)), 
           input : nilTermList, 
           output : getQidList(procCommand(F[T], ME, DB)), 
           default : ME, Atts > 
     if  (F == 'parse_.)    or-else 
        ((F == 'red_.)      or-else 
        ((F == 'reduce_.)   or-else 
        ((F == 'rew_.)      or-else 
        ((F == 'rewrite_.)  or-else 
        ((F == 'frew_.)     or-else  
        ((F == 'frewrite_.) or-else 
        ((F == 'unify_.) or-else 
         (F == 'id-unify_.) or-else 
         (F == 'variant`unify_.) or-else 
         (F == 'asymmetric`variant`unify_.) or-else 
         (F == 'get`variants_.)
         ))))))) .

  crl [search] :
     < O : X@DatabaseClass | db : DB, input : (F[T, T']), output : QIL, default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : getDatabase(procCommand(F[T, T'], ME, DB)), 
           input : nilTermList, 
           output : getQidList(procCommand(F[T, T'], ME, DB)), 
           default : ME, Atts > 
     if  (F == 'search_=>_.)  or-else 
        ((F == 'search_=>1_.) or-else 
        ((F == 'search_=>*_.) or-else 
        ((F == 'search_=>+_.) or-else  
        ((F == 'search_=>!_.) or-else
        ((F == 'search_~>_.)  or-else 
        ((F == 'search_~>1_.) or-else 
        ((F == 'search_~>*_.) or-else 
        ((F == 'search_~>+_.) or-else  
        ((F == 'search_~>!_.) or-else
        ((F == 'match_<=?_.)  or-else 
         (F == 'xmatch_<=?_.))))))))))) .

  rl [select] :
     < O : X@DatabaseClass | db : DB, input : ('select_.[T]), output : QIL, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB, input : nilTermList, output : (QIL 'The eMetaPrettyPrint(parseModExp(T)) 'has 'been 'set 'as 'current 'module. '\n), default : parseModExp(T), Atts > .

  rl [show-modules] :
     < O : X@DatabaseClass | db : DB, 
        input : ('show`modules`..@Command@), 
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB, input : nilTermList, 
           output : showModules(DB), default : ME, Atts > .
  rl [show-views] :
     < O : X@DatabaseClass | db : DB, 
        input : ('show`views`..@Command@), 
        output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB, input : nilTermList, 
           output : showViews(DB), default : ME, Atts >  .

*** The \texttt{show module} command, which prints the specified module, or
*** the current one if no module name is specified, is handled by the 
*** following rules.

  crl [show-module] :
    < O : X@DatabaseClass | db : DB, 
       input : ('show`module`..@Command@), 
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getTopModule(ME', DB')),
          default : ME', Atts > 
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [show-module] :
    < O : X@DatabaseClass | db : DB, input : ('show`module_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass | 
          db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME'', DB'), getTopModule(ME'', DB')),
          default : ME, Atts > 
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .
  crl [show-module] :
    < O : X@DatabaseClass | db : DB, input : ('show`module_.[T]), output : nil, Atts >
    => < O : X@DatabaseClass | db : DB, input : nil, 
          output : ('Error 'evaluating 'the 'given 'module 'expression.), Atts > 
    if evalModExp(ME:[ModuleExpression], DB':[Database]) := evalModExp(parseModExp(T), DB) .

  crl [show-all] :
    < O : X@DatabaseClass | db : DB, input : ('show`all`..@Command@), 
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getFlatModule(ME', DB')),
          default : ME', Atts > 
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [show-all] :
    < O : X@DatabaseClass | db : DB, input : ('show`all_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getFlatModule(ME', DB')),
          default : ME, Atts > 
    if ME'' := parseModExp(T) 
    /\ < DB' ; ME' > := evalModExp(ME'', DB) .

  crl [show-vars] :
    < O : X@DatabaseClass | db : DB, input : ('show`vars`..@Command@), 
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrintVars(getVars(ME', DB')),
          default : ME', Atts >  
    if DB' := database(evalModExp(ME, DB)) 
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-vars] :
    < O : X@DatabaseClass | db : DB, input : ('show`vars_.[T]), 
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrintVars(getVars(ME', DB')),
          default : ME, Atts > 
    if ME'' := parseModExp(T) 
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-sorts] :
    < O : X@DatabaseClass | db : DB, input : ('show`sorts`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getSorts(getFlatModule(ME', DB'))),
          default : ME', Atts >  
    if DB' := database(evalModExp(ME, DB)) 
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-sorts] :
    < O : X@DatabaseClass | db : DB, input : ('show`sorts_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getSorts(getFlatModule(ME', DB'))),
          default : ME, Atts > 
    if ME'' := parseModExp(T) 
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-ops] :
    < O : X@DatabaseClass | db : DB, input : ('show`ops`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getOps(getFlatModule(ME', DB'))),
          default : ME', Atts >  
    if DB' := database(evalModExp(ME, DB)) 
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-ops] :
    < O : X@DatabaseClass | db : DB, input : ('show`ops_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getOps(getFlatModule(ME', DB'))),
          default : ME, Atts > 
    if ME'' := parseModExp(T) 
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-mbs] :
    < O : X@DatabaseClass | db : DB, input : ('show`mbs`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getMbs(getFlatModule(ME', DB'))),
          default : ME', Atts >  
    if DB' := database(evalModExp(ME, DB)) 
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-mbs] :
    < O : X@DatabaseClass | db : DB, input : ('show`mbs_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getMbs(getFlatModule(ME', DB'))),
          default : ME, Atts > 
    if ME := parseModExp(T) 
       /\ DB' := database(evalModExp(ME, DB))
       /\ ME' := modExp(evalModExp(ME, DB)) .

  crl [show-eqns] :
    < O : X@DatabaseClass | db : DB, input : ('show`eqs`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | 
          db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getEqs(getFlatModule(ME', DB'))),
         default : ME', Atts >  
    if DB' := database(evalModExp(ME, DB)) 
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-eqns] :
    < O : X@DatabaseClass | db : DB, input : ('show`eqs_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | 
          db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getEqs(getFlatModule(ME', DB'))),
          default : ME, Atts > 
    if ME'' := parseModExp(T) 
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-rls] :
    < O : X@DatabaseClass | db : DB, input : ('show`rls`..@Command@), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getRls(getFlatModule(ME', DB'))),
          default : ME', Atts >  
    if DB' := database(evalModExp(ME, DB)) 
       /\ ME' := modExp(evalModExp(ME, DB)) .
  crl [show-rls] :
    < O : X@DatabaseClass | db : DB, input : ('show`rls_.[T]), output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : eMetaPrettyPrint(getFlatModule(ME', DB'), getRls(getFlatModule(ME', DB'))),
          default : ME, Atts > 
    if ME'' := parseModExp(T) 
       /\ DB' := database(evalModExp(ME'', DB))
       /\ ME' := modExp(evalModExp(ME'', DB)) .

  crl [show-view] :
     < O : X@DatabaseClass | db : DB, input : ('show`view_.[T]), output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | db : DB', input : nilTermList, 
           output : eMetaPrettyPrint(DB', getView(parseViewExp(T), DB')),
           default : ME, Atts > 
     if DB' := evalViewExp(parseViewExp(T), nil, DB) .

  crl [set`protect_on] :
     < O : X@DatabaseClass | 
           db : DB,  
           input : ('set`protect_on`.[T]), 
           output : QIL', 
           default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES,  
                   MNS' ME', MNS'', MNS3, QIL), 
           input : nilTermList, 
           output : (QIL' 'set 'protect header2QidList(ME') 'on '\n), 
           default : ME, Atts > 
     if ME' := parseModExp(T) 
        /\ unitInDb(ME', DB)
        /\ db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) := DB .
  crl [set`protect_off] :
     < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL),  
           input : ('set`protect_off`.[T]), 
           output : QIL', 
           default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES, remove(MNS', ME'), MNS'', MNS3, QIL),  
           input : nilTermList, 
           output : (QIL' 'set 'protect header2QidList(ME') 'off '\n), 
           default : ME, Atts > 
     if ME' := parseModExp(T) .

  crl [set`extend_on] :
     < O : X@DatabaseClass | 
           db : DB,  
           input : ('set`extend_on`.[T]), 
           output : QIL', 
           default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES,  
                   MNS', MNS'' ME', MNS3, QIL), 
           input : nilTermList, 
           output : (QIL' 'set 'extend header2QidList(ME') 'on '\n), 
           default : ME, Atts > 
     if ME' := parseModExp(T) 
        /\ unitInDb(ME', DB)
        /\ db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) := DB .
  crl [set`extend_off] :
     < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL),  
           input : ('set`extend_off`.[T]), 
           output : QIL', 
           default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES, MNS', remove(MNS'', ME'), MNS3, QIL),  
           input : nilTermList, 
           output : (QIL' 'set 'extend header2QidList(ME') 'off '\n), 
           default : ME, Atts > 
     if ME' := parseModExp(T) .

  crl [set`include_on] :
     < O : X@DatabaseClass | 
           db : DB,  
           input : ('set`include_on`.[T]), 
           output : QIL', 
           default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES,  
                   MNS', MNS'', MNS3 . ME', QIL), 
           input : nilTermList, 
           output : (QIL' 'set 'include header2QidList(ME') 'on '\n), 
           default : ME, Atts > 
     if ME' := parseModExp(T) 
        ----/\ unitInDb(ME', DB)
        /\ db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL) := DB .
  crl [set`include_off] :
     < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL),  
           input : ('set`include_off`.[T]), 
           output : QIL', 
           default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', remove(MNS3, ME'), QIL),  
           input : nilTermList, 
           output : (QIL' 'set 'include header2QidList(ME') 'off '\n), 
           default : ME, Atts > 
     if ME' := parseModExp(T) .

  crl [load] :
     < O : X@DatabaseClass | 
           db : DB,  
           input : ('load_.[T]), 
           output : QIL', 
           default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : getDatabase(procLoad(T, ME, DB)), 
           input : nilTermList, 
           output : getQidList(procLoad(T, ME, DB)), 
           default : ME, Atts > 
     if ME' := parseModExp(T) .

  eq 'rm`ids`..@Command@ = 'remove`identity`attributes`..@Command@ .
  eq 'rm`ids_.[T] = 'remove`identity`attributes_.[T] .
  
  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB, 
       input : ('remove`identity`attributes`..@Command@), 
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), removeIds(getFlatModule(ME', DB'), all))),
          default : ME', Atts > 
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB, input : ('remove`identity`attributes_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass | 
          db : DB', input : nilTermList, 
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), removeIds(axCohComplete(getFlatModule(ME'', DB')), all))),
          default : ME, Atts > 
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  eq 'rm`nh`ids`..@Command@ = 'remove`non-handled`identity`attributes`..@Command@ .
  eq 'rm`nh`ids_.[T] = 'remove`non-handled`identity`attributes_.[T] .
  
  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB, 
       input : ('remove`non-handled`identity`attributes`..@Command@), 
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), removeIds(getFlatModule(ME', DB'), non-handled))),
          default : ME', Atts > 
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [remove-id-attributes] :
    < O : X@DatabaseClass | db : DB, input : ('remove`non-handled`identity`attributes_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass | 
          db : DB', input : nilTermList, 
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), removeIds(getFlatModule(ME'', DB'), non-handled))),
          default : ME, Atts > 
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  crl [remove-assoc-attributes] :
    < O : X@DatabaseClass | db : DB, 
       input : ('remove`assoc`attributes`..@Command@), 
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), removeLonelyAssocs(getFlatModule(ME', DB')))),
          default : ME', Atts > 
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [remove-assoc-attributes] :
    < O : X@DatabaseClass | db : DB, input : ('remove`assoc`attributes_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass | 
          db : DB', input : nilTermList, 
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), removeLonelyAssocs(getFlatModule(ME'', DB')))),
          default : ME, Atts > 
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  crl [acu-coherence-completion] :
    < O : X@DatabaseClass | db : DB, 
       input : ('ax`coherence`completion`..@Command@), 
       output : nil, default : ME, Atts >
    => < O : X@DatabaseClass | db : DB', input : nilTermList, 
          output : (eMetaPrettyPrint(getFlatModule(ME', DB'), axCohComplete(getFlatModule(ME', DB')))),
          default : ME', Atts > 
    if < DB' ; ME' > := evalModExp(ME, DB) .
  crl [acu-coherence-completion] :
    < O : X@DatabaseClass | db : DB, input : ('ax`coherence`completion_.[T]), output : nil, default : ME,   Atts >
    => < O : X@DatabaseClass | 
          db : DB', input : nilTermList, 
          output : (eMetaPrettyPrint(getFlatModule(ME'', DB'), axCohComplete(getFlatModule(ME'', DB')))),
          default : ME, Atts > 
    if < DB' ; ME'' > := evalModExp(parseModExp(T), DB) .

  rl [error] :
     < O : X@DatabaseClass | 
        db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, NQIL), 
        input : TL, output : nil, default : ME, Atts >
     => < O : X@DatabaseClass | 
           db : db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, nil), 
           input : TL, output : NQIL, default : ME, Atts > .

  *** Auxiliary Functions

  op showViews : Database -> QidList .
  op showModules : Database -> QidList .

  eq showViews(db(MIS, MNS, VIS, (VE # VES), MNS', MNS'', MNS3, QIL))
    = (eMetaPrettyPrint(VE) '\n 
       showViews(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))) .
  eq showViews(
       db(MIS, MNS, VIS, emptyViewExpSet, MNS', MNS'', MNS3, QIL)) 
    = nil .

  eq showModules(
       db(MIS, (MN . MNS), VIS, VES, MNS', MNS'', MNS3, QIL))
    = (eMetaPrettyPrint(MN) '\n 
       showModules(db(MIS, MNS, VIS, VES, MNS', MNS'', MNS3, QIL))) .
  eq showModules(
    db(MIS, emptyModuleNameSet, VIS, VES, MNS', MNS'', MNS3, QIL))
    = nil .

  rl [help] :
     < O : X@DatabaseClass | input : ('help`..@Command@), output : QIL, Atts >
     => < O : X@DatabaseClass | input : nilTermList, output : fm-help, Atts > .
endm

*******************************************************************************
fmod TEXT-STYLE is
--- pr META-LEVEL + PRE-VARIANT .
 pr META-LEVEL .

 var QL : QidList .

 op green : QidList -> QidList .
 eq green(QL) = '\g QL '\o .

 op yellow : QidList -> QidList .
 eq yellow(QL) = '\y QL '\o .

 op red : QidList -> QidList .
 eq red(QL) = '\r QL '\o .

 op bold : QidList -> QidList .
 eq bold(QL) = '\! QL '\o .
endfm

*******************************************************************************

***
*** The Full Maude Module
***

*** We now give the rules to initialize the loop, and to specify the
*** communication between the loop---the input/output of the system---and the
*** database.  Depending on the kind of input that the database receives, its 
*** state will be changed, or some output will be generated.

mod FULL-MAUDE is
  pr META-FULL-MAUDE-SIGN .
  pr DATABASE-HANDLING .
  inc LOOP-MODE .
  pr BANNER .

*** The state of the persistent system, which is supported by the built-in
*** module \texttt{LOOP-MODE}, described in Section~\ref{loop}, is represented 
*** as a single object.

  subsort Object < State .

  op o : -> Oid .
  op init : -> System .

  var  Atts : AttributeSet .
  var  X@DatabaseClass : DatabaseClass .
  var  O : Oid .
  var  DB : Database .
  var  ME : Header .
  var  QI : Qid .
  vars QIL QIL' QIL'' : QidList .
  var  TL : TermList .
  var  N : Nat .
  vars RP RP' : ResultPair .

  rl [init] :
     init
     => [nil,
         < o : Database | 
            db : initialDatabase,
            input : nilTermList, output : nil, 
            default : 'CONVERSION >,
         ('\n '\t '\s '\s '\s '\s string2qidList(banner) '\n)] .

*** When some text has been introduced in the loop, the first argument of the
*** operator \verb~[_,_,_,]~ is different from \texttt{nil}, and we can use
*** this fact to activate the following rule, that enters an input such as a
*** module or a command from the user into the database.  The constant
*** \texttt{GRAMMAR} names the module containing the signature defining the
*** top level syntax of Full Maude (see Section~\ref{sec:signature} and
*** Appendix~\ref{signature-full-maude}). This signature is used by the
*** \texttt{metaParse} function to parse the input. PD the input is
*** syntactically valid\footnote{Of course, the input may be syntactically
*** valid, but not semantically valid, since further processing---for example,
*** of bubbles---may reveal a semantic inconsistency.}, the parsed input is 
*** placed in the \texttt{input} attribute of the database object; otherwise, 
*** an error message is placed in the output channel of the loop.

  rl [in] :
    [QI QIL, 
     < O : X@DatabaseClass | 
         db : DB, input : nilTermList, output : nil, default : ME, Atts >, 
     QIL']
    => if metaParse(GRAMMAR, QI QIL, '@Input@) :: ResultPair
       then [nil, 
             < O : X@DatabaseClass | db : DB, 
                 input : getTerm(metaParse(GRAMMAR, QI QIL, '@Input@)),
                 output : nil, default : ME, Atts >, 
              QIL'] 
       else [nil, 
             < O : X@DatabaseClass | db : DB, input : nilTermList, 
                 output : ('\r 'Warning: 
                           printSyntaxError(metaParse(GRAMMAR, QI QIL, '@Input@), 
                             QI QIL) 
                           '\n
                           '\r 'Error: '\o 'No 'parse 'for 'input. '\n), 
                 default : ME, Atts >, 
             QIL'] 
       fi .

*** When the \texttt{output} attribute of the persistent object contains a
*** nonempty list of quoted identifiers, the \texttt{out} rule moves it to the
*** third argument of the loop. Then the Core Maude system displays it in the 
*** terminal.

  rl [out] :
    [QIL, 
     < O : X@DatabaseClass | 
         db : DB, input : TL, output : (QI QIL'), default : ME, Atts >, 
     QIL'']
    => [QIL, 
        < O : X@DatabaseClass | 
            db : DB, input : TL, output : nil, default : ME, Atts >, 
        (QI QIL' QIL'')] .
endm

*******************************************************************************
