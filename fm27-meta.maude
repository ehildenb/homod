load fm27-omod.maude

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

***
*** Evaluation of Modules and Theories
***

*** As explained in Section~\ref{evaluation-overview}, in our approach
*** transforming a module from its possibly complex structured version to its
*** unstructured form is a two-step process.  First, all module expressions
*** are evaluated, generating an intermediate form in which there are only
*** simple inclusion relationships among the modules. This first step can be
*** seen as the reduction of a structured specification to its structured
*** \emph{normal form}. Then, in a second step, this structured normal form is
*** flattened into an unstructured specification.  Note, however, that the 
*** importation of built-in modules is left explicit in the flattened form. 
*** The function \texttt{normalize} is in charge of normalizing the 
*** structure.

*** The process of evaluation of a preunit has to take into account the
*** possibility of bubbles being contained in it. Depending on whether it is
*** dealing with a preunit or with a unit, the evaluation process is
*** accomplished by two different functions, namely, \texttt{evalPreModule} and
*** \texttt{evalModule}. One function or the other will be called in each case.
*** Evaluating a module already in the database, which is done by
*** \texttt{evalModule}, does not require bubble handling. Besides this
*** difference, both functions proceed in a similar way. Before presenting the 
*** functions \texttt{evalPreModule} and \texttt{evalModule} we introduce some 
*** auxiliary declarations.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod EVALUATION is
  pr O-O-TO-SYSTEM-MOD-TRANSF .
  pr MOD-EXPR-EVAL .
  pr UNIT-BUBBLE-PARSING .

  sort List<Module> .
  subsort Module < List<Module> .

  op nil : -> List<Module> .
  op __ : List<Module> List<Module> -> List<Module> [assoc id: nil] .
  eq unitError(QIL) UL unitError(QIL') = unitError(QIL QIL') UL .

  vars M PU U U' U'' : Module .
  vars UL UL' : List<Module> .
  vars DB  DB' : Database .
  vars ME ME' : ModuleExpression .
  var  P : ViewExp .
  var  PD : ParameterDecl .
  vars PL PL' PL'' : ParameterList .
  vars IL IL' IL'' : ImportList .
  var  I : Import .
  var  CDS : ClassDeclSet .
  var  SSDS : SubsortDeclSet .
  var  SCDS : SubclassDeclSet .
  var  OPD : OpDecl .
  vars OPDS VDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  B : Bool .
  vars QI QI' V L L' L'' A A' A'' F F' F'' X Y W Z : Qid .
  vars QIL QIL' SL : QidList .
  vars S S' S'' C C' C'' : Sort .
  vars SS SS' : SortSet .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  vars AtS AtS' : AttrSet .
  var  Rl : Rule .
  var  CD : ClassDecl .
  var  ADS : AttrDeclSet .
  var  MD : MsgDecl .
  vars T T' T'' T3 : Term .
  var  TL : TermList .
  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars VE VE' VE'' : ViewExp .
  var  HkL : HookList .
  vars PDL PDL' : ParameterDeclList .
  var  St : String .

*** The \texttt{subunitImports} function returns the list of all the
*** subunits of a given unit. It is called with the list of importations of
*** the given unit as first argument, and proceeds recursively through its 
*** structure collecting all the subunits in it.

*** The function \texttt{subunitImports} proceeds storing the importations
*** considered up to that point, so it does not have to go through the same
*** part of the structure more than once. When the function is initially 
*** called the second argument is set to \texttt{nil}.

  op subunitImports : ParameterDeclList ImportList Database -> ImportList .
  op subunitImports : ImportList ImportList Database -> ImportList .

  eq subunitImports((PD, PDL), IL, DB) 
    = subunitImports(PDL, IL (protecting pd(PD) .), DB) .
  eq subunitImports((nil).ParameterDeclList, IL, DB) 
    = subunitImports(IL, nil, DB) .

  eq subunitImports(I IL, IL' I IL'', DB) 
    = subunitImports(IL, IL' I IL'', DB)  .
  eq subunitImports(I IL, IL', DB) 
    = subunitImports(getImports(getTopModule(moduleName(I), DB)) IL, I IL', DB)
    [owise] .
  eq subunitImports((nil).ImportList, IL, DB) = IL .

*** The function \texttt{getModules} returns the list of those units
*** in the list of importations given as argument which are not built-in.

  op getModules : ImportList Database -> List<Module> .
  op getModules : ImportList List<Module> Database -> List<Module> .

  eq getModules(IL, DB) = getModules(IL, nil, DB) .

  eq getModules(((including ME .) IL), UL, DB) 
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((including pd(PD) .) IL), UL, DB) 
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(((extending ME .) IL), UL, DB) 
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((extending pd(PD) .) IL), UL, DB) 
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(((protecting ME .) IL), UL, DB) 
    = getModules(IL, (UL getInternalModule(ME, DB)), DB) .
  eq getModules(((protecting pd(PD) .) IL), UL, DB) 
    = getModules(IL, (UL getInternalModule(pd(PD), DB)), DB) .
  eq getModules(IL, UL unitError(QIL) UL', DB) = unitError(QIL) .
  eq getModules(nil, UL, DB) = UL .

*** The normalization of a structure consists in evaluating each of the module
*** expressions appearing in it. Note that, if the \texttt{evalModExp} function
*** generates new modules, they will be evaluated using the \texttt{evalModule}
*** function, producing recursive calls on the part of the structure not 
*** previously normalized. Parameters are handled separatedly. They are 
*** folded out when analyzing the interface of a module.

  pr 3TUPLE{ImportList,ParameterDeclList,Database}
       * (op ((_,_,_)) to <_;_;_>,
          op p1_ to importList,
          op p2_ to parameterDeclList,
          op p3_ to database) .

----  sort Tuple{ImportList,ParameterDeclList,Database} .
----  op <_;_;_> : ImportList ParameterDeclList Database 
----       -> Tuple{ImportList,ParameterDeclList,Database} .
----  op importList : Tuple{ImportList,ParameterDeclList,Database} -> ImportList .
----  op parameterDeclList : 
----       Tuple{ImportList,ParameterDeclList,Database} -> ParameterDeclList .
----  op database : Tuple{ImportList,ParameterDeclList,Database} -> Database .
----  eq importList(< IL ; PDL ; DB >) = IL .
----  eq parameterDeclList(< IL ; PDL ; DB >) = PDL .
----  eq database(< IL ; PDL ; DB >) = DB .

  op normalize : ImportList ParameterDeclList Database 
       -> Tuple{ImportList,ParameterDeclList,Database} .
  op normalize : ImportList ImportList ParameterDeclList ParameterDeclList 
       Database -> Tuple{ImportList,ParameterDeclList,Database} .
  op createCopy : ParameterDecl Database -> Database .
  ---- its definition is in INST-EXPR-EVALUATION

  eq normalize(IL, PDL, DB) = normalize(nil, IL, nil, PDL, DB) .

  eq normalize(IL, IL', PDL, (X :: ME, PDL'), DB) 
    = normalize(IL, IL', 
        (PDL, X :: modExp(evalModExp(ME, nil, DB))), PDL',
        createCopy((X :: modExp(evalModExp(ME, nil, DB))), 
          database(evalModExp(ME, nil, DB)))) .
  eq normalize(IL, (including ME .) IL', PDL, PDL', DB)
    = normalize(IL (including modExp(evalModExp(ME, PDL, DB)) .), IL', 
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, (extending ME .) IL', PDL, PDL', DB)
    = normalize(IL (extending modExp(evalModExp(ME, PDL, DB)) .), IL', 
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, (protecting ME .) IL', PDL, PDL', DB)
    = normalize(IL (protecting modExp(evalModExp(ME, PDL, DB)) .), IL', 
        PDL, PDL', database(evalModExp(ME, PDL, DB))) .
  eq normalize(IL, I IL', PDL, PDL', DB) 
    = normalize(IL I, IL', PDL, PDL', DB) 
    [owise] .
  eq normalize(IL, nil, PDL, nil, DB) = < IL ; PDL ; DB > .

*** \texttt{checkSortClashes} checks whether the intersection of the two sTS
*** of sorts given as arguments is empty or not. If it is nonempty, then there
*** is a clash of names, and a warning message is passed to the database.  The
*** check is very simple, and only reports the name of one of the modules from
*** which the sorts come. Only the name of the module from which the sorts 
*** given as second argument come is known at this point. This is the module 
*** name given as first argument.
*** 
***   op checkSortClashes : Header SortSet SortSet Database -> Database .
*** 
***   eq checkSortClashes(ME, (S ; SS), (S ; SS'), DB)
***     = checkSortClashes(ME, SS, SS', 
***         warning(DB, 
***           '\g 'Advisory: '\o
***           'Clash 'of 'sort eSortToSort(S) 'from header2Qid(ME) '\n)) .
***   ceq checkSortClashes(ME, (S ; SS), SS', DB)
***     = checkSortClashes(ME, SS, SS', DB)
***     if not (S in SS') .
***   eq check(ME, none, SS, DB) = DB .

*** In the current system, the only transformation handled by the
*** \texttt{transform} function is the one from object-oriented modules to
*** system modules, which is accomplished by the
*** \texttt{omod2mod} function presented in
*** Section~\ref{omod2modfunction}. However, \texttt{transform} has been 
*** defined as a general transformation that could affect other kinds of 
*** modules in a future extension.

  op transform : Module Database -> Module .

  eq transform(unitError(QIL), DB) = unitError(QIL) .
  ceq transform(U, DB) = rmVariantAttrs(U) if U :: SModule or U :: STheory .
  ceq transform(U, DB) = rmVariantAttrs(omod2mod(U, DB)) 
    if not U :: SModule /\ not U :: STheory /\ U :: OModule or U :: OTheory .

*** The function \texttt{signature} generates a functional module of sort
*** \texttt{FModule}, without equations, by ``forgetting'' the appropriate
*** declarations and converting extended sorts and module names into quoted 
*** identifiers.

  op removeIds : OpDeclSet Module -> OpDeclSet .
  eq removeIds(op F : TyL -> Ty [id(T) AtS] . OPDS, M) 
    = removeIds(op F : TyL -> Ty [AtS] . OPDS, M) .
  eq removeIds(op F : TyL -> Ty [right-id(T) AtS] . OPDS, M) 
    = removeIds(op F : TyL -> Ty [AtS] . OPDS, M) .
  eq removeIds(op F : TyL -> Ty [left-id(T) AtS] . OPDS, M) 
    = removeIds(op F : TyL -> Ty [AtS] . OPDS, M) .
  eq removeIds(op F : TyL -> Ty [special(term-hook(QI, T) HkL) AtS] . OPDS, M) 
    = removeIds(op F : TyL -> Ty [special(HkL) AtS] . OPDS, M) .
  eq removeIds(OPDS, M) = OPDS [owise] .

  op removeDittos : OpDeclSet Module -> OpDeclSet .
  ceq removeDittos(
        op F : TyL -> Ty [ditto AtS] . op F : TyL' -> Ty' [AtS'] . OPDS, M)
    = removeDittos(
        op F : TyL -> Ty [AtS removeCtorMetadata(AtS')] . op F : TyL' -> Ty' [AtS'] . OPDS, M) 
    if not ditto in AtS' /\ sameKind(M, TyL Ty, TyL' Ty') .
  eq removeDittos(OPDS, M) = OPDS [owise] .

  op signature : Module -> Module .
  eq signature(unitError(QIL)) = unitError(QIL) .
  eq signature(U) 
    = fmod header2Qid(getName(U)) is
         convertModuleExpressions(getImports(U))
         sorts getSorts(U) .
         getSubsorts(U)
         removeIds(
           removeDittos(getOps(U), 
             setSubsorts(
               setSorts(emptyFModule('DUMMY), getSorts(U)),
               getSubsorts(U))),
           setSubsorts(
             setSorts(emptyFModule('DUMMY), getSorts(U)),
             getSubsorts(U)))
         none
         none
      endfm 
    [owise] .

*** The function \texttt{flatModule} generates a module of sort \texttt{Module}
*** by ``forgetting'' declarations and converting extended sorts and module 
*** identifiers into quoted identifiers.

  op flatModule : Module -> Module .
  eq flatModule(unitError(QIL)) = unitError(QIL) .
  eq flatModule(U)
    = if U :: FModule or U :: FTheory
      then (fmod header2Qid(getName(U)) is
               getImports(U)
               sorts getSorts(U) .
               getSubsorts(U)
               getOps(U)
               getMbs(U)
               getEqs(U)
            endfm)
      else (mod header2Qid(getName(U)) is
               getImports(U)
               sorts getSorts(U) .
               getSubsorts(U)
               getOps(U)
               getMbs(U)
               getEqs(U)
               getRls(U)
            endm)
      fi 
    [owise] .

  op convertModuleExpressions : ImportList -> ImportList .
  eq convertModuleExpressions(((protecting ME * (MAPS) .) IL)) 
    = (protecting ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(((extending ME * (MAPS) .) IL)) 
    = (extending ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(((including ME * (MAPS) .) IL)) 
    = (including ME * (renamings(MAPS)) .) convertModuleExpressions(IL) .
  eq convertModuleExpressions(I IL) = I convertModuleExpressions(IL) [owise] .
  eq convertModuleExpressions(nil) = nil .  
  
  op renamings : RenamingSet -> RenamingSet .
  eq renamings(op F to F' [AtS]) = op F to F' [AtS] .
  eq renamings((op F to F' [AtS], MAPS)) 
    = (op F to F' [AtS], renamings(MAPS)) 
    [owise] .
  eq renamings(op F : TyL -> Ty to F' [AtS]) 
    = op F : TyL -> Ty to F' [AtS] .
  eq renamings((op F : TyL -> Ty to F' [AtS], MAPS)) 
    = (op F : TyL -> Ty to F' [AtS], 
       renamings(MAPS)) 
    [owise] .
  eq renamings(sort S to S') = sort S to S' .
  eq renamings(((sort S to S'), MAPS)) 
    = ((sort S to S'), renamings(MAPS)) 
    [owise] .
  eq renamings(label L to L') = label L to L' .
  eq renamings(((label L to L'), MAPS)) 
    = ((label L to L'), renamings(MAPS)) 
    [owise] .
  eq renamings((MAP, MAPS)) = renamings(MAPS) [owise] .
  eq renamings(none) = none .

*** The evaluation process for units without bubbles is as follows. After 
*** normalizing the structure, the function \texttt{evalModule} calls
*** \texttt{evalModule1} with an empty copy of the module to which the list of
*** declarations of importations of built-in modules is added, and with the
*** list of its nonbuilt-in subunits.

*** \texttt{evalModule1} accumulates all the declarations in all the 
*** nonbuilt-insubmodules in the copy of the module passed as second argument. 
*** The top module is then introduced in the database, and, after calling the
*** \texttt{transform} function and renaming all the variables in it, the 
*** internal version of such a module is entered in the database as well.

*** Finally, \texttt{evalModule2} generates the signature and the flat version
*** of the module and enters them in the database.

  *** op evalModule : Module Database -> Database .
  ***  moved to MOD-EXPR-EVAL to solve dependency
  op evalModule1 : Module Module List<Module> OpDeclSet Database -> Database .
  op evalModule2 : Module Module Database -> Database .

  ceq evalModule(U, VDS, DB)
    = evalModule1(setPars(setImports(U, IL), PDL), empty(U), 
        getModules(IL', DB'), VDS, DB') 
    if < IL ; PDL ; DB' > := normalize(getImports(U), getPars(U), DB)
    /\ IL' := subunitImports(PDL, IL, DB') .
   eq evalModule(U, VDS, DB) = DB [owise] .

  eq evalModule1(U, U', (U'' UL), VDS, DB)
    = evalModule1(U, addDecls(U', setImports(U'', nil)), UL, VDS, DB) .
  eq evalModule1(U, U', nil, VDS, DB) 
    = evalModule2(
        setImports(transform(U, DB), nil), 
        U', 
        insertVars(getName(U), VDS,
          insertInternalModule(getName(U), transform(U, DB), 
            insertTopModule(getName(U), U, DB)))) .
  eq evalModule1(U, U', unitError(QIL), VDS, DB) = warning(DB, QIL) .

  eq evalModule2(U, U', DB)
    = insertFlatModule(getName(U), flatModule(addDecls(U, U')), DB) .
  eq evalModule2(unitError(QIL), U, DB) = warning(DB, QIL) .

*** The function \texttt{evalPreModule} has to take care of the bubbles in the
*** unit. As we explained in Section~\ref{evaluation-overview}, both the
*** signature and the flattened version of the module are created
*** simultaneously, completing the parsing of the bubbles once the signature 
*** has been built, and then completing the flattened module.

*** The \texttt{evalPreModule} function takes as arguments two copies of the
*** module and a database. We shall see in Section~\ref{unit-processing} how
*** these two modules are generated; the one passed as first argument has
*** still bubbles in it, while the other one, which will be used to build the
*** signature, does not contain any bubbles. This module without bubbles is
*** the result of removing the bubbles from the declarations in it, or of 
*** removing the declarations themselves when they contain bubbles, as in the 
*** case of equations, for example.

*** The \texttt{evalPreModule} function is quite similar to the function
*** \texttt{evalModule}. First, the structure is normalized by calling the
*** \texttt{normalize} function, and then all the subunits in the
*** structure are collected (accomplished by \texttt{subunitImports} and
*** \texttt{getModules}) and the list of importations is updated
*** with the sublist of importations of built-in
*** modules (\texttt{selectBuiltInImports}). Second, the structure of all the
*** subunits below the top is flattened to a single unit. This unit is used to
*** create a first version of the signature (without identity elements of
*** operators) in which all the bubbles in the top preunit are
*** parsed (\texttt{solveBubbles}). The final version of the signature and 
*** the flat unit are generated once the bubbles have been parsed. The 
*** `internal' version of the module is also generated by renaming the 
*** variables in it (\texttt{renameVars}). All these versions of the module 
*** are finally entered in the database.

*** Note that if the \texttt{META-LEVEL} module is imported in the module
*** being evaluated, a declaration importing the predefined module
*** \texttt{UP} Section~\ref{non-built-in-predefined}) is added. With the
*** declarations in this module it will be possible to parse bubbles 
*** containing calls to the \texttt{up} functions (see 
*** Section~\ref{structured-specifications}) in them.

  op evalPreModule : Module Module OpDeclSet Database -> Database .
  op evalPreModule1 : 
       Module Module List<Module> Module OpDeclSet Database -> Database .
  op evalPreModule2 : Module Module Module OpDeclSet Database -> Database .
  op evalPreModule3 : Module Module Module Database -> Database .

  *** evalPreModule just calls evalPreModule1 with a set of the units in the 
  *** structure of the given module. Depending on whether the module is 
  *** importing META-LEVEL or not UP will be added. BOOL will be added if
  *** the include BOOL flag is set and the module doesn't include it already.

  ceq evalPreModule(PU, U, VDS, DB)
    *** PU  : top unit with bubbles (preunit)
    *** U   : top unit without bubbles (decls with bubbles were removed)
    *** VDS : ops corresponding to the vbles in the top unit 
    = evalPreModule1(
        setPars(setImports(PU, IL'), PDL'), 
        setName(empty(U), getName(U)),
        getModules(IL'', DB'), 
        setImports(U, nil), 
        VDS, 
        DB') 
    if IL := getImports(PU) 
    /\ PDL := getPars(PU)
    /\ < IL' ; PDL' ; DB' > := normalize(defImports(PU, DB) IL, PDL, DB)
    /\ IL'' := subunitImports(PDL, IL', DB') .
  eq evalPreModule(PU, U, VDS, DB) = DB [owise] .

  *** evalPreModule1 joins all the units in the structure into a single unit,
  *** the one given as second argument; recall that the fourth one is the
  *** top module without bubbles but with the complete list of subunits
  *** being imported explicitly

  eq evalPreModule1(PU, U, (U' UL), U'', VDS, DB)
    = evalPreModule1(PU, addDecls(U, U'), UL, U'', VDS, DB) .
  eq evalPreModule1(PU, U, nil, U', VDS, DB) 
    = evalPreModule2(PU, U, signature(transform(addDecls(U', setImports(U, nil)), DB)), VDS, DB)
    [owise] . 
  eq evalPreModule1(PU, unitError(QIL), UL, U', VDS, DB) = warning(DB, QIL) .
  eq evalPreModule1(unitError(QIL), U, UL, U', VDS, DB) = warning(DB, QIL) .
  eq evalPreModule1(PU, U, unitError(QIL), U', VDS, DB) = warning(DB, QIL) .

  eq evalPreModule2(PU, U, M, VDS, DB)
    *** PU : top module with bubbles
    *** U  : everything below
    *** M  : complete signature
    = evalPreModule3(
        solveBubblesMod(PU, getOps(U), M, 
          included('META-MODULE, getImports(PU), DB), VDS, DB),
        U, M, 
        insertVars(getName(PU), VDS, 
          insertTopModule(getName(PU), 
            solveBubblesMod(PU, getOps(U), M, 
              included('META-MODULE, getImports(PU), DB), VDS, DB), DB))) .

  eq evalPreModule3(PU, U, M, DB)
    *** PU : top module without bubbles
    *** U  : everything below
    *** M  : complete signature 
    = insertFlatModule(getName(PU),
        flatModule(setImports(transform(addDecls(PU, U), DB), nil)),
        insertInternalModule(getName(PU), transform(PU, DB), DB)) .
  eq evalPreModule3(unitError(QIL), U, M, DB) = warning(DB, QIL) .
endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** Note that in both \texttt{evalModule} and \texttt{evalPreModule}, the function
*** \texttt{transform} has to be invoked to transform the module into a
*** functional or system module. In the current system, the only 
*** transformation available is from object-oriented modules to system modules.

***
*** 6.8 Application of Map STS
***

*** The following two modules deal with the application of a set of renaming
*** maps to a module. Except for the proof obligations and additional checks
*** associated with views---almost none of these checks are performed, and
*** none of these proof obligations is generated in the current version---the
*** way of applying a renaming map and a view map on a module is the same.
*** Internally, they are treated in the same way; the only difference between 
*** them consists in the way of calling the function to accomplish this 
*** application.

*** Note that there might be some `interference' between sort maps, and
*** operator maps and message maps when they are applied. Let us consider for 
*** example a module with an operator declaration
*** 
***  op f : Foo -> Foo .
***
*** and a renaming map set 
***
***  (sort Foo to Bar, op f : Foo -> Foo to g)
***
*** These renamings have to be applied carefully to avoid unintended behaviors.
*** Depending on which of the maps is applied first, the other will be
*** applicable or not.  All the maps must be applied to the original module. 
*** To avoid the interference between the sort maps and other maps, the map set
*** is divided into two sTS: The first one contains the sort maps, and the 
*** second one contains the other maps.

*** We assume that there are no ambiguous mappings, that is, that we do not
*** have, for example, maps \verb~op f to g~ and \verb~op f to h~. In case of
*** such ambiguity, one of the maps will be arbitrarily chosen.

***
*** 6.8.1 Map STS on Terms
***

*** The application of a set of view maps to a term is defined in the following
*** module \texttt{RENAMING-SET-APPL-ON-TERM}. The function
*** \texttt{applyMapsToTerm} is used to apply a given view map set to terms
*** appearing in equations, rules, identity element declarations, and 
*** membership axioms, as part of the process of applying a map set to a unit.

*** Some of the auxiliary functions introduced in this module will also be used
*** in the application of maps to operator and message declarations in the 
*** \texttt{RENAMING-SET-APPL-ON-UNIT} module.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod RENAMING-SET-APPL-ON-TERM is
  pr UNIT .
  pr FMAP .
  pr EXT-SORT .

  var  R : Renaming .
  vars RS RS' RS'' SRS ORS : RenamingSet .
  var  M : Module .
  vars F F' F'' A A' A'' : Qid .
  vars T T' T'' O : Term .
  vars TL TL' TL'' TL3 : TermList .
  vars S S' S'' C C' C'' : Sort .
  var  SS : SortSet .
  var  K : Kind .
  vars TyL TyL' : TypeList .
  vars Ty Ty' : Type .
  vars Subst Subst' Subst'' : Substitution .
  var  AtS : AttrSet .
  var  OPDS : OpDeclSet .
  vars V V' : Variable .
  vars Ct Ct' : Constant .
  var  QIL : QidList .
  var  Cd : Condition .

*** The following functions \texttt{applyMapsToSort} and
*** \texttt{applyMapsToClassSort} apply a set of maps, respectively, to a
*** sort a to a class name in its single identifier form, that is, when they
*** appear qualifying constants. Functions \texttt{applyMapsToType} and
*** \texttt{applyMapsToClassName} are similar but being applied to sort or 
*** class names in their normal form.

  op applyMapsToSort : RenamingSet Sort -> Sort .
  eq applyMapsToSort((sort S to S'), S) = S' .
  eq applyMapsToSort((sort S to S'), S'') = S'' [owise] .
  eq applyMapsToSort(((sort S to S'), SRS), S) = S' .
  eq applyMapsToSort(((sort S to S'), SRS), S'') 
    = applyMapsToSort(SRS, S'')  
    [owise] .
  eq applyMapsToSort(R, S) = S [owise].
  eq applyMapsToSort((R, SRS), S) = applyMapsToSort(SRS, S) [owise].
  eq applyMapsToSort(none, S) = S .

  op applyMapsToSortSet : RenamingSet SortSet -> SortSet .
  eq applyMapsToSortSet(SRS, (S ; SS)) 
    = (applyMapsToType(SRS, S) ; applyMapsToSortSet(SRS, SS)) .
  eq applyMapsToSortSet(SRS, none) = none .

  op applyMapsToType : RenamingSet Type -> Type .
  eq applyMapsToType((sort S to S'), S) = S' .
  eq applyMapsToType(((sort S to S'), SRS), S) = S' .
  eq applyMapsToType((sort S to S'), K)
    = qid("[" + string(applyMapsToType(sort S to S', getSort(K))) + "]") .
  eq applyMapsToType(((sort S to S'), SRS), K)
    = qid("[" 
       + string(applyMapsToType(((sort S to S'), SRS), getSort(K))) 
       + "]") .
  eq applyMapsToType(SRS, Ty) = Ty [owise] .

  op applyMapsToClassName : RenamingSet Sort -> Sort .
  eq applyMapsToClassName((class C to C'), C) = C' .
  eq applyMapsToClassName(((class C to C'), SRS), C) = C' .
  eq applyMapsToClassName(SRS, C) = C [owise] .

*** \texttt{applyOpMapsToOpId} applies a map set to an operator name.

  op applyOpMapsToOpId : Qid RenamingSet -> Qid .
  eq applyOpMapsToOpId(F, (op F to F' [AtS])) = F' .
  eq applyOpMapsToOpId(F, (op F : TyL -> Ty to F' [AtS])) = F' .
  eq applyOpMapsToOpId(F, RS) = F [owise] .

*** Note that all maps introduced in Sections~\ref{renaming-maps}
*** and~\ref{view-maps}, except for label maps, may affect a term. For example,
*** sort maps will be applied to the qualifications of terms, and class and
*** attribute maps have to be applied to the objects appearing in the term.
*** Operator and message maps in which an explicit arity and coarity is given,
*** and operator maps going to derived operators (see Section~\ref{Views}) 
*** must be applied to the complete family of subsort-overloaded operators.

*** The function \texttt{applyMapsToTerm} takes as arguments two sTS of
*** view maps (the first set for sort maps, and the second for the other maps),
*** the term to which the maps will be applied, and a module to be used in the
*** matching of terms, sort comparisons, etc. Its declaration is as follows.

  op applyMapsToTerm2 : RenamingSet RenamingSet Term Module -> Term .

*** If the term on which the maps have to be applied is not an object,
*** different cases have to be considered for each of the possible forms of a
*** term. If it is a variable or \texttt{error*}, the same term is returned
*** without change (term maps are a special case for this). If it is a sort
*** test or a lazy sort test, with forms \verb~T : S~ and \verb~T :: S~,
*** respectively, the maps are applied to the term \texttt{T} and to the sort
*** \texttt{S}.  In case of being of forms \verb~F.S~ or \verb~F[TL]~ with
*** \texttt{F} an operator name, \texttt{S} a sort, and \texttt{TL} a list of
*** terms, the function \texttt{getRightOpMaps} will return the subset of
*** maps which are applicable on such term. If \texttt{none} is returned then
*** no map is applicable. If more than one map is returned then there is an
*** ambiguity, and any of them will be arbitrarily taken. The function 
*** \texttt{imagTerm} is called with the term and the maps applicable on 
*** it and return the image of the term. In case of a term of the form 
*** \texttt{F[TL]}, \texttt{imageOfTerm} will make recursive calls with the 
*** arguments in \texttt{TL}.

*** The application of a term map to a term requires the `matching' of the
*** source term in the map with the term on which the map is applied, and then
*** the application of the obtained substitution. Note, however, that a
*** complete matching algorithm is not required. Given the form of the pattern
*** we can choose beforehand the appropriate map, that is, we know that in
*** fact there is a match when the function is called. Note also that the map
*** has to be applied to the whole family of subsort overloaded operators. We
*** just have to check that the sort of the given variable and the
*** corresponding term are in the same connected component of sorts.  In
*** addition to getting the appropriate substitution, the only thing we need
*** to check is that there are no variables with different assignments, that 
*** is, that in case of having a nonlinear pattern, the terms being assigned 
*** to each variable are equal. We call \texttt{pseudoMatch} to the function 
*** doing this task.

  op applyMapsToTerm2 : RenamingSet RenamingSet TermList Module -> TermList .

  op imageOfTerm : RenamingSet RenamingSet Term RenamingSet Module -> Term .
  op applyMapsToSubst : RenamingSet RenamingSet Substitution Module -> Substitution .
  op pseudoMatch : TermList TermList Module Substitution -> Substitution .
  op pseudoMatch2 : TermList TermList Module Substitution -> Substitution .
  op pseudoMatchResult : Substitution -> Substitution .
  op pseudoMatchResult : Substitution Assignment Substitution Substitution -> Substitution .

  op getRightOpMaps : Qid TypeList Type RenamingSet Module -> RenamingSet .
  op applyMapsToObjectAttrSet : RenamingSet RenamingSet Sort Term Module -> Term .
  op applyMapsToAttrNameInTerm : RenamingSet Sort Qid Module -> Qid .

  eq applyMapsToTerm2(SRS, ORS, Ct, M) 
    = imageOfTerm(SRS, ORS, Ct, 
        getRightOpMaps(getName(Ct), nil, getType(Ct), ORS, M), M) .
  eq applyMapsToTerm2(SRS, ORS, V, M) 
    = qid(string(getName(V)) + ":" 
          + string(applyMapsToType(SRS, getType(V)))) .
  eq applyMapsToTerm2(SRS, ORS, qidError(QIL), M) = qidError(QIL) .
  eq applyMapsToTerm2(SRS, ORS, F[TL], M) 
    = imageOfTerm(SRS, ORS, F[TL], 
        getRightOpMaps(F, eLeastSort(M, TL), leastSort(M, F[TL]), ORS, M), 
        M)
    [owise] .
    ---- if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq applyMapsToTerm2(SRS, ORS, '<_:_|_>[O, Ct, T], M) 
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M), 
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                  + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               applyMapsToObjectAttrSet(SRS, ORS, getName(Ct), T, M)].
  ceq applyMapsToTerm2(SRS, ORS, '<_:_|_>[O, C, T], M) 
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M), 
               applyMapsToClassName(SRS, C), 
               applyMapsToObjectAttrSet(SRS, ORS, C, T, M)] 
    if not C :: Constant .
  eq applyMapsToTerm2(SRS, ORS, '<_:_|`>[O, Ct], M) 
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M), 
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                 + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               'none.AttributeSet] .
  ceq applyMapsToTerm2(SRS, ORS, '<_:_|`>[O, C], M) 
    = '<_:_|_>[applyMapsToTerm2(SRS, ORS, O, M), 
         applyMapsToClassName(SRS, C), 'none.AttributeSet] 
    if not C :: Constant .
  ceq applyMapsToTerm2(SRS, ORS, F[TL], M)
    = qid("_::`" + string(applyMapsToType(SRS, qid(substr(string(F), 4, length(string(F))))))) [
        applyMapsToTerm2(SRS, ORS, TL, M)]
    if substr(string(F), 0, 4) == "_::`" .
----    /\ substr(string(F), sd(length(string(F)), 2), 2) = "`}" .
    
  ceq applyMapsToTerm2(SRS, ORS, (T, TL), M) 
    = (applyMapsToTerm2(SRS, ORS, T, M), 
       applyMapsToTerm2(SRS, ORS, TL, M)) 
    if TL =/= empty .

*** Application of a map set to the name of an attribute in an object

  eq applyMapsToAttrNameInTerm((attr A . S to A'), C, A'', M)
    = if sameKind(M, S, C) and-then (qid(string(A) + "`:_") == A'')
      then qid(string(A') + "`:_")
      else A''
      fi .
  eq applyMapsToAttrNameInTerm(((attr A . S to A'), ORS), C, A'', M)
    = if sameKind(M, S, C) and-then (qid(string(A) + "`:_") == A'')
      then qid(string(A') + "`:_")
      else applyMapsToAttrNameInTerm(ORS, C, A'', M)
      fi .
  eq applyMapsToAttrNameInTerm(R, C, A, M) = A [owise] .
  eq applyMapsToAttrNameInTerm((R, ORS), C, A, M)
    = applyMapsToAttrNameInTerm(ORS, C, A, M)
    [owise] .
  eq applyMapsToAttrNameInTerm(none, S, A, M) = A .

*** Selection of all the operator or message maps that are applicable on an
*** operator with a given arity and coarity.

  eq getRightOpMaps(F, TyL, Ty, (msg F' to F''), M)
    = getRightOpMaps(F, TyL, Ty, (op F' to F'' [none]), M) .
  eq getRightOpMaps(F, TyL, Ty, ((msg F' to F''), RS), M)
    = getRightOpMaps(F, TyL, Ty, ((op F' to F'' [none]), RS), M) .
  eq getRightOpMaps(F, TyL, Ty, (msg F' : TyL' -> Ty' to F''), M)
    = getRightOpMaps(F, TyL, Ty, op F' : TyL' -> Ty' to F'' [none], M) .
  eq getRightOpMaps(F, TyL, Ty, ((msg F' : TyL' -> Ty' to F''), RS), M)
    = getRightOpMaps(F, TyL, Ty,
        (op F' : TyL' -> Ty' to F'' [none], RS), M) .
  eq getRightOpMaps(F, TyL, Ty, (op F to F' [AtS]), M) = (op F to F' [AtS]) .
  eq getRightOpMaps(F, TyL, Ty, (op F to F' [AtS], RS), M)
    = (op F to F' [AtS], getRightOpMaps(F, TyL, Ty, RS, M)) .
  eq getRightOpMaps(F, TyL, Ty, op F : TyL' -> Ty' to F' [AtS], M)
    = if (size(TyL') == 2 and-then (sameKindAll(M, Ty', TyL) and-then assoc in attrs2SameKind(F, TyL, M)))
         or-else
         sameKind(M, TyL Ty, TyL' Ty') 
      then (op F : TyL' -> Ty' to F' [AtS])
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op F : TyL' -> Ty' to F' [AtS], RS), M)
    = if (size(TyL') == 2 and-then (sameKindAll(M, Ty', TyL) and-then assoc in attrs2SameKind(F, TyL, M)))
         or-else
         sameKind(M, TyL Ty, TyL' Ty') 
      then (op F : TyL' -> Ty' to F' [AtS], 
            getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M)
      fi .
  eq getRightOpMaps(F, TyL, Ty, op_to`term_(F[TL], T), M)
    = if sameKind(M, TyL, varListSort(TL))
      then (op_to`term_(F[TL], T))
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(F[TL], T), RS), M)
    = if sameKind(M, TyL, varListSort(TL))
      then (op_to`term_(F[TL], T), getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M) 
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(Ct, T)), M)
    = if TyL == nil 
         and-then (F == getName(Ct) 
         and-then sameKind(M, Ty, getType(Ct)))
      then (op_to`term_(Ct, T))
      else none
      fi .
  eq getRightOpMaps(F, TyL, Ty, (op_to`term_(Ct, T), RS), M)
    = if TyL == nil 
         and-then (F == getName(Ct) 
         and-then sameKind(M, Ty, getType(Ct)))
      then (op_to`term_(Ct, T), getRightOpMaps(F, TyL, Ty, RS, M))
      else getRightOpMaps(F, TyL, Ty, RS, M) 
      fi .
  eq getRightOpMaps(F, TyL:[Type], Ty:[Type], RS, M) = none [owise].

  op varListSort : TermList -> TypeList .
  eq varListSort((V, TL)) = (getType(V) varListSort(TL)) .
  eq varListSort(empty) = nil .

  op attrs2SameKind : Qid TypeList Module -> AttrSet .
  op attrs2SameKind : Qid TypeList OpDeclSet Module -> AttrSet .
  eq attrs2SameKind(F, Ty Ty' TyL, M) = attrs2SameKind(F, Ty Ty', getOps(M), M) .
 ceq attrs2SameKind(F, TyL, op F : TyL' -> Ty' [AtS] . OPDS, M) ---- all subsort overloaded operators have the same equational attributes 
    = AtS
    if sameKind(M, TyL, TyL') .
  eq attrs2SameKind(F, TyL, OPDS, M) = none [owise] .
  
*** Application of a map set to the set of attributes in an object

  eq applyMapsToObjectAttrSet(RS, RS', C, '_`,_[A[T], TL], M)
    = '_`,_[applyMapsToAttrNameInTerm(RS', C, A, M)
              [applyMapsToTerm2(RS, RS', T, M)], 
            applyMapsToObjectAttrSet(RS, RS', C, TL, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C, A[T], M)
    = applyMapsToAttrNameInTerm(RS', C, A, M) 
        [applyMapsToTerm2(RS, RS', T, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C, 
       '_`,_['none.AttributeSet, TL], M)
    = '_`,_['none.AttributeSet, 
            applyMapsToObjectAttrSet(RS, RS', C, TL, M)] .
  eq applyMapsToObjectAttrSet(RS, RS', C, 'none.AttributeSet, M) 
    = 'none.AttributeSet .

*** Image of a term 

  eq imageOfTerm(RS, RS', Ct, none, M)
    = qid(string(getName(Ct)) + "." 
          + string(applyMapsToType(RS, getType(Ct)))) .
  eq imageOfTerm(RS, RS', F[TL], none, M)
    = F [ applyMapsToTerm2(RS, RS', TL, M) ] .

  eq imageOfTerm(RS, RS', F[TL], (op F to F' [AtS]), M) 
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], ((op F to F' [AtS]), RS''), M) 
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], (op F : TyL -> Ty to F'[AtS]), M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', F[TL], (op F : TyL -> Ty to F'[AtS], RS''),M)
    = F' [ applyMapsToTerm2(RS, RS', TL, M) ] .
  eq imageOfTerm(RS, RS', T, op_to`term_(T', T''), M) 
    = applySubst(T'', 
        applyMapsToSubst(RS, RS', pseudoMatch(T', T, M, none), M)) .
  eq imageOfTerm(RS, RS', T, (op_to`term_(T', T''), RS''), M) 
    = applySubst(T'', 
        applyMapsToSubst(RS, RS', pseudoMatch(T', T, M, none), M)) .
  ceq imageOfTerm(RS, RS', Ct, (op F to F' [AtS]), M) 
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct)))) 
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, ((op F to F' [AtS]), RS''), M) 
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct)))) 
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, (op F : TyL -> Ty to F' [AtS]), M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .
  ceq imageOfTerm(RS, RS', Ct, (op F : TyL -> Ty to F' [AtS], RS''),M)
    = qid(string(F') + "." + string(applyMapsToType(RS, getType(Ct))))
    if getName(Ct) = F .

*** Application of a Substitution on a term

  op applySubst : TermList Substitution -> TermList .
  eq applySubst(T, none) = T .
  eq applySubst(V, ((V' <- T) ; Subst))
    = if getName(V) == getName(V')
      then T
      else applySubst(V, Subst)
      fi .
  eq applySubst(F[TL], Subst) = F[applySubst(TL, Subst)] .
  eq applySubst(Ct, Subst) = Ct .
  ceq applySubst((T, TL), Subst) 
    = (applySubst(T, Subst), applySubst(TL,Subst))
    if TL =/= empty .

*** Application of a Substitution to a condition

  op applySubst : Condition Substitution -> Condition .
  eq applySubst(T = T' /\ Cd, Subst) 
    = (applySubst(T, Subst) = applySubst(T', Subst)) /\ applySubst(Cd, Subst) .
  eq applySubst(T => T' /\ Cd, Subst) 
    = (applySubst(T, Subst) => applySubst(T', Subst)) /\ applySubst(Cd, Subst) .
  eq applySubst(T : S /\ Cd, Subst) 
    = (applySubst(T, Subst) : S) /\ applySubst(Cd, Subst) .
  eq applySubst((nil).EqCondition, Subst) = nil .

*** PseudoMatch

  eq pseudoMatch(T, T', M, Subst) 
    = pseudoMatchResult(pseudoMatch2(T, T', M, Subst)) .

  eq pseudoMatch2(Ct, Ct', M, Subst) = none .
  eq pseudoMatch2(F[TL], F'[TL'], M, Subst) 
    = if F == F'
      then pseudoMatch2(TL, TL', M, Subst)
      else none 
      fi .
  eq pseudoMatch2((V, TL), (T, TL'), M, Subst) 
    = if sameKind(M, getType(V), leastSort(M, T))
      then pseudoMatch2(TL, TL', M, (V <- T ; Subst)) 
      else none
      fi .
  eq pseudoMatch2(V, T, M, Subst) 
    = if sameKind(M, getType(V), leastSort(M, T))
      then (V <- T ; Subst) 
      else none
      fi .

  eq pseudoMatch2((V, TL), (T, TL'), M, Subst) 
    = if sameKind(M, getType(V), leastSort(M, T))
      then pseudoMatch2(TL, TL', M, (V <- T ; Subst)) 
      else none
      fi .
  eq pseudoMatch2((Ct, TL), (Ct', TL'), M, Subst) 
    = if getName(Ct) == getName(Ct')
      then pseudoMatch2(TL, TL', M, Subst) 
      else none
      fi .
  eq pseudoMatch2((F[TL], TL'), (F'[TL''], TL3), M, Subst) 
    = if F == F'
      then pseudoMatch2(TL', TL3, M, pseudoMatch2(TL, TL'', M, none) ; Subst)
      else none 
      fi .
  eq pseudoMatch2(empty, empty, M, Subst) = Subst .

  *** pseudoMatchResult detects conflicts and eliminates duplicates

  eq pseudoMatchResult((V <- T) ; Subst)
    = pseudoMatchResult(none, (V <- T), none, Subst) .
  eq pseudoMatchResult(none) = none .

  eq pseudoMatchResult(Subst, (V <- T), Subst', (V' <- T') ; Subst'')
    = if V == V' 
      then if T == T' 
           then pseudoMatchResult(Subst, (V <- T), Subst', Subst'')
           else none
           fi
      else pseudoMatchResult(Subst, (V <- T), Subst' ; (V' <- T'), Subst'')
      fi .
  eq pseudoMatchResult(Subst, (V <- T), (V' <- T') ; Subst', none)
    = pseudoMatchResult(Subst ; (V <- T), (V' <- T'), none, Subst') .
  eq pseudoMatchResult(Subst, (V <- T), none, none) = (Subst ; (V <- T)) .

*** Application of a set of maps to a substitution

  eq applyMapsToSubst(RS, RS', ((V <- T) ; Subst), M)
    = ((applyMapsToTerm2(RS, RS', V, M) <- applyMapsToTerm2(RS, RS', T, M)) ; 
       applyMapsToSubst(RS, RS', Subst, M)) .
  eq applyMapsToSubst(RS, RS', none, M) = none .

endfm

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

*** We do not include here the equations defining the semantics of the function
*** \texttt{applyMapsToTerm}. Instead, we present an example illustrating
*** the meaning of the function. Renaming maps and view maps were already
*** discussed in Sections~\ref{Views} and~\ref{module-expressions}.

*** Let us consider the following configuration in the module
*** \texttt{STACK2[Accnt]} presented in Section~\ref{module-expressions}. In
*** this configuration we have objects in the class \texttt{Accnt} which
*** represent the accounts of different clients of a bank, which is
*** represented as an object \texttt{'bank} of class \texttt{Stack[Accnt]}.
*** The object \texttt{'bank} in the example configuration below keeps a stack 
*** with the accounts of the bank represented as a linked list of nodes, each 
*** of which corresponds to the account of one of the clients.

***   ('bank push 'john) 
***   ('peter elt 2000) 
***   < 'bank : Stack[Accnt] | first : o ('bank, 1) > 
***   < 'paul : Accnt | bal : 5000 > 
***   < 'peter : Accnt | bal : 2000 > 
***   < 'mary : Accnt | bal : 7200 > 
***   < 'john : Accnt | bal : 100 > 
***   < o('bank, 0) : Node[Accnt] | node : 'peter, next : null > 
***   < o('bank, 1) : Node[Accnt] | node : 'mary, next : o('bank, 0) > .
***
*** Let us apply the following renaming to the previous term. 
*** 
***   (op o to id, 
***    class Stack[Accnt] to Bank,
***    msg _push_ : Oid Oid -> Msg to open`account`in_to_,
***    msg _pop to close`account`of_,
***    msg _elt_ to _owns_dollars,
***    attr node . Node[Accnt] to client,
***    attr bal . Accnt to balance)
***
*** The resulting term is as follows.
*** 
***   (open account in 'bank to 'john) 
***   ('peter owns 2000 dollars) 
***   < 'bank : Bank | first : id('bank, 1) > 
***   < 'paul : Accnt | balance : 5000 > 
***   < 'peter : Accnt | balance : 2000 > 
***   < 'mary : Accnt | balance : 7200 > 
***   < 'john : Accnt | balance : 100 > 
***   < id('bank, 0) : Node[Accnt] | client : 'peter, next : null > 
***   < id('bank, 1) : Node[Accnt] | client : 'mary, next : id('bank, 0) >

*** The function \texttt{applyMapsToTerm} treats the object constructor
*** \verb~<_:_|_>~ in a special way. It cannot be renamed, and, when an
*** occurrence of such a constructor is found, class and attribute maps require
*** a particular handling. Inside terms these maps are only triggered when
*** this constructor is found, and they are applied in a very restricted way,
*** according to the general pattern for objects.  We assume that the operator 
*** \verb~<_:_|_>~ is only used for objects and that objects constructed using 
*** it are well-formed.

***
*** 6.8.2 Map STS on Modules
***

*** The application of view maps to modules and theories of the different types
*** is defined in the following module \texttt{RENAMING-SET-APPL-ON-UNIT}. The
*** function \texttt{applyMapsToModule} is defined recursively by applying it
*** to the different components of a unit. When the terms in the different
*** declarations are reached, the function \texttt{applyMapsToTerm} is 
*** called. This call is made with the set of maps split conveniently, as 
*** explained above.

-------------------------------------------------------------------------------
*******************************************************************************
-------------------------------------------------------------------------------

fmod RENAMING-SET-APPL-ON-UNIT is
  pr RENAMING-SET-APPL-ON-TERM .
  pr INT-LIST .
  pr VIEW-EXPR .

  op applyMapsToModule : RenamingSet Module Module -> Module .
  op applyMapsToModuleAux : RenamingSet RenamingSet Module Module -> Module .
  op splitMaps : RenamingSet -> Tuple{RenamingSet,RenamingSet} .
  op splitMapsAux : RenamingSet RenamingSet RenamingSet 
       -> Tuple{RenamingSet,RenamingSet} .

  op applyMapsToTypeList : RenamingSet TypeList -> TypeList .
  op applyMapsToSubsorts : RenamingSet SubsortDeclSet -> SubsortDeclSet .
  op applyMapsToOps : RenamingSet RenamingSet OpDeclSet Module -> OpDeclSet .
  op applyMapsToOp : RenamingSet RenamingSet RenamingSet OpDecl Module -> OpDecl .
  op applyMapsToAttrs : RenamingSet RenamingSet AttrSet Module -> AttrSet .
  op applyMapToAttrs : Renaming AttrSet -> AttrSet .
  op applyMapToAttrsAux : AttrSet AttrSet AttrSet -> AttrSet .
  op applyMapsToHooks : RenamingSet RenamingSet HookList Module -> HookList .
  op applyMapsToHooksAux : RenamingSet RenamingSet Hook Module -> Hook .
  op applyMapsToMbs : RenamingSet RenamingSet MembAxSet Module -> MembAxSet .
  op applyMapsToEqs : RenamingSet RenamingSet EquationSet Module -> EquationSet .
  op applyMapsToRls : RenamingSet RenamingSet RuleSet Module -> RuleSet .
  op applyMapsToCond : RenamingSet RenamingSet Condition Module -> Condition .
  op applyMapsToLabel : RenamingSet Qid -> Qid .
  op applyMapsToClassDeclSet : RenamingSet RenamingSet ClassDeclSet -> ClassDeclSet .
  op applyMapsToSubclassDeclSet : RenamingSet SubclassDeclSet -> SubclassDeclSet .
  op applyMapsToMsgDeclSet : RenamingSet RenamingSet MsgDeclSet Module -> MsgDeclSet .
  op applyMapsToMsgDecl : RenamingSet RenamingSet MsgDecl Module -> MsgDecl .
  op applyMapsToAttrName : RenamingSet Sort Qid -> Qid .
  op applyMapsToAttrDeclSet : RenamingSet RenamingSet Sort AttrDeclSet -> AttrDeclSet .

  vars M U : Module .
  vars QI QI' QI'' L L' L'' F F' F'' A A' A'' : Qid .
  vars V V' : Variable .
  vars QIL QIL' : QidList .
  var  VE : ViewExp .
  var  H : Header .
  var  ME : ModuleExpression .
  var  PDL : ParameterDeclList .
  var  IL : ImportList .
  vars S S' S'' C C' C'' : Sort .
  var  Ty : Type .
  vars TyL TyL' : TypeList .
  var  SS : SortSet .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  ADS : AttrDeclSet .
  vars T T' T'' T3 O : Term .
  vars TL TL' : TermList .
  var  At : Attr .
  vars AtS AtS' AtS'' : AttrSet . 
  vars I I' : Nat .
  vars NL NL' : IntList .
  var  Hk : Hook .
  var  HkL : HookList .
  var  R : Renaming .
  vars RS RS' RS'' SRS ORS : RenamingSet .
  var  Subst : Substitution .
  var  Cond : Condition .
  var  St : String .
  var  MN : ModuleName .

  sort Tuple{RenamingSet,RenamingSet} .
  op <_;_> : RenamingSet RenamingSet -> Tuple{RenamingSet, RenamingSet} .
  ops sortMaps otherMaps : Tuple{RenamingSet, RenamingSet} -> RenamingSet .
  eq sortMaps(< RS ; RS' >) = RS .
  eq otherMaps(< RS ; RS' >) = RS' .

  eq splitMaps(RS) = splitMapsAux(RS, none, none) .
  eq splitMapsAux((sort S to S'), RS', RS'') 
    = splitMapsAux(none, ((sort S to S'), RS'), RS'') .
  eq splitMapsAux(((sort S to S'), RS), RS', RS'') 
    = splitMapsAux(RS, ((sort S to S'), RS'), RS'') .
  eq splitMapsAux((class S to S'), RS', RS'') 
    = splitMapsAux(none, ((class S to S'), RS'), RS'') .
  eq splitMapsAux(((class S to S'), RS), RS', RS'') 
    = splitMapsAux(RS, ((class S to S'), RS'), RS'') .
  eq splitMapsAux(R, RS', RS'') 
    = splitMapsAux(none, RS', (R, RS'')) [owise] .
  eq splitMapsAux((R, RS), RS', RS'') 
    = splitMapsAux(RS, RS', (R, RS'')) [owise] .
  eq splitMapsAux(none, RS, RS') = < RS ; RS' > .

*** To avoid the interference between the sort and class maps with other maps, the map
*** set is divided in two sets.

  ceq applyMapsToModule(RS, U, M) 
    = applyMapsToModuleAux(SRS, ORS, U, M) 
    if < SRS ; ORS > := splitMaps(RS) .
  eq applyMapsToModule(RS, U, unitError(QIL)) = unitError(QIL) .

  eq applyMapsToModuleAux(SRS, ORS, mod H is IL sorts SS . SSDS OPDS MAS EqS RlS endm, M)
    = mod H is
          IL 
          sorts applyMapsToSortSet(SRS, SS) . 
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
      endm .
  eq applyMapsToModuleAux(SRS, ORS, th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth, M)
    = th MN is
          IL sorts applyMapsToSortSet(SRS, SS) . 
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
          applyMapsToRls(SRS, ORS, RlS, M)
      endth .
  eq applyMapsToModuleAux(SRS, ORS, fmod H is IL sorts SS . SSDS OPDS MAS EqS endfm, M)
    = fmod H is
          IL 
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
      endfm .
  eq applyMapsToModuleAux(SRS, ORS, fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth, M)
    = fth MN is 
          IL 
          sorts applyMapsToSortSet(SRS, SS) .
          applyMapsToSubsorts(SRS, SSDS)
          applyMapsToOps(SRS, ORS, OPDS, M)
          applyMapsToMbs(SRS, ORS, MAS, M)
          applyMapsToEqs(SRS, ORS, EqS, M)
      endfth .
  eq applyMapsToModuleAux(SRS, ORS, omod H is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom, M)
    = omod H is 
           IL 
           sorts applyMapsToSortSet(SRS, SS) . 
           applyMapsToSubsorts(SRS, SSDS)
           applyMapsToClassDeclSet(SRS, ORS, CDS)
           applyMapsToSubclassDeclSet(SRS, SCDS)
           applyMapsToOps(SRS, ORS, OPDS, M)
           applyMapsToMsgDeclSet(SRS, ORS, MDS, M)
           applyMapsToMbs(SRS, ORS, MAS, M)
           applyMapsToEqs(SRS, ORS, EqS, M)
           applyMapsToRls(SRS, ORS, RlS, M)
      endom .
  eq applyMapsToModuleAux(SRS, ORS, oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth, M)
    = oth MN is 
           IL 
           sorts applyMapsToSortSet(SRS, SS) . 
           applyMapsToSubsorts(SRS, SSDS)
           applyMapsToClassDeclSet(SRS, ORS, CDS)
           applyMapsToSubclassDeclSet(SRS, SCDS)
           applyMapsToOps(SRS, ORS, OPDS, M)
           applyMapsToMsgDeclSet(SRS, ORS, MDS, M)
           applyMapsToMbs(SRS, ORS, MAS, M)
           applyMapsToEqs(SRS, ORS, EqS, M)
           applyMapsToRls(SRS, ORS, RlS, M)
      endoth .

  eq applyMapsToOps(RS, RS', (op F : TyL -> Ty [AtS] . OPDS), M)
    = (applyMapsToOp(RS, getRightOpMaps(F, TyL, Ty, RS', M), RS', (op F : TyL -> Ty [AtS] .), M)
       applyMapsToOps(RS, RS', OPDS, M)) .
  eq applyMapsToOps(RS, RS', none, M) = none .

  eq applyMapsToOp(RS, R, RS', (op F : TyL -> Ty [AtS] .), M)
    = (op applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) 
         [applyMapsToAttrs(RS, RS', applyMapToAttrs(R, AtS), M)] .) .
  eq applyMapsToOp(RS, (R, RS'), RS'', (op F : TyL -> Ty [AtS] .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily 
    = (op applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) 
         [applyMapsToAttrs(RS, RS'', applyMapToAttrs(R, AtS), M)] .) .
  eq applyMapsToOp(RS, none, RS', (op F : TyL -> Ty [AtS] .), M)
    *** No map for this declaration
    = (op F : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) 
         [applyMapsToAttrs(RS, RS', AtS, M)] .) .

  eq applyMapsToMsgDeclSet(RS, RS', ((msg F : TyL -> Ty .) MDS), M)
    = (applyMapsToMsgDecl(RS, getRightOpMaps(F, TyL, Ty, RS', M), (msg F : TyL -> Ty .), M)
       applyMapsToMsgDeclSet(RS, RS', MDS, M)) .
  eq applyMapsToMsgDeclSet(RS, RS', none, M) = none .

  eq applyMapsToMsgDecl(RS, R, (msg F : TyL -> Ty .), M)
    = (msg applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .
  eq applyMapsToMsgDecl(RS, (R, RS'), (msg F : TyL -> Ty .), M)
    *** In case of ambiguous mappings we take one of them arbitrarily
    = (msg applyOpMapsToOpId(F, R) : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .
  eq applyMapsToMsgDecl(RS, none, (msg F : TyL -> Ty .), M)
    *** No map for this declaration
    = (msg F : applyMapsToTypeList(RS, TyL) -> applyMapsToType(RS, Ty) .) .

*** The function \texttt{applyMapToAttrs} just takes care of changing the
*** attributes of the operators as indicated in the renamings. The renamings
*** properly said is accomplished by the function 
*** \texttt{applyMapsToAttrs}.

  eq applyMapToAttrs((msg F to F'), AtS) = AtS .
  eq applyMapToAttrs((msg F : TyL -> Ty to F'), AtS) = AtS .
  eq applyMapToAttrs(op_to`term_(T, T'), AtS) = AtS .
  eq applyMapToAttrs((op F to F' [AtS]), AtS')
    = applyMapToAttrsAux(AtS, AtS', none) .
  eq applyMapToAttrs((op F : TyL -> Ty to F' [AtS]), AtS')
    = applyMapToAttrsAux(AtS, AtS', none) .

  *** add the new syntactic attributes
  eq applyMapToAttrsAux((gather(QIL) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (gather(QIL) AtS'')) .
  eq applyMapToAttrsAux((format(QIL) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (format(QIL) AtS'')) .
  eq applyMapToAttrsAux((prec(I) AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', (prec(I) AtS'')) .
  eq applyMapToAttrsAux((At AtS), AtS', AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') 
    [owise] .

  *** remove the old syntactic attributes
  eq applyMapToAttrsAux(AtS, (format(QIL) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .
  eq applyMapToAttrsAux(AtS, (gather(QIL) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .
  eq applyMapToAttrsAux(AtS, (prec(I) AtS'), AtS'')
    = applyMapToAttrsAux(AtS, AtS', AtS'') .

  eq applyMapToAttrsAux(none, (At AtS), AtS')
    = applyMapToAttrsAux(none, AtS, (At AtS')) .
  eq applyMapToAttrsAux(none, none, AtS) = AtS .

  eq applyMapsToTypeList(RS, (Ty TyL)) 
    = (applyMapsToType(RS, Ty) applyMapsToTypeList(RS, TyL)) .
  eq applyMapsToTypeList(RS, nil) = nil .

  eq applyMapsToSubsorts(RS, ((subsort S < S' .) SSDS))
    = ((subsort applyMapsToType(RS, S) < applyMapsToType(RS, S') .)
       applyMapsToSubsorts(RS, SSDS)) .
  eq applyMapsToSubsorts(RS, none) = none .

  eq applyMapsToAttrs(RS, RS', (id(T) AtS), M)
    = (id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (left-id(T) AtS), M)
    = (left-id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (right-id(T) AtS), M)
    = (right-id(applyMapsToTerm2(RS, RS', T, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (special(HkL) AtS), M)
    = (special(applyMapsToHooks(RS, RS', HkL, M))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', (label(L) AtS), M)
    = (label(applyMapsToLabel(RS, L))
       applyMapsToAttrs(RS, RS', AtS, M)) .
  eq applyMapsToAttrs(RS, RS', AtS, M) = AtS [owise] .

  eq applyMapsToHooks(RS, RS', id-hook(QI, QIL) HkL, M) 
    = id-hook(QI, QIL) 
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', op-hook(QI, QI', QIL, QI'') HkL, M)
    = applyMapsToHooksAux(RS, 
         getRightOpMaps(QI', QIL, QI'', RS', M), 
         op-hook(QI, QI', QIL, QI''), M) 
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', term-hook(QI, T) HkL, M)
    = term-hook(QI, applyMapsToTerm2(RS, RS', T, M)) 
      applyMapsToHooks(RS, RS', HkL, M).
  eq applyMapsToHooks(RS, RS', nil, M) = nil .

  eq applyMapsToHooksAux(RS, R, op-hook(QI, F, TyL, Ty), M)
    = op-hook(QI, applyOpMapsToOpId(F, R),
         applyMapsToTypeList(RS, TyL), applyMapsToType(RS, Ty)) .
  eq applyMapsToHooksAux(RS, (R, RS'), op-hook(QI, F, TyL, Ty), M)
    *** In case of ambiguous mappings we take any of them arbitrarily  
    = op-hook(QI, applyOpMapsToOpId(F, R),
         applyMapsToTypeList(RS, TyL), applyMapsToType(RS, Ty)) .
  eq applyMapsToHooksAux(RS, none, op-hook(QI, F, TyL, Ty), M)
    = op-hook(QI, F, applyMapsToTypeList(RS, TyL), 
        applyMapsToType(RS, Ty)) .

  eq applyMapsToMbs(RS, RS', ((mb T : S [AtS] .) MAS), M)
    = ((mb applyMapsToTerm2(RS, RS', T, M) : applyMapsToType(RS, S) 
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToMbs(RS, RS', MAS, M)) .
  eq applyMapsToMbs(RS, RS', ((cmb T : S if Cond [AtS] .) MAS), M)
    = ((cmb applyMapsToTerm2(RS, RS', T, M) : applyMapsToType(RS, S)
          if applyMapsToCond(RS, RS', Cond, M) 
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToMbs(RS, RS', MAS, M)) .
  eq applyMapsToMbs(RS, RS', none, M) = none .

  eq applyMapsToEqs(RS, RS', ((ceq T = T' if Cond [AtS] .) EqS), M) 
    = ((ceq applyMapsToTerm2(RS, RS', T, M) 
          = applyMapsToTerm2(RS, RS', T', M)
          if applyMapsToCond(RS, RS', Cond, M) 
        [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToEqs(RS, RS', EqS, M)) .
  eq applyMapsToEqs(RS, RS', ((eq T = T' [AtS] .) EqS), M) 
    = ((eq applyMapsToTerm2(RS, RS', T, M) 
          = applyMapsToTerm2(RS, RS', T', M) 
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToEqs(RS, RS', EqS, M)) .
  eq applyMapsToEqs(RS, RS', none, M) = none .

  eq applyMapsToRls(RS, RS', ((crl T => T' if Cond [AtS] .) RlS), M) 
    = ((crl applyMapsToTerm2(RS, RS', T, M)
          => applyMapsToTerm2(RS, RS', T', M)
          if applyMapsToCond(RS, RS', Cond, M) 
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToRls(RS, RS', RlS, M)) .
  eq applyMapsToRls(RS, RS', ((rl T => T' [AtS] .) RlS), M) 
    = ((rl applyMapsToTerm2(RS, RS', T, M)
          => applyMapsToTerm2(RS, RS', T', M) 
          [applyMapsToAttrs(RS, RS', AtS, M)] .)
       applyMapsToRls(RS, RS', RlS, M)) .
  eq applyMapsToRls(RS, RS', none, M) = none .

  eq applyMapsToCond(RS, RS', T = T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) = applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T : S /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) : applyMapsToSort(RS, S)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T := T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) := applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', T => T' /\ Cond, M)
    = applyMapsToTerm2(RS, RS', T, M) => applyMapsToTerm2(RS, RS', T', M)
      /\ applyMapsToCond(RS, RS', Cond, M) .
  eq applyMapsToCond(RS, RS', nil, M) = nil .

  eq applyMapsToLabel((label L to L'), L'')
    = if L == L'' 
      then L'
      else L''
      fi .
  eq applyMapsToLabel(((label L to L'), RS), L'')
    = if L == L'' 
      then L'
      else applyMapsToLabel(RS, L'')
      fi .
  eq applyMapsToLabel(R, L) = L [owise] .
  eq applyMapsToLabel((R, RS), L)
    = applyMapsToLabel(RS, L)
    [owise] .
  eq applyMapsToLabel(none, L) = L .

  eq applyMapsToClassDeclSet(RS, RS', class C | ADS . CDS)
    = (class applyMapsToClassName(RS, C) | applyMapsToAttrDeclSet(RS, RS', C, ADS) .
       applyMapsToClassDeclSet(RS, RS', CDS)) .
  eq applyMapsToClassDeclSet(RS, RS', none) = none .

  eq applyMapsToAttrDeclSet(RS, RS', C, ((attr A : Ty), ADS))
    = ((attr applyMapsToAttrName(RS', C, A) : applyMapsToType(RS, Ty)),
       applyMapsToAttrDeclSet(RS, RS', C, ADS)) .
  eq applyMapsToAttrDeclSet(RS, RS', C, none) = none .

  eq applyMapsToAttrName((attr A . C to A'), C', A'')
    = if (C == C') and (A == A'')
      then A'
      else A''
      fi .
  eq applyMapsToAttrName(((attr A . C to A'), RS), C', A'')
    = if (C == C') and (A == A'')
      then A'
      else applyMapsToAttrName(RS, C', A'')
      fi .
  eq applyMapsToAttrName(R, C, A) = A [owise] .
  eq applyMapsToAttrName((R, RS), C, A)
    = applyMapsToAttrName(RS, C, A)
    [owise] .
  eq applyMapsToAttrName(none, C, A) = A .

  eq applyMapsToSubclassDeclSet(RS, subclass C < C' . SCDS)
    = (subclass applyMapsToClassName(RS, C) < applyMapsToClassName(RS, C') .
       applyMapsToSubclassDeclSet(RS, SCDS)) .
  eq applyMapsToSubclassDeclSet(RS, none) = none .
endfm

*******************************************************************************

***
*** 6.9 Instantiation of Parameterized Modules and the 
***     \texttt{META-LEVEL} Module Expression

*** A parameterized module 
*** $\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\}\ldots\texttt{, L}_n
*** \texttt{ :: T}_n\texttt{]}$, with \mbox{$\texttt{L}_1\ldots\texttt{L}_n$}
*** labels and \mbox{$\texttt{T}_1\ldots\texttt{T}_n$} theory identifiers, is
*** represented as a module with name \texttt{M} which contains parameter
*** declarations  \mbox{$\texttt{par\ L}_i\texttt{\ ::\ T}_i$} for 
*** $1\leq i\leq n$, and an importation declaration
*** \mbox{$\texttt{inc\ par\ L}_i\texttt{\ ::\ T}_i\texttt{\ .}$} for each
*** parameter \mbox{$\texttt{L}_i\texttt{\ ::\ T}_i$} in its interface.  Note
*** that all modules are handled in a uniform way: nonparameterized modules 
*** and theories have their list of parameters set to \texttt{nil}.

*** The instantiation of the formal parameters of a parameterized module with
*** actual modules or theories requires a view from each formal parameter
*** theory to its corresponding actual unit. The process of instantiation
*** results in the replacement of each interface theory by its corresponding 
*** actual parameter, using the views to bind actual names to formal names.

*** The naming conventions for sorts have to be taken into account in the
*** instantiation process: every occurrence of a sort coming from a theory in
*** the interface of a module must be qualified by its theory's label, and
*** sorts defined in the body of a parameterized module can be parameterized
*** by the labels in the interface of the module (see 
*** Section~\ref{parameterized-modules}).

*** The labeling convention for theories and for the sorts coming from them is
*** very useful to avoid collisions of sort names coming from the parameter
*** theories, and also to allow different uses of the same theory several
*** times in the interface of a module. We assume that all sorts coming from
*** the theory part of the parameter theories are used in their qualified form
*** to manipulate the maps defined in the views before being applied to the
*** body of the module being instantiated. If the target of a view is a 
*** theory, the sorts from the theory part of the target theory appearing in 
*** the targTS of the maps in the view will be qualified as well, following 
*** the same convention.

*** When a parameterized module
*** $\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\ }
***            \ldots\texttt{,\ L}_n\texttt{\ ::\ T}_n\texttt{]}$
*** is instantiated with views $\texttt{V}_1\ldots\texttt{V}_n$, each
*** parameterized sort $\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$
*** in the body of the parameterized module is renamed to
*** $\texttt{S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$.

*** The discussion on the qualification of sorts in views before being used in
*** the instantiation process applies in a completely similar way to class
*** names in parameterized object-oriented modules.

*** As we saw in Section~\ref{module-expressions}, it is possible to import a
*** module expression in which a parameterized module is instantiated by some
*** of the formal parameters of the parameterized module in which it is
*** imported. This is done by using the label of some of the parameters in the
*** interface of a module, say \mbox{$\texttt{L}_k\texttt{\ ::\ T}_k$}, in a
*** module expression in which some parameterized module \texttt{N} with formal
*** parameter $\texttt{T}_k$ is instantiated with $\texttt{L}_k$, that is, we
*** have the module expression $\texttt{N[}\ldots\texttt{L}_k\ldots\texttt{]}$.
*** In this case, $\texttt{L}_k$ is considered as the identity view for the
*** theory $\texttt{T}_k$ with $\texttt{L}_k$ as name. Note that to be able to
*** check whether a label in the interface of a module is used in an
*** instantiation of this form, in the evaluation of a module expression the
*** list of parameters of the module in which the module expression appears
*** must be available. This is the reason why the \texttt{evalModExp} function 
*** was defined with \texttt{ParameterList} as one of the sorts in its 
*** arity (see Section~\ref{evalModExp}). For module expressions appearing 
*** outside of any module, that is, in commands, etc., this list will be set 
*** to \texttt{nil}.

*** Note that this kind of instantiation may produce a `cascade' effect. The
*** module being instantiated may itself import other module expressions in
*** which labels of some of its parameter theories are used in the
*** instantiation of some of these imported module expressions. This is handled
*** by `preparing' the module expressions appearing in the importation
*** declarations of the module (\texttt{prepImports}). This process
*** consists in changing the labels of the interface of the module being
*** instantiated which are used in the importations of module expressions by
*** the corresponding view names (\texttt{prepHeader}). After completing the
*** generation of the module resulting from the evaluation of the module
*** expression, this module will be evaluated with the \texttt{evalModule} 
*** function, producing the evaluation of these new module expressions. In any 
*** extension of the language, new equations for the function 
*** \texttt{prepHeader} will have to be added for each new kind of module 
*** expression being defined.

*** In Sections~\ref{renaming} and~\ref{extension} we shall see how new
*** equations completing the semantics of \texttt{prepHeader} are added for
*** each new module expression being defined. In the case of the renaming
*** module expression, the renaming maps will have to be prepared as well, to 
*** adjust the sort names being renamed to the conventions discussed above.

*** As for any other module expression being defined, in addition to the
*** operator declaration for the constructor of the instantiation module
*** expression, equations completing the semantics of operators
*** \texttt{evalModExp}, \texttt{header2QidList}, and 
*** \texttt{setUpModExpDeps} have to be given.

fmod INST-EXPR-EVALUATION is
  pr EVALUATION .
  pr RENAMING-SET-APPL-ON-UNIT .
  inc MOD-EXPR .
  inc MOD-NAME .
  pr DATABASE .

*** We start by giving the new constructor for sort \texttt{ModuleExpression}. 
*** Note thatthe modules \texttt{MOD-EXPR} and \texttt{MOD-NAME} have been 
*** imported in \texttt{including} mode.

  vars QI QI' QI'' X Y W Z C F F' A A' L L' : Qid .
  var  QIL : QidList .
  vars M M' PU U U' U'' DM : Module .
  var  Th : OTheory .
  vars ME ME' ME'' : ModuleExpression .
  var  H : Header .
  vars MN MN' : ModuleName .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 : Set{ModuleName} .
  vars VE VE' VE'' VE3 VE4 : ViewExp .
  vars VES VES' : Set{ViewExp} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars DB DB' DB'' : Database . 
  var  PD : ParameterDecl .
  vars PDL PDL' PDL'' PDL3 PDL4 PDL5 : ParameterDeclList .
  var  PDS : Set{ParameterDecl} .
  vars PL PL' PL'' PL3 : ParameterList .
  vars S S' P P' P'' : Sort .
  vars IL IL' IL'' IL3 : ImportList .
  vars SMS SMS' SMS'' SMS3 : SortMappingSet .
  vars OMS OMS' OMS'' OMS3 : OpMappingSet .
  var  V : Variable .
  var  Ct : Constant .
  var  SL : QidList .
  var  Ty : Type .
  var  TyL : TypeList .
  vars SS SS' SS'' : SortSet .
  var  K : Kind .
  vars T T' O : Term .
  var  DT : Default{Term} .
  var  TL : TermList .
  var  CDS : ClassDeclSet .
  var  ADS : AttrDeclSet .
  var  B : Bool .
  var  AtS : AttrSet .
  var  N : Nat .
  var  PV : PreView .
  var  VI : View .
  var  VDS : OpDeclSet .
  vars RS RS' RS'' SRS SRS' ORS ORS' : RenamingSet .

*** In the input given by the user, the operator \verb~_(_)~ is used both for
*** the instantiation of module expressions, and for expressions
*** parameterizing the module \texttt{META-LEVEL} with a list of module names.
*** The function \texttt{evalModExp} distinguishes these two cases, calling
*** the function \texttt{unitInst} in the former and the function 
*** \texttt{prepMetalevel} in the latter.

  op unitInst : Header ParameterList ParameterDeclList Database -> Database .
  op prepMetalevel : ParameterList Database -> Database .

  eq evalModExp(ME{PL}, PDL, DB) 
    = if unitInDb(ME{PL}, DB) 
      then < DB ; ME{PL} >
      else if ME == 'META-LEVEL
           then < prepMetalevel(PL, DB) ; ME{PL} >
           else < unitInst(
                    modExp(evalModExp(ME, PDL, evalViewExp(PL, PDL, DB))), 
                    PL, PDL, 
                    database(evalModExp(ME, PDL, evalViewExp(PL, PDL, DB)))) 
                  ; 
                  modExp(evalModExp(ME, PDL, evalViewExp(PL, PDL, DB))){PL} >
           fi
      fi .

*** The function \texttt{prepMetalevel} creates a new module with the
*** module expression being evaluated as name, which imports the predefined
*** \texttt{META-LEVEL} module. For each module name \texttt{I} in the list
*** given as parameter of the expression, the declaration of a constant
*** \texttt{I} of sort \texttt{Module} and an equation identifying such
*** constant with the metarepresentation of the module with such name in the 
*** database are added to the module being created.

  op prepMetalevelAux : ParameterList Module Database -> Database .

  eq prepMetalevel(PL, DB)
    = prepMetalevelAux(PL, 
        addImports((including 'META-LEVEL .),
          setName(emptyFModule, 'META-LEVEL{PL})), DB) .

  eq prepMetalevelAux((QI), U, DB)
    = prepMetalevelAux(nil,
        addOps((op qid("META-" + string(QI)) : nil -> 'Module [none] .), 
          addEqs((eq qid("META-" + string(QI) + ".Module") 
                    = up(getFlatModule(QI, database(evalModExp(QI, DB)))) 
                    [none] .), 
            U)),
        DB) .
  eq prepMetalevelAux((QI, PL), U, DB)
    = prepMetalevelAux(PL,
        addOps((op qid("META-" + string(QI)) : nil -> 'Module [none] .), 
          addEqs((eq qid("META-" + string(QI) + ".Module") 
                    = up(getFlatModule(QI, database(evalModExp(QI, DB)))) 
                    [none] .), 
            U)),
        DB) .
  eq prepMetalevelAux(nil, U, DB) = evalModule(U, none, DB) .

*** The function \texttt{getClassNames} returns the set of the names of
*** the classes in a set of class declarations.

  op getClassNames : ClassDeclSet -> SortSet .

  eq getClassNames(((class S | ADS .) CDS)) 
    = (S ; getClassNames(CDS)) .
  eq getClassNames(none) = none .

*** The following `getTh' functions return the corresponding elements in the
*** theory part of the structure of the given unit. For example, the function
*** \texttt{getThSorts} returns the set of sorts declared in the ``loose
*** part'' of the structure of the unit in the database having the name 
*** indicated as first argument.

  op getThSorts : ModuleExpression Database -> SortSet .
  op getThClasses : ModuleExpression Database -> SortSet .
  op getThSortsAux : ImportList Database -> SortSet .
  op getThClassesAux : ImportList Database -> SortSet .

  eq getThSorts(ME, DB)
    = if theory(getTopModule(ME, DB))
      then (getThSortsAux(getImports(getTopModule(ME, DB)), DB) ; 
            getSorts(getTopModule(ME, DB)))
      else none
      fi .

  eq getThSortsAux(((including MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(((extending MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(((protecting MN .) IL), DB)
    = (getThSorts(MN, DB) ; getThSortsAux(IL, DB)) .
  eq getThSortsAux(nil, DB) = none .

  eq getThClasses(ME, DB)
    = if getTopModule(ME, DB) :: OTheory
         and-then not getTopModule(ME, DB) :: STheory
      then (getThClassesAux(getImports(getTopModule(ME, DB)), DB) ;
            getClassNames(getClasses(getTopModule(ME, DB))))
      else none
      fi .

  eq getThClassesAux(((including MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(((extending MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(((protecting MN .) IL), DB)
    = (getThClasses(MN, DB) ; getThClassesAux(IL, DB)) .
  eq getThClassesAux(nil, DB) = none .

*** The `get' functions return the corresponding elements in the structure of
*** the given unit. For example, \texttt{getSortSet} returns all the sorts
*** declared in the structure of the unit in the database having the name 
*** given as first argument.

  op getSortSet : ModuleName Database -> SortSet .
  op getClassSet : ModuleName Database -> SortSet .

  op getSortSetAux : ImportList Database -> SortSet .
  op getClassSetAux : ImportList Database -> SortSet .

  eq getSortSet(MN, DB)
    = (getSortSetAux(getImports(getTopModule(MN, DB)), DB) ; 
       getSorts(getTopModule(MN, DB))) .

  eq getSortSetAux(((including MN .) IL), DB) 
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(((extending MN .) IL), DB) 
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(((protecting MN .) IL), DB) 
    = (getSortSet(MN, DB) ; getSortSetAux(IL, DB)) .
  eq getSortSetAux(nil, DB) = none .

  eq getClassSet(MN, DB)
    = (getClassSetAux(getImports(getTopModule(MN, DB)), DB) ;
       getClassNames(getClasses(getTopModule(MN, DB)))) .

  eq getClassSetAux(((including MN .) IL), DB) 
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(((extending MN .) IL), DB) 
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(((protecting MN .) IL), DB) 
    = (getClassSet(MN, DB) ; getClassSetAux(IL, DB)) .
  eq getClassSetAux(nil, DB) = none .

*** As pointed out in Section~\ref{parameterized-modules}, in a parameterized
*** module all occurrences of sorts or classes coming from the parameter
*** theories have to be qualified. \texttt{createCopy} is the function used
*** for creating these renamed copies of the parameters. As also explained in
*** Section~\ref{parameterized-modules}, if a parameter theory is structured, 
*** the renaming is carried out not only at the top level, but for the entire 
*** ``theory part'' in the structure.

*** The function \texttt{createCopy} calls an auxiliary function,
*** \texttt{prepPar}, which recursively proceeds through all the subtheories
*** of the given theory. For each theory in the structure, the required set of
*** maps is generated and applied to such a theory using the
*** \texttt{applyMapsToModule} function discussed in
*** Section~\ref{applyMapsToModule}, which is then evaluated and entered into
*** the database. Note that the renamings to which a theory is subjected must 
*** also be applied to the theories importing it. The new database and the 
*** renaming maps applied to the theory will have to be returned by the 
*** function.

*** The function \texttt{prepPar} makes a copy of the theory specified by the
*** name given as first argument and of all its subtheories (only theories, no
*** modules), and qualifies all the sorts appearing in it with the label given
*** in the declaration of the parameter, which is given as second argument.

  pr 2TUPLE{ViewExp,ViewExp} 
       * (op ((_,_)) to <_;_>,
          op p1_ to 1st,
          op p2_ to 2nd).

  sorts ---- Tuple{ViewExp,ViewExp} 
        Set{Tuple{ViewExp,ViewExp}} 
        prepParResult  .
  subsort Tuple{ViewExp,ViewExp} < Set{Tuple{ViewExp,ViewExp}} .
----  op <_;_> : ViewExp ViewExp -> Tuple{ViewExp,ViewExp} .
----  ops 1st 2nd : Tuple{ViewExp,ViewExp} -> ViewExp .
  op none : -> Set{Tuple{ViewExp,ViewExp}} .
  op __ : Set{Tuple{ViewExp,ViewExp}} Set{Tuple{ViewExp,ViewExp}} 
      -> Set{Tuple{ViewExp,ViewExp}} [assoc comm id: none] .

  vars VEPS VEPS' : Set{Tuple{ViewExp,ViewExp}} .
  
----  eq 1st(< VE ; VE' >) = VE .
----  eq 2nd(< VE ; VE' >) = VE' .
  
  op prepPar : Qid Qid ModuleExpression Database -> prepParResult .
  op prepParImports : ImportList ImportList Qid Qid SortMappingSet OpMappingSet 
        Set{Tuple{ViewExp,ViewExp}} ParameterDeclList Database -> prepParResult .

  op <_;_;_;_;_;_;_;_> : SortMappingSet OpMappingSet Database ViewExp ViewExp Set{Tuple{ViewExp,ViewExp}} Bool ImportList -> prepParResult .
  op sortMappingSet : prepParResult -> SortMappingSet .
  op opMappingSet : prepParResult -> OpMappingSet .
  op database : prepParResult -> Database .
  op sourceViewExp : prepParResult -> ViewExp .
  op targetViewExp : prepParResult -> ViewExp .
  op viewExpPairSet : prepParResult -> Set{Tuple{ViewExp,ViewExp}} .
  op theoryFlag : prepParResult -> Bool .
  op getImports : prepParResult -> ImportList .
  eq opMappingSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = OMS .
  eq sortMappingSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = SMS .
  eq database(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = DB .
  eq sourceViewExp(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VE .
  eq targetViewExp(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VE' .
  eq viewExpPairSet(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = VEPS .
  eq theoryFlag(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = B .
  eq getImports(< SMS ; OMS ; DB ; VE ; VE' ; VEPS ; B ; IL >) = IL .

  ----op createCopy : ParameterDecl Database -> Database .
  op prepPar : Qid ModuleExpression Database  -> prepParResult .
  op prepParImports : ImportList ImportList Qid SortMappingSet OpMappingSet 
        Set{Tuple{ViewExp,ViewExp}} ParameterDeclList Database -> prepParResult .

  eq createCopy(X :: ME, DB)
    = if unitInDb(pd(X :: ME), DB)
      then DB
      else database(prepPar(X, ME, database(evalModExp(ME, DB))))
      fi .

  ceq prepPar(X, ME, DB)
    = < SMS' ; 
        OMS ;
        (if unitInDb(pd(X :: ME), DB)
         then DB
         else evalModule(
                setImports(
                  setName(
                    applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), Th, getFlatModule(ME, DB)),
                    pd(X :: ME)),
                  IL),
                applyMapsToOps(maps2rens(SMS'), maps2rens(OMS), getVars(ME, DB), getFlatModule(ME, DB)),
                DB')
         fi) ;
        mtViewExp ; mtViewExp ; none ; true ; nil >
    if Th := getTopModule(ME, DB)
       /\ < SMS ; OMS ; DB' ; VE ; VE' ; VEPS ; B ; IL > := prepParImports(getImports(Th), nil, X, none, none, none, X :: ME, DB) 
       /\ SMS' := (SMS
                   sortMapsPar(X, getSorts(Th), none)
                   classMapsPar(X, classSet(getClasses(Th)), none)) .
  eq prepPar(X, ME, DB)
    = < none ; none ; warning(DB, '\r 'Error: '\o 'Incorrect 'parameter '\n) ; 
        mtViewExp ; mtViewExp ; none ; false ; nil > 
      [owise] .

  ceq prepParImports(((including ME .) IL), IL', X, SMS, OMS, VEPS, PDL, DB)
    = if B
      then prepParImports(IL, (IL' (including pd(X :: ME') .)), X, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (including ME .)), X, SMS, OMS, VEPS, PDL, DB)
      fi 
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((extending ME .) IL), IL', X, SMS, OMS, VEPS, PDL, DB)
    = if B
      then *** A theory shouldn't be imported in protecting mode
           prepParImports(IL, (IL' (extending pd(X :: ME') .)), X, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (extending ME .)), X, SMS, OMS, VEPS, PDL, DB)
      fi 
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((protecting ME .) IL), IL', X, SMS, OMS, VEPS, PDL, DB)
    = if B
      then *** A theory shouldn't be imported in protecting mode
           prepParImports(IL, (IL' (protecting pd(X :: ME') .)), X, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB')
      else prepParImports(IL, (IL' (protecting ME .)), X, SMS, OMS, VEPS, PDL, DB)
      fi 
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((including pd(X :: ME) .) IL), IL', Y, SMS, OMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (including pd(Z :: ME') .)), Y, (SMS SMS'), (OMS OMS'), (< X ; Z > VEPS), PDL, DB') 
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((extending pd(X :: ME) .) IL), IL', Y, SMS, OMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (extending pd(Z :: ME') .)), Y, (SMS SMS'), (OMS OMS'), (< X ; Z > VEPS), PDL, DB') 
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(((protecting pd(X :: ME) .) IL), IL', Y, SMS, OMS, (< X ; Z > VEPS), PDL, DB)
    = prepParImports(IL, (IL' (protecting pd(Z :: ME') .)), Y, (SMS SMS'), (OMS OMS'), (< X ; Z > VEPS), PDL, DB') 
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(X, ME', database(evalModExp(ME', PDL, DB))) .
  eq prepParImports(nil, IL, X, SMS, OMS, VEPS, PDL, DB)
    = < SMS ; OMS ; DB ; mtViewExp ; mtViewExp ; none ; false ; IL > .

  ceq prepPar(X, Y, ME, DB)
    = (< SMS' ; OMS ;
        (if unitInDb(pd(Y :: ME), DB)
         then DB
         else evalModule(
                setImports(
                  setName(
                    applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), getTopModule(pd(X :: ME), DB), getFlatModule(pd(X :: ME), DB)),
                    pd(Y :: ME)),
                  IL),
                applyMapsToOps(maps2rens(SMS'), maps2rens(OMS), getVars(pd(X :: ME), DB), getFlatModule(pd(X :: ME), DB)),
                DB')
         fi) ;
        X ; Y ; < X ; Y > ; true ; nil >) 
    if Th := getTopModule(ME, DB)
    /\ (< SMS ; OMS ; DB' ; VE ; VE' ; VEPS ; B ; IL >) := prepParImports(getImports(Th), nil, X, Y, none, none, < X ; Y >, X :: ME, DB) 
    /\ SMS' := (SMS
                genMapsQualSorts(X, Y, getSorts(Th), none)
                genMapsQualClasses(X, Y, classSet(getClasses(Th)), none)) .

  eq prepParImports(((including ME .) IL), IL', X, Y, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' including ME .), X, Y, SMS, OMS, VEPS, PDL, DB) .
  eq prepParImports(((extending ME .) IL), IL', X, Y, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' extending ME .), X, Y, SMS, OMS, VEPS, PDL, DB) .
  eq prepParImports(((protecting ME .) IL), IL', X, Y, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, (IL' protecting ME .), X, Y, SMS, OMS, VEPS, PDL, DB) .
  ceq prepParImports(including pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' including pd(X :: ME') ., Y, Z, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB') 
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(extending pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' extending pd(X :: ME') ., Y, Z, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB') 
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  ceq prepParImports(protecting pd(X :: ME) . IL, IL', Y, Z, SMS, OMS, VEPS, PDL, DB)
    = prepParImports(IL, IL' protecting pd(X :: ME') ., Y, Z, (SMS SMS'), (OMS OMS'), VEPS, PDL, DB') 
    if ME' := prepModExp(ME, VEPS)
    /\ < SMS' ; OMS' ; DB' ; VE ; VE' ; VEPS' ; B ; IL'' > := prepPar(Y, Z, ME', database(evalModExp(ME', PDL, DB))) .
  eq prepParImports(nil, IL, X, Y, SMS, OMS, VEPS, PDL, DB)
    = < SMS ; OMS ; DB ; mtViewExp ; mtViewExp ; none ; false ; IL > .

  op sortMapsPar : Qid SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .
  op classMapsPar : Qid SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .

  op qualify : Qid Sort -> Sort .
  op qualify : Qid Sort Set{Tuple{ViewExp,ViewExp}} -> Sort .
  op qualify : Qid Sort ParameterList ParameterList Set{Tuple{ViewExp,ViewExp}} -> Sort .

  eq qualify(X, S) = qualify(X, getName(S), getPars(S), empty, none) .

  eq qualify(X, S, VEPS) = qualify(X, getName(S), getPars(S), empty, VEPS) .

  eq qualify(X, S, (P, PL), PL', < P ; P' > VEPS) 
    = qualify(X, S, PL, PL' P', < P ; P' > VEPS) .
  eq qualify(X, S, (P, PL), PL', VEPS) 
    = qualify(X, S, PL, PL' P, VEPS) 
    [owise] .
  eq qualify(X, S, empty, PL, VEPS) 
    = qid(string(X) + "$" + string(makeSort(S, PL))) .

  eq sortMapsPar(X, (S ; SS), VEPS)
    = (sort S to qualify(X, S, VEPS) . sortMapsPar(X, SS, VEPS)) .
  eq sortMapsPar(X, none, VEPS) = none .

  eq classMapsPar(X, (S ; SS), VEPS)
    = (class S to qualify(X, S, VEPS) . classMapsPar(X, SS, VEPS)) .
  eq classMapsPar(X, none, VEPS) = none .

*** When one of the labels of the interface of a module is being used in a
*** module expression to instantiate some formal parameter of a module, then,
*** in the evaluation of such module expression the qualification of all sorts
*** and class names coming from the theory part of the parameter theory have
*** to be changed according to such a label. In the evaluation of an
*** instantiation module expression this is done by generating the
*** corresponding renaming maps, which are then applied to the module being
*** instantiated. Given labels \texttt{L} and \texttt{L'}, for each sort or 
*** class name \texttt{S} in the set given as argument, a map of the form 
*** \verb~L$S to L'$S~ is generated.

  op genMapsQualSorts : Qid Qid SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .
  op genMapsQualClasses : Qid Qid SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .

  eq genMapsQualSorts(X, Y, (S ; SS), VEPS)
    = (sort qualify(X, S, VEPS) to qualify(Y, S, VEPS) .
       genMapsQualSorts(X, Y, SS, VEPS)) .
  eq genMapsQualSorts(X, Y, none, VEPS) = none .

  eq genMapsQualClasses(X, Y, (S ; SS), VEPS)
    = (class qualify(X, S, VEPS) to qualify(Y, S, VEPS) .
       genMapsQualClasses(X, Y, SS, VEPS)) .
  eq genMapsQualClasses(X, Y, none, VEPS) = none .

*** The function \texttt{prepare} takes the map set of a view and
*** prepares it to be used in an instantiation by transforming sort and class
*** names into their qualified form, if required (sorts and class names in a 
*** view have to be qualified only if they were defined in a theory).

*** The \texttt{prepare} function takes six arguments: The sets of maps
*** to be prepared, the label with which the sorts to be renamed have to be
*** qualified, the set of sorts in the theory part of the source of the view,
*** and the set of sorts and class names in the theory part of the target of 
*** the view.

*** Note that we assume that there is a sort map and a class map for each sort
*** and class in the theory part of the source of the view. Therefore, sorts
*** and class names appearing as sources of sort and class maps are
*** systematically qualified. The sorts or class names used in the targets of
*** the maps will be qualified only if they were declared in a theory. In maps
*** for operators in which the arity and coarity are specified, or for those
*** going to derived terms, the sorts appearing in the arity or coarity of an
*** operator and those used to qualify terms, or in sort tests in terms, must
*** also be qualified. However, in these cases the qualification cannot be
*** done on all sorts, but only on those defined in the theory parts. This is 
*** the reason why the sets of sorts in the theory parts of the source and 
*** target and the set of class names in the target of the view are given when 
*** calling \texttt{prepare}.

  op prepare : SortMappingSet Qid SortSet SortSet SortSet -> SortMappingSet .
  op prepare : OpMappingSet Qid SortSet SortSet SortSet -> OpMappingSet .

  op prepare : TypeList Qid SortSet -> TypeList .
  op prepTerm : TermList Qid SortSet -> TermList .

  eq prepare(sort S to S' . SMS, X, SS, SS', SS'')
    = (if S' in SS'
       then sort qualify(X, S) to qualify(X, S') .
       else sort qualify(X, S) to S' .
       fi
       prepare(SMS, X, SS, SS', SS'')) .
  eq prepare(class S to S' . SMS, X, SS, SS', SS'')
    = (if S' in SS''
       then (class qualify(X, S) to qualify(X, S') .)
       else (class qualify(X, S) to S' .)
       fi
       prepare(SMS, X, SS, SS', SS'')) .
  eq prepare((none).SortMappingSet, X, SS, SS', SS'') = none .
       
  eq prepare(op F to F' . OMS, X, SS, SS', SS'')
    = (op F to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(op F : TyL -> Ty to F' . OMS, X, SS, SS', SS'')
    = (op F : prepare(TyL, X, SS) -> prepare(Ty, X, SS) to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(op T to term T' . OMS, X, SS, SS', SS'')
    = (op prepTerm(T, X, SS) to term prepTerm(T', X, SS') .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(msg F to F' . OMS, X, SS, SS', SS'')
    = (msg F to F' . 
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(msg F : TyL -> Ty to F' . OMS, X, SS, SS', SS'')
    = (msg F : prepare(TyL, X, SS) -> prepare(Ty, X, SS) to F' .
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare(attr A . S to A' . OMS, X, SS, SS', SS'')
    = (attr A . qualify(X, S) to A' . 
       prepare(OMS, X, SS, SS', SS'')) .
  eq prepare((none).OpMappingSet, X, SS, SS', SS'') = none .

  eq prepare((S TyL), X, (S ; SS)) = (qualify(X, S) prepare(TyL, X, (S ; SS))) .
  eq prepare((K TyL), X, SS) = prepare((getSort(K) TyL), X, SS) .
  eq prepare((S TyL), X, SS) = (S prepare(TyL, X, SS)) [owise] .
  eq prepare(nil, X, SS) = nil .

  eq prepTerm(F[TL], X, SS) = F[prepTerm(TL, X, SS)] .
  eq prepTerm(V, X, SS)
    = if getType(V) in SS 
      then qid(string(getName(V)) + ":" + string(qualify(X, getType(V))))
      else qid(string(getName(V)) + ":" + string(getType(V)))
      fi .
  eq prepTerm(Ct, X, SS)
    = if getType(Ct) in SS 
      then qid(string(getName(Ct)) + "." + string(qualify(X, getType(Ct))))
      else qid(string(getName(Ct)) + "." + string(getType(Ct)))
      fi .
  ceq prepTerm((T, TL), X, SS) 
    = (prepTerm(T, X, SS), prepTerm(TL, X, SS)) 
    if TL =/= empty .
  eq prepTerm(qidError(QIL), X, SS) = qidError(QIL) .

*** For each parameterized sort
*** $\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$ in the
*** body of a parameterized module with
*** $\texttt{L}_1\ldots\texttt{L}_n$ the labels of the parameters in
*** the interface of the module, a map of the form 9
*** $\texttt{sort\ S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]\
***      to\ S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$
*** is generated, where $\texttt{V}_i$ is the name of the view associated to
*** the label $\texttt{L}_i$ in the set of pairs given as argument.

  op genMapsSorts : SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .
  op genMapsClasses : SortSet Set{Tuple{ViewExp,ViewExp}} -> SortMappingSet .

  op prepSort : Sort Set{Tuple{ViewExp,ViewExp}} -> Sort .
  op prepSort : Sort ParameterList ParameterList Set{Tuple{ViewExp,ViewExp}} -> Sort .

  eq genMapsSorts((S ; SS), VEPS) 
    = (if prepSort(S, VEPS) == S
       then none
       else (sort S to prepSort(S, VEPS) .)
       fi)
      genMapsSorts(SS, VEPS) .
  eq genMapsSorts(none, VEPS) = none .

  eq genMapsClasses((S ; SS), VEPS) 
    = (if prepSort(S, VEPS) == S
       then none
       else (class S to prepSort(S, VEPS) .)
       fi)
      genMapsClasses(SS, VEPS) .
  eq genMapsClasses(none, VEPS) = none .

  eq prepSort(S, VEPS) = prepSort(getName(S), empty, getPars(S), VEPS) .
  eq prepSort(Ty, VEPS) = Ty [owise] .

  eq prepSort(S, PL, P, < P ; VE > VEPS) 
    = prepSort(S, (PL, VE), empty, < P ; VE > VEPS) .
  eq prepSort(S, PL, (P, PL'), < P ; VE > VEPS) 
    = prepSort(S, (PL, VE), PL', < P ; VE > VEPS) .
  eq prepSort(S, PL, P, VEPS) 
    = prepSort(S, (PL, prepSort(P, VEPS)), empty, VEPS) 
    [owise] .
  eq prepSort(S, PL, (P, PL'), VEPS) 
    = prepSort(S, (PL, prepSort(P, VEPS)), PL', VEPS) 
    [owise] .
  eq prepSort(S, PL, empty, VEPS) 
    = if getPars(S) == empty
      then makeSort(S, PL)
      else makeSort(prepSort(S, VEPS), PL)
      fi .

*** The function \texttt{prepImports} takes a list of importation
*** declarations and a set of pairs composed of a label and a view name, and
*** returns the list of importations resulting from changing in each of the
*** module expressions the occurrences of the labels of the interface of the 
*** module being instantiated by the names of the views associated to them in 
*** the list of pairs.

  op prepImports : ImportList Set{Tuple{ViewExp,ViewExp}} -> ImportList .

  op prepModExp : 
       ModuleExpression Set{Tuple{ViewExp,ViewExp}} -> ModuleExpression .
  op prepModExp : ModuleExpression ViewExp ViewExp ViewExp 
       Set{Tuple{ViewExp,ViewExp}} -> ModuleExpression .
  op prepParameterDecl : 
       ParameterDecl Set{Tuple{ViewExp,ViewExp}} -> ParameterDecl .
  op prepViewExp : ViewExp Set{Tuple{ViewExp,ViewExp}} -> ViewExp .
  op prepViewExp : ParameterList Set{Tuple{ViewExp,ViewExp}} -> ParameterList .

  eq prepImports(((including ME .) IL), VEPS)
    = (including prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((including pd(PD) .) IL), VEPS)
    = (including pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(((extending ME .) IL), VEPS)
    = (extending prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((extending pd(PD) .) IL), VEPS)
    = (extending pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(((protecting ME .) IL), VEPS)
    = (protecting prepModExp(ME, VEPS) .)
      prepImports(IL, VEPS) .
  eq prepImports(((protecting pd(PD) .) IL), VEPS)
    = (protecting pd(prepParameterDecl(PD, VEPS)) .)
      prepImports(IL, VEPS) .
  eq prepImports(nil, VEPS) = nil .

  eq prepModExp(QI, VEPS) = QI .
  eq prepModExp(ME{PL}, VEPS) = prepModExp(ME, empty, empty, PL, VEPS) .
  eq prepModExp(ME + ME', VEPS) 
    = prepModExp(ME, VEPS) + prepModExp(ME', VEPS) .
  eq prepModExp(ME, VEPS) = ME [owise] .

  eq prepModExp(ME, PL, PL', (P, PL''), < P ; S > VEPS) 
    = prepModExp(ME, (PL, S), PL', PL'', < P ; S > VEPS) .
  eq prepModExp(ME, PL, PL', (P, PL''), < P ; S{PL3} > VEPS) 
    = prepModExp(ME, (PL, S{PL3}), PL', PL'', < P ; S{PL3} > VEPS) .
  ceq prepModExp(ME, PL, PL', (P, PL''), < P ; P' ;; VE > VEPS) 
    = prepModExp(ME, (PL, P'), (PL', VE), PL'', < P ; P' ;; VE > VEPS) 
    if VE =/= mtViewExp .
  eq prepModExp(ME, PL, PL', (P, PL''), VEPS) 
    = prepModExp(ME, (PL, P), PL', PL'', VEPS) 
    [owise] .
  eq prepModExp(ME, PL, PL', (QI{PL''}, PL3), VEPS) 
    = prepModExp(ME, (PL, prepViewExp(QI{PL''}, VEPS)), PL', PL3, VEPS) .
  eq prepModExp(ME, PL, empty, empty, VEPS) = ME{PL} .
  eq prepModExp(ME, PL, PL', empty, VEPS) = ME{PL}{PL'} [owise] .

  eq prepParameterDecl(X :: ME, < Y ; Z > VEPS) 
    = if X == Y 
      then (Z :: ME)
      else prepParameterDecl(X :: ME, VEPS) 
      fi .
  eq prepParameterDecl(X :: ME, none) = X :: ME .

  eq prepViewExp(VE, < VE ; VE' > VEPS) = VE' .
  eq prepViewExp(QI, VEPS) = QI [owise] .
  eq prepViewExp(X{PL}, VEPS) = X{prepViewExp(PL, VEPS)} [owise] .
  ceq prepViewExp((VE, PL), VEPS)
    = prepViewExp(VE, VEPS), prepViewExp(PL, VEPS) 
    if VE =/= nil /\ PL =/= nil [owise] .

*** The function \texttt{unitInst} calls the auxiliary function
*** \texttt{unitInstAux}, which proceeds recursively on each of the parameters
*** in the interface of the module being instantiated. For each view, a set of
*** maps to be applied to the module is generated, which are accumulated in 
*** the third argument of the function.

*** In the base case, when there are no more parameters and no more views, the
*** maps for the parameterized sorts are also generated, and all maps are 
*** then applied.

*** \texttt{unitInstAux} proceeds accumulating also the list of parameters
*** being modified, the list of importations, and a list of label-view
*** pairs (\texttt{QidTuple{ViewExp,ViewExp}}) associating each label in
*** the interface to the view used in the instantiation of the theory with
*** such label. This list of pairs is used to generate the set of maps of the
*** parameterized  sorts and to `prepare' the list of importations as 
***  indicated above.

  sort TreatParResult .

  op <_;_;_;_;_;_> : SortMappingSet OpMappingSet ParameterDeclList ImportList 
       Set{Tuple{ViewExp,ViewExp}} Database -> TreatParResult .
  op getSortMappings : TreatParResult -> SortMappingSet .
  op getOpMappings : TreatParResult -> OpMappingSet .
  op getPars : TreatParResult -> ParameterDeclList .
  op getImports : TreatParResult -> ImportList .
  op viewExpPairSet : TreatParResult -> Set{Tuple{ViewExp,ViewExp}} .
  op db : TreatParResult -> Database .

  eq getSortMappings(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = SMS .
  eq getOpMappings(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = OMS .
  eq getPars(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = PDL .
  eq getImports(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = IL .
  eq viewExpPairSet(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = VEPS .
  eq db(< SMS ; OMS ; PDL ; IL ; VEPS ; DB >) = DB .

  op unitInstAux : Module Module OpDeclSet SortMappingSet OpMappingSet ParameterDeclList 
        ParameterDeclList  ImportList  ImportList  ParameterList
        Set{Tuple{ViewExp,ViewExp}}  ParameterDeclList  Database 
        ->  Database .
  op treatPar : ParameterDecl ViewExp  Set{Tuple{ViewExp,ViewExp}} 
        ParameterDeclList  Database  ->  TreatParResult .
  op treatPar2 : ParameterDecl ViewExp  Set{Tuple{ViewExp,ViewExp}} 
        ParameterDeclList  Database  ->  TreatParResult .
  op treatParAux : Qid ModuleExpression ParameterDeclList ViewExp Qid ViewExp 
        ViewExp  ParameterDeclList  SortMappingSet OpMappingSet  ParameterDeclList 
        ImportList  Set{Tuple{ViewExp,ViewExp}}  Database  
        -> TreatParResult .
  op treatParAux2 : Qid ModuleExpression ParameterDeclList ViewExp Qid ViewExp 
        ViewExp ParameterDeclList SortMappingSet OpMappingSet ParameterDeclList ImportList 
        Set{Tuple{ViewExp,ViewExp}} Database -> TreatParResult .

  eq unitInst(ME, PL, PDL, DB)
    = unitInstAux(setName(getTopModule(ME, DB), ME{PL}),
        signature(getFlatModule(ME, DB)), getVars(ME, DB), none, none,
        getPars(getTopModule(ME, DB)), nil,
        getImports(getTopModule(ME, DB)), nil, PL, none, PDL, DB) .

  ceq unitInstAux(U, M, VDS, SMS, OMS, (X :: ME, PDL), PDL', IL, IL'', (QI, PL), VEPS, PDL'', DB)
    = unitInstAux(U, M, VDS, (SMS SMS'), (OMS OMS'), PDL, (PDL', PDL3), IL, (IL'' IL3), PL, (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; PDL3 ; IL3 ; VEPS' ; DB' > := treatPar(X :: ME, QI, VEPS, PDL'', DB) .
  ceq unitInstAux(U, M, VDS, SMS, OMS, (X :: ME, PDL), PDL', IL, IL'', (QI{PL}, PL'), VEPS, PDL'', DB)
    = unitInstAux(U, M, VDS, (SMS SMS'), (OMS OMS'), PDL, (PDL', PDL3), IL, (IL'' IL3), PL', (VEPS VEPS'), PDL'', DB')
    if < SMS' ; OMS' ; PDL3 ; IL3 ; VEPS' ; DB' > := treatPar(X :: ME, QI{PL}, VEPS, PDL'', DB) .
  ceq unitInstAux(U, M, VDS, SMS, OMS, nil, PDL, IL, IL', empty, VEPS, PDL', DB)
    = evalModule(
        setImports(setPars(applyMapsToModule(maps2rens(SMS'), maps2rens(OMS), U, M), PDL), (prepImports(IL, VEPS) IL')), 
        applyMapsToOps(maps2rens(SMS'), maps2rens(OMS), VDS, M), 
        DB) 
    if SMS' := (SMS
                genMapsSorts((getSorts(U) ; getSortSetAux(getImports(U), DB)), VEPS)
                genMapsClasses((getClassNames(getClasses(U)) ; getClassSetAux(getImports(U), DB)), VEPS)) .
  eq unitInstAux(unitError(QIL), UK:[Module], SDV:[OpDeclSet], SMS, OMS, PDL, PDL', IL, IL', PL, VEPS, PDL'', DB)
    = warning(DB, QIL) .
  eq unitInstAux(noModule, unitError(QIL), VDS, SMS, OMS, PDL, PDL', IL, IL', VE, VEPS, PDL'', DB)
    = warning(DB, QIL) .
  eq unitInstAux(U, M, VDS, SMS, OMS, (X :: ME, PDL), PDL', IL, IL', empty, VEPS, PDL'', DB)
    = warning(DB, '\r 'Error: '\o 'Incorrect 'module header2QidList(getName(U)) '. '\n) .
  eq unitInstAux(U, M, VDS, SMS, OMS, nil, PDL, IL, IL', (QI, VE, PL), VEPS, PDL', DB)
    = warning(DB, '\r 'Error: '\o 'Incorrect 'module header2QidList(getName(U)) '. '\n) .
  eq unitInstAux(U, M, VDS, SMS, OMS, PDL, PDL', IL, IL', PL, VEPS, PDL'', DB)
    = DB 
    [owise] .

  eq treatParView(X :: ME, VE, ME', VEPS, PDL, DB)
    = if labelInModExp(X, ME')
      then treatPar(X :: ME, VE, VEPS, PDL, DB)
      else < none ; 
             none ;
             getPars(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             getImports(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             viewExpPairSet(treatPar(X :: ME, VE, VEPS, PDL, DB)) ;
             db(treatPar(X :: ME, VE, VEPS, PDL, DB)) >
      fi .

  op labelInModExp : Qid ModuleExpression -> Bool .
  op labelInViewExp : Qid ViewExp -> Bool .

  eq labelInModExp(X, QI) = X == QI .
  eq labelInModExp(X, ME{VE}) = labelInViewExp(X, VE) .
  eq labelInModExp(X, TUPLE[N]) = false .
  eq labelInModExp(X, POWER[N]) = false .

  eq labelInViewExp(X, QI) = X == QI .
  eq labelInViewExp(X, ((VE, VE'))) 
    = labelInViewExp(X, VE) or-else labelInViewExp(X, VE') .
  eq labelInViewExp(X, QI{VE}) = X == QI or-else labelInViewExp(X, VE) .

  eq treatPar(X :: ME, VE, VEPS, PDL, DB)
    = if VE :: Qid and-then labelInParameterDeclList(VE, PDL)
      then < (genMapsQualSorts(X, VE, getThSorts(ME, DB), VEPS)
              genMapsQualClasses(X, VE, getThClasses(ME, DB), VEPS)) ;
             none ;
             VE :: ME ;
             nil ;
             < X ; VE > ;
             createCopy((VE :: ME), DB) >
      else if viewInDb(VE, DB)
           then if theory(getTopModule(getTo(getView(VE, DB)), DB))
                then < prepare(
                         getSortMappings(getView(VE, DB)), 
                         X, 
                         getThSorts(ME, DB), 
                         getThSorts(getTo(getView(VE, DB)), DB), 
                         getThClasses(getTo(getView(VE, DB)), DB)) ; 
                       prepare(
                         getOpMappings(getView(VE, DB)), 
                         X, 
                         getThSorts(ME, DB), 
                         getThSorts(getTo(getView(VE, DB)), DB), 
                         getThClasses(getTo(getView(VE, DB)), DB)) ; 
                       X :: getTo(getView(VE, DB)) ;
                       nil ;
                       < X ; (VE ;; X) > ;
                       createCopy((X :: getTo(getView(VE, DB))), DB) >
                else < prepare(
                         getSortMappings(getView(VE, DB)), 
                         X, 
                         getThSorts(ME, DB), none, none) ; 
                       prepare(
                         getOpMappings(getView(VE, DB)), 
                         X, 
                         getThSorts(ME, DB), none, none) ; 
                       getPars(getTopModule(getTo(getView(VE, DB)), DB)) ;
                       (protecting getTo(getView(VE, DB)) .) ;
                       < X ; VE > ;
                       DB >
                fi
           else < none ; none ; nil ; nil ; none ; warning(DB, '\r 'Error: '\o 'View VE 'not 'in 'database. '\n) >
           fi
      fi .

  op viewInstAux : View SortMappingSet OpMappingSet ParameterDeclList ParameterDeclList 
       ParameterList Set{Tuple{ViewExp,ViewExp}} ParameterDeclList Database  
       -> Database .
  op treatParView : ParameterDecl ParameterList ModuleExpression  
       Set{Tuple{ViewExp,ViewExp}} ParameterDeclList Database 
       -> TreatParResult .
  op treatParAux : Qid ModuleExpression ParameterList Qid ViewExp ViewExp 
       ParameterList SortMappingSet OpMappingSet ParameterList ImportList 
       Set{Tuple{ViewExp,ViewExp}} Database -> TreatParResult .

  eq viewInst(VE, PL, PDL, DB)
    = viewInstAux(setName(getView(VE, DB), VE{PL}),
        none, none, getPars(getView(VE, DB)), nil, PL, none, PDL, DB) .

  ceq viewInstAux(VI, SMS, OMS, (X :: ME, PDL), PDL', (QI, PL), VEPS, PDL'', DB)
    = viewInstAux(VI, (SMS SMS'), (OMS OMS'), PDL, (PDL', PDL3), PL, (VEPS VEPS'), PDL'', DB') 
    if < SMS' ; OMS' ; PDL3 ; IL ; VEPS' ; DB' > := treatParView(X :: ME, QI, getFrom(VI), VEPS, PDL'', DB) .
  ceq viewInstAux(VI, SMS, OMS, (X :: ME, PDL), PDL', (QI{PL}, PL'), VEPS, PDL'', DB)
    = viewInstAux(VI, SMS SMS', OMS OMS', PDL, (PDL', PDL3), PL', (VEPS VEPS'), PDL'', DB') 
    if < SMS' ; OMS' ; PDL3 ; IL ; VEPS' ; DB' > := treatParView(X :: ME, QI{PL}, getFrom(VI), VEPS, PDL'', DB) .
  ceq viewInstAux(VI, SMS, OMS, nil, PDL, empty, VEPS, PDL', DB)
    = insertView(
        setPars(
          setFrom(
            setTo(
              setSortMappings(
                setOpMappings(VI,
                  applyMapsToMaps(
                    maps2rens(genMapsSorts(getSortSet(getFrom(VI), DB''), VEPS)
                              genMapsClasses(getClassSet(getFrom(VI), DB''), VEPS)),
                    maps2rens(SMS
                              genMapsSorts(getSortSet(getTo(VI), DB''), VEPS)
                              genMapsClasses(getClassSet(getTo(VI), DB''), VEPS)),
                    getOpMappings(VI))),
                applyMapsToMaps(
                  maps2rens(genMapsSorts(getSortSet(getFrom(VI), DB''), VEPS)
                            genMapsClasses(getClassSet(getFrom(VI), DB''), VEPS)),
                  maps2rens(SMS
                            genMapsSorts(getSortSet(getTo(VI), DB''), VEPS)
                            genMapsClasses(getClassSet(getTo(VI), DB''), VEPS)),
                  getSortMappings(VI))),
              prepModExp(getTo(VI), VEPS)),
            prepModExp(getFrom(VI), VEPS)),
          PDL),
        DB'') 
    if < DB'  ; ME'  > := evalModExp(prepModExp(getFrom(VI), VEPS), PDL', DB)
    /\ < DB'' ; ME'' > := evalModExp(prepModExp(getTo(VI), VEPS), PDL', DB') .
  eq viewInstAux(viewError(QIL), SMS, OMS, PDL0:[ParameterDeclList], PDL, PL, VEPS, PDL', DB)
    = warning(DB, QIL) .
  eq viewInstAux(VI, SMS, OMS, (X :: ME, PDL), PDL', empty, VEPS, PDL'', DB)
    = warning(DB, ('\r 'Error: '\o 'Incorrect 'view getName(VI) '. '\n)) .
  eq viewInstAux(VI, SMS, OMS, nil, PDL, (QI, PL), VEPS, PDL', DB)
    = warning(DB, ('\r 'Error: '\o 'Incorrect 'view getName(VI) '. '\n)) .
  eq viewInstAux(VI, SMS, OMS, (X :: ME, PDL), PDL', (QI{PL}, PL'), VEPS, PDL'', DB)
    = warning(DB, ('\r 'Error: '\o 'Wrong 'instantiation getName(VI) '. '\n)) .

  op applyMapsToMaps : RenamingSet RenamingSet SortMappingSet -> SortMappingSet .
  op applyMapsToMaps : RenamingSet RenamingSet OpMappingSet -> OpMappingSet .
  op applyMapsToTerm : RenamingSet TermList -> TermList .

  eq applyMapsToMaps(SRS, SRS', sort S to S' . SMS)
    = (sort applyMapsToType(SRS, S) to applyMapsToType(SRS', S') .
       applyMapsToMaps(SRS, SRS', SMS)) .
  eq applyMapsToMaps(SRS, SRS', class S to S' . SMS)
    = (class applyMapsToType(SRS, S) to applyMapsToType(SRS',S') .
       applyMapsToMaps(SRS, SRS', SMS)) .
  eq applyMapsToMaps(SRS, SRS', SMS) = SMS [owise] .

  eq applyMapsToMaps(SRS, SRS', op_to`term_.(T, T') OMS)
    = (op_to`term_.(applyMapsToTerm(SRS, T), applyMapsToTerm(SRS', T'))  
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', op F : TyL -> Ty to F' . OMS)
    = (op F : applyMapsToTypeList(SRS, TyL) -> applyMapsToType(SRS, Ty) to F' . 
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', msg F : TyL -> S to F' . OMS)
    = (msg F : applyMapsToTypeList(SRS, TyL) -> applyMapsToType(SRS, S) to F' . 
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', attr A . S to A' . OMS)
    = (attr A . applyMapsToType(SRS, S) to A' .
       applyMapsToMaps(SRS, SRS', OMS)) .
  eq applyMapsToMaps(SRS, SRS', OMS) = OMS [owise] .

  eq applyMapsToTerm(SRS, Ct) 
    = qid(string(getName(Ct)) + "." + string(applyMapsToType(SRS, getType(Ct)))) .
  eq applyMapsToTerm(SRS, V) 
    = qid(string(getName(V)) + "." + string(applyMapsToType(SRS, getType(V)))) .
  eq applyMapsToTerm(SRS, qidError(QIL)) = qidError(QIL) .
  ceq applyMapsToTerm(SRS, F[TL]) 
    = F[applyMapsToTerm(SRS, TL)]
    if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq applyMapsToTerm(SRS, '<_:_|_>[O, Ct, T]) 
    = '<_:_|_>[applyMapsToTerm(SRS, O), 
               qid(string(applyMapsToClassName(SRS, getName(Ct))) 
                   + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               applyMapsToTerm(SRS, T)] .
  ceq applyMapsToTerm(SRS, '<_:_|_>[O, C, T]) 
    = '<_:_|_>[applyMapsToTerm(SRS, O), 
               applyMapsToClassName(SRS, C), 
               applyMapsToTerm(SRS, T)] 
    if not C :: Constant .
  eq applyMapsToTerm(SRS, '<_:_|`>[O, Ct]) 
    = '<_:_|_>[applyMapsToTerm(SRS, O), 
               qid(string(applyMapsToClassName(SRS, getName(Ct)))
                   + "." + string(applyMapsToClassName(SRS, getType(Ct)))),
               'none.AttributeSet] .
  ceq applyMapsToTerm(SRS, '<_:_|`>[O, C]) 
    = '<_:_|_>[applyMapsToTerm(SRS, O), 
               applyMapsToClassName(SRS, C), 
               'none.AttributeSet] 
    if not C :: Constant .

  ceq applyMapsToTerm(SRS, (T, TL)) 
    = (applyMapsToTerm(SRS, T), applyMapsToTerm(SRS, TL)) 
    if TL =/= empty .

*** As pointed out in Section~\ref{module-names}, for each new module
*** expression constructor being introduced, we need to add equations for the
*** operator \texttt{header2Qid}. Since the function to transform view
*** expressions into lists of quoted identifiers was already defined in 
*** Section~\ref{VIEW-EXPR}, we just need to add the following equation.

  eq header2Qid((ME { PL })) 
    = qidList2Qid(header2Qid(ME) '`{ parameterList2Qid(PL) '`}) .
  ceq header2QidList((ME { PL })) 
    = (if QI == '\s then QIL else QIL QI fi 
       '`{ parameterList2QidList(PL) '`} '\s) 
    if QIL QI := header2QidList(ME) .
 
*** Given a module expression of the form \verb~ME{VE}~ such that
*** \texttt{ME} is in the database, we need to add \verb~ME{VE}~ to the set
*** of names of the modules depending on \texttt{ME} and on \texttt{VE}.
*** Since \texttt{VE} may be a composed view expression, we have to add the
*** name of the module  to each of the views in it. In this way, if \texttt{ME}
*** or any of the  views in \texttt{VE} is redefined or removed from the
*** database,  \verb~ME{VE}~ will be removed as well.

  eq setUpModExpDeps(ME{PL}, 
      db(< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME{PL}, PL,
        db(< ME ; DT ; U ; U' ; M ; VDS ; (MNS . ME{PL}) ; VES > MIS, 
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps(ME{PL}, 
      db(< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', 
         VIS, VES', MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME{PL}, PL,
        db(< ME ; DM ; U ; U' ; M ; VDS ; (MNS . ME{PL}) ; VES > MIS, 
           MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, DB)
    = setUpModExpDeps('META-LEVEL{PL}, PL, DB) .
  eq setUpModExpDeps('META-LEVEL{QI}, 
       db(< QI ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< QI ; DT ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{QI} ; VES > 
          MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps('META-LEVEL{QI}, 
       db(< QI ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< QI ; DM ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{QI} ; VES > 
          MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  ceq setUpModExpDeps(ME{PL}, DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    if (ME =/= 'META-LEVEL) /\ (not unitInDb(ME, DB)) .

  eq setUpModExpDeps('META-LEVEL{PL}, (QI, PL'),
       db(< QI ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModExpDeps('META-LEVEL{PL}, PL',
        db(< QI ; DT ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{PL} ; VES >
           MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, (QI, PL'),
       db(< QI ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS', 
          VIS, VES', MNS'', MNS3, MNS4, QIL))
    = setUpModExpDeps('META-LEVEL{PL}, PL',
        db(< QI ; DM ; U ; U' ; M ; VDS ; MNS . 'META-LEVEL{PL} ; VES >
           MIS, MNS', VIS, VES', MNS'', MNS3, MNS4, QIL)) .
  eq setUpModExpDeps('META-LEVEL{PL}, nil, DB) = DB .

  op viewExpDeps : Header ViewExp Database -> Database .

----  eq viewExpDeps(ME, VE, 
----        db(MIS, MNS, 
----           < VE ; DT ; VI ; MNS' ; VES > VIS, VES', 
----           MNS'', MNS3, MNS4, QIL))
----    = db(MIS, MNS, < VE ; DT ; VI ; MNS' . ME ; VES > VIS, VES', 
----         MNS'', MNS3, MNS4, QIL) .
  eq viewExpDeps(ME, (VE, PL), 
        db(MIS, MNS, 
           < VE ; DT ; VI ; MNS' ; VES > VIS, VES', 
           MNS'', MNS3, MNS4, QIL))
    = viewExpDeps(ME, PL, 
        db(MIS, MNS, 
           < VE ; DT ; VI ; MNS' . ME ; VES > VIS, VES', 
           MNS'', MNS3, MNS4, QIL)) .
----  eq viewExpDeps(ME, VE, DB) = DB [owise] .
  eq viewExpDeps(ME, (VE, PL), DB) = viewExpDeps(ME, PL, DB) [owise] .
  eq viewExpDeps(ME, empty, DB) = DB .

endfm

*******************************************************************************

***
*** 6.10 Renaming of Modules
***

*** In addition to the declaration of the constructor for renaming module
*** expressions, the following module \texttt{RENAMING-EXPR-EVALUATION}
*** introduces equations to treat this new case in the definition of functions
*** \texttt{evalModExp}, \texttt{header2QidList}, \texttt{prepHeader}, and 
*** \texttt{setUpModuleDeps}.

*** A renaming expression is evaluated by applying the renaming maps, not only
*** to the top unit, but also to the part of the structure \emph{affected} by
*** the maps. The renaming process propagates downwards in the unit hierarchy
*** while the units in the structure are affected by the renamings. We say that
*** a unit is affected by a set of maps (checked by the \texttt{modAffd}
*** function) when any of the maps is applicable to any of the declarations in
*** the unit, or in any of its subunits. The application of a set of maps to a
*** single unit is accomplished by the \texttt{applyMapsToModule} function, 
*** discussed in Section~\ref{applyMapsToModule}.

fmod RENAMING-EXPR-EVALUATION is
  pr DATABASE .
  pr RENAMING-SET-APPL-ON-UNIT .
  pr EVALUATION .
  inc MOD-EXPR .
  pr MOD-EXPR-EVAL .
  pr INST-EXPR-EVALUATION .
  pr FMAP .

  vars ME ME' : ModuleExpression .
  var  MNS MNS' MNS'' MNS3 MNS4 : Set{ModuleName} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars M M' : Module .
  vars PU U U' DM : Module .
  vars DB DB' : Database .
  var  QIL : QidList .
  vars VES VES' : Set{ViewExp} .
  var  PL : ParameterList .
  var  PDL : ParameterDeclList .
  vars PDS PDS' : Set{ParameterDecl} .
  var  I : Import .
  vars IL IL' : ImportList .
  var  R : Renaming .
  vars RS RS' RS'' RS3 : RenamingSet .
  var  VEPS : Set{Tuple{ViewExp,ViewExp}} .
  vars X QI QI' QI'' F F' F'' L L' L'' A A' A'' : Qid .
  vars S S' S'' C C' C'' : Sort .
  var  K : Kind .
  vars SS : SortSet .
  vars TyL TyL' : TypeList .
  vars Ty Ty' : Type .
  vars T T' T'' T3 : Term .
  var  DT : Default{Term} .
  var  TL : TermList .
  var  OPD : OpDeclSet .
  vars OPDS VDS : OpDeclSet .
  vars AtS AtS' : AttrSet .
  var  Rl : Rule .
  var  RlS : RuleSet .
  var  CD : ClassDecl .
  var  CDS : ClassDeclSet .
  var  ADS : AttrDeclSet .
  var  MD : MsgDecl .
  var  MDS : MsgDeclSet .
  var  N : Nat .
  var  NL : IntList .
  var  Hk : Hook .
  var  HkL : HookList .
  var  B : Bool .
  var  St : String .

*** The function \texttt{crtCopyRen} creates a copy of the part of the
*** structure of the specified module which is affected by the renaming,
*** applying to each of the generated modules in the new structure the subset
*** of maps affecting each one of them. The equation extending the
*** \texttt{evalModExp} function to the renaming module expression is then 
*** reduced to a call to \texttt{crtCopyRen} with the appropriate 
*** arguments.

  eq labelInModExp(X, ME * (RS)) = labelInModExp(X, ME) .

  op crtCopyRen : ModuleExpression RenamingSet Database -> Database .

  ceq evalModExp(ME * (RS), PDL, DB) 
    = if unitInDb(ME' * (RS''), DB') 
      then < DB' ; ME' * (RS'') >
      else < crtCopyRen(ME', RS', DB') ; ME' * (RS'') >
      fi 
    if < DB' ; ME' > := evalModExp(ME, PDL, DB)
       /\ RS' := fixMaps(RS, ME', DB') 
       /\ RS'' := canMaps(RS', getFlatModule(ME', DB')) .

  eq crtCopyRen(ME, none, DB) = DB .
  ceq crtCopyRen(ME, RS, DB)
    = if unitInDb(_*`(_`)(ME, RS'), DB) 
      then DB
      else applyMapsRec(
             RS, 
             getImports(getTopModule(ME, DB)), 
             nil,
             setName(
               applyMapsToModuleAux(RS'', RS3, 
                 getTopModule(ME, DB), getFlatModule(ME, DB)), 
               _*`(_`)(ME, RS')), 
             applyMapsToOps(RS'', RS3, 
               getVars(ME, DB), getFlatModule(ME, DB)),
             DB)
      fi 
    if RS' := canMaps(RS, getFlatModule(ME, DB)) 
       /\ < RS'' ; RS3 > := splitMaps(RS') .

  op canMaps : RenamingSet Module -> RenamingSet .
  eq canMaps(op F : TyL -> Ty to F' [AtS], M)
    = op F : canKinds(TyL, M) -> canKinds(Ty, M) to F' [AtS] .
  eq canMaps((op F : TyL -> Ty to F' [AtS], RS), M)
    = (op F : canKinds(TyL, M) -> canKinds(Ty, M) to F' [AtS],
       canMaps(RS, M)) .
  eq canMaps(msg F : TyL -> Ty to F', M)
    = msg F : canKinds(TyL, M) -> canKinds(Ty, M) to F' .
  eq canMaps((msg F : TyL -> Ty to F', RS), M)
    = (msg F : canKinds(TyL, M) -> canKinds(Ty, M) to F',
       canMaps(RS, M)) .
  eq canMaps(R:Renaming, M) = R:Renaming [owise] .
  eq canMaps((R:Renaming, RS), M) 
    = (R:Renaming, canMaps(RS, M)) 
    [owise] .
  eq canMaps(none, M) = none .

  op canKinds : TypeList Module -> [TypeList] .
  ---- eq canKinds(K:Kind TyL, M) 
  ----   = kind(maximalSorts(M, K:Kind)) canKinds(TyL, M) .
  eq canKinds(nil, M) = nil .
  eq canKinds(cc(S ; SS) TyL, M)
    = kind(maximalSorts(M, getKind(M, S))) canKinds(TyL, M) .
  ----eq canKinds(TyL, M) = nil [owise] .

*** We proceed downwards while the set of maps affects the module, but we do so
*** restricting the set of maps to the subset affecting the module. Since
*** operator and message maps in which arity and coarity are specified must be
*** applied to the whole subsort-overloaded family of operators or messages, we
*** have to carry along the signature of the module at the top to make all the
*** calls to the engine. Note that we may have maps of operations or messages
*** with the domain given by sorts that are not in the submodules but which 
*** have other sorts in the submodules in the same connected components.

  op applyMapsRec : RenamingSet ImportList ImportList Module OpDeclSet Database -> Database .

  eq applyMapsRec(RS, ((including ME .) IL), IL', U, VDS, DB) 
   = applyMapsRec(
       RS, IL, 
       including ME *( canMaps(fixMaps(RS, ME, DB), 
                               getFlatModule(ME, DB)) ) . IL', 
       U, VDS,  
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, ((extending ME .) IL), IL', U, VDS, DB) 
   = applyMapsRec(
       RS, IL, 
       extending ME *( canMaps(fixMaps(RS, ME, DB), 
                               getFlatModule(ME, DB)) ) . IL', 
       U, VDS,  
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, ((protecting ME .) IL), IL', U, VDS, DB) 
   = applyMapsRec(
       RS, IL, 
       protecting ME *( canMaps(fixMaps(RS, ME, DB), 
                               getFlatModule(ME, DB)) ) . IL', 
       U, VDS,  
       crtCopyRen(ME, fixMaps(RS, ME, DB), DB)) .
  eq applyMapsRec(RS, (I IL), IL', U, VDS, DB) 
    = applyMapsRec(RS, IL, (I IL'), U, VDS, DB) 
    [owise] .
  eq applyMapsRec(RS, nil, IL, U, VDS, DB) 
    = evalModule(setImports(U, IL), VDS, DB) .
  eq applyMapsRec(RS, IL, IL', unitError(QIL), VDS, DB) 
    = warning(DB, QIL) .

  op fixMaps : [RenamingSet] ModuleExpression Database -> RenamingSet .
  op fixMaps2 : [RenamingSet] Module ClassDeclSet MsgDeclSet -> RenamingSet .

  ceq fixMaps(RS, ME, DB) 
    = fixMaps2(RS, getFlatModule(ME, DB), CDS, MDS) 
    if < CDS ; MDS > := getAllClassesAndMsgs(ME, DB) .

  eq fixMaps2(op F to F' [AtS], M, CDS, MDS) 
    = opsAffd(getOps(M), op F to F' [AtS], M) .
  eq fixMaps2((op F to F' [AtS], RS), M, CDS, MDS)
    = (opsAffd(getOps(M), op F to F' [AtS], M), 
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(op F : TyL -> Ty to F' [AtS], M, CDS, MDS)
    = opsAffd(getOps(M), op F : TyL -> Ty to F' [AtS], M) .
  eq fixMaps2((op F : TyL -> Ty to F' [AtS], RS), M, CDS, MDS)
    = (opsAffd(getOps(M), op F : TyL -> Ty to F' [AtS], M),
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(msg F to F', M, CDS, MDS) 
    = msgsAffd(MDS, msg F to F', M) .
  eq fixMaps2((msg F to F', RS), M, CDS, MDS)
    = (msgsAffd(MDS, msg F to F', M), fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(msg F : TyL -> Ty to F', M, CDS, MDS)
    = msgsAffd(MDS, msg F : TyL -> Ty to F', M) .
  eq fixMaps2((msg F : TyL -> Ty to F', RS), M, CDS, MDS)
    = (msgsAffd(MDS, msg F : TyL -> Ty to F', M),
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(sort Ty to Ty', M, CDS, MDS)
    = if sortsAffd(getSorts(M), sort Ty to Ty')
      then (sort Ty to Ty')
      else none
      fi .
  eq fixMaps2(((sort Ty to Ty'), RS), M, CDS, MDS)
    = (if sortsAffd(getSorts(M), sort Ty to Ty')
       then (sort Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(class Ty to Ty', M, CDS, MDS)
    = if classesAffd(CDS, class Ty to Ty')
      then (class Ty to Ty')
      else none
      fi .
  eq fixMaps2(((class Ty to Ty'), RS), M, CDS, MDS)
    = (if classesAffd(CDS, class Ty to Ty')
       then (class Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(attr A . Ty to Ty', M, CDS, MDS)
    = if classesAffd(CDS, attr A . Ty to Ty')
      then (attr A . Ty to Ty')
      else none
      fi .
  eq fixMaps2(((class A . Ty to Ty'), RS), M, CDS, MDS)
    = (if classesAffd(CDS, attr A . Ty to Ty')
       then (attr A . Ty to Ty')
       else none
       fi,
       fixMaps2(RS, M, CDS, MDS)) .
  eq fixMaps2(R:Renaming, M, CDS, MDS) = R:Renaming [owise] .
  eq fixMaps2((R:Renaming, RS), M, CDS, MDS) 
    = (R:Renaming, fixMaps2(RS, M, CDS, MDS)) 
    [owise] .
  eq fixMaps2(none, M, CDS, MDS) = none .

  sort Tuple{ClassDeclSet, MsgDeclSet} .
  op <_;_> : ClassDeclSet MsgDeclSet -> Tuple{ClassDeclSet, MsgDeclSet} .
  op getClasses : Tuple{ClassDeclSet, MsgDeclSet} -> ClassDeclSet .
  op getMsgs : Tuple{ClassDeclSet, MsgDeclSet} -> MsgDeclSet .
  eq getClasses(< CDS ; MDS >) = CDS .
  eq getMsgs(< CDS ; MDS >) = MDS .

  op getAllClassesAndMsgs : 
       ModuleExpression Database -> Tuple{ClassDeclSet, MsgDeclSet} .
  op getAllClassesAndMsgs : 
       ImportList Database -> Tuple{ClassDeclSet, MsgDeclSet} .

  eq getAllClassesAndMsgs(ME, DB)
    = if getTopModule(ME, DB) :: OModule
         and-then not getTopModule(ME, DB) :: SModule
      then < getClasses(
               getAllClassesAndMsgs(getImports(getTopModule(ME, DB)), DB))
             getClasses(getTopModule(ME, DB)) 
             ;
             getMsgs(
               getAllClassesAndMsgs(getImports(getTopModule(ME, DB)), DB))
             getMsgs(getTopModule(ME, DB)) >
      else < none ; none >
      fi .

  eq getAllClassesAndMsgs(I IL, DB)
    = < getClasses(getAllClassesAndMsgs(moduleName(I), DB))
        getClasses(getAllClassesAndMsgs(IL, DB))
        ;
        getMsgs(getAllClassesAndMsgs(moduleName(I), DB))
        getMsgs(getAllClassesAndMsgs(IL, DB)) > .
  eq getAllClassesAndMsgs((nil).ImportList, DB) = < none ; none > .

----  sorts NeSet<TypeList> Set<TypeList> .
----  subsort TypeList < NeSet<TypeList> < Set<TypeList> .
----  op noneTLS : -> Set<TypeList> [ctor] .
----  op _!_ : Set<TypeList> Set<TypeList> -> Set<TypeList>
----     [ctor assoc comm id: noneTLS] .
----  op _!_ : NeSet<TypeList> NeSet<TypeList> -> NeSet<TypeList>
----     [ctor assoc comm id: noneTLS] .

----  sort Set<Type> .
----  subsorts Type SortSet < Set<Type> .
----  op _o_ : Set<Type> Set<Type> -> Set<Type> [ctor assoc comm id: none] .
----
----  eq Ty o Ty = Ty .

  sort TypeSetList .
  subsort TypeSet < TypeSetList .
  op nilTSL : -> TypeSetList [ctor] .
  op _l_ : TypeSetList TypeSetList -> TypeSetList
     [ctor assoc id: nilTSL] .

  var  TS : TypeSet .
  var  TSL : TypeSetList .
  var  TLS : TypeListSet .
----  var  NTLS : NeTypeListSet .

----  eq TyL ! TyL = TyL .

  ----eq _!_(qidError(QIL), NTLS) = qidError(QIL) .

  op fixKinds : TypeList Module -> TypeListSet .
  op fixKinds : TypeList TypeSetList Module -> TypeListSet .
  op fixKindsAux : Type Module -> TypeSet .
  op fixKindsAux2 : SortSet Module -> TypeSet .
  op unfold : TypeSetList -> TypeListSet .
  op add : TypeSet TypeListSet -> TypeListSet .

  eq fixKinds(TyL, M) = fixKinds(TyL, nilTSL, M) .

  eq fixKinds(Ty TyL, TSL, M) 
    = if fixKindsAux(Ty, M) == nil
      then none
      else fixKinds(TyL, TSL l fixKindsAux(Ty, M), M)
      fi .
  eq fixKinds(nil, TSL, M) = unfold(TSL) .

  eq fixKindsAux(S, M) 
    = if S in getSorts(M) 
      then cc(connectedSorts(M, S)) 
      else none 
      fi .
  eq fixKindsAux(K, M) = fixKindsAux2(getSorts(K), M) .
  eq fixKindsAux(cc(SS), M) = fixKindsAux2(SS, M) .

  eq fixKindsAux2((S ; SS), M) 
    = (if S in getSorts(M) 
       then cc(connectedSorts(M, S)) 
       else none 
       fi 
       ;
       fixKindsAux2(SS, M)) .
  eq fixKindsAux2(none, M) = none .

  ceq unfold(TS l TSL) = add(TS, unfold(TSL)) if TS =/= none .
  eq unfold(nilTSL) = none .

  ceq add(Ty, TyL ; TLS) = add(Ty, TyL) ; add(Ty, TLS) if TLS =/= none .
  eq add(Ty ; Ty' ; TS, TLS) = add(Ty, TLS) ; add(Ty' ; TS, TLS) .
  eq add(none, TLS) = nilTSL .
  eq add(Ty, none) = Ty .
  eq add(Ty, TyL) = Ty TyL .

  op connectedSorts : Module Type -> SortSet .
  op connectedSorts : Module SortSet Type -> SortSet .
  eq connectedSorts(M, Ty) = connectedSorts(M, getSorts(M), Ty) .
  eq connectedSorts(M, S ; SS, Ty)
    = if sameKind(M, S, Ty) 
      then S 
      else none 
      fi ; connectedSorts(M, SS, Ty) .
  eq connectedSorts(M, none, Ty) = none .

  op sortsAffd : SortSet Renaming -> Bool .
  op opsAffd : OpDeclSet Renaming Module -> RenamingSet .
  op opsAffdAux : OpDeclSet Qid TypeListSet Qid AttrSet Module -> RenamingSet .

  eq sortsAffd((S ; SS), (sort S to S')) = true .
  eq sortsAffd(SS, (sort S to S')) = false [owise] .

  eq opsAffd(op F : TyL -> Ty [AtS] . OPDS, op F to F' [AtS'], M)
    = op F to F' [AtS'] .
  eq opsAffd(OPDS, op F : TyL -> Ty to F' [AtS], M) 
    = opsAffdAux(OPDS, F, fixKinds(TyL Ty, M), F', AtS, M) .
  eq opsAffd(OPDS, RS:[RenamingSet], M) = none [owise] .

  eq opsAffdAux(op F : TyL -> Ty [AtS] . OPDS, 
       F, (TyL' Ty') ; TLS, F', AtS', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (op F : TyL' -> Ty' to F' [AtS'],
            opsAffdAux(OPDS, F, TLS, F', AtS', M))
      else (opsAffdAux(OPDS, F, (TyL' Ty') ; TLS, F', AtS', M),
            opsAffdAux(op F : TyL -> Ty [AtS] . OPDS, F, TLS, F', AtS', M))
      fi .
  eq opsAffdAux(OPDS, F, TLS, F', AtS, M) = none [owise] .

*** The predicate \texttt{modAffd} checks whether the module with the
*** name given as first argument in the database is affected by the set of maps
*** given as second argument. A module is affected by a map set if any of the
*** maps is applicable to the module or to any of its submodules.

  op modAffd : Header RenamingSet Module Database -> Bool .

  op modAffdAux : Module RenamingSet Module Database -> Bool .
  op rlsAffd : RuleSet RenamingSet -> Bool .
  op importsAffd : ImportList RenamingSet Module Database -> Bool .
  op classesAffd : ClassDeclSet RenamingSet -> Bool .
  op msgsAffd : MsgDeclSet RenamingSet Module -> RenamingSet .
  op msgsAffdAux : MsgDeclSet Qid TypeListSet Qid Module -> RenamingSet .

  eq modAffd(ME, RS, M, DB) 
    = modAffdAux(getTopModule(ME, DB), RS, M, DB) .

  eq modAffdAux(U, RS, M, DB) 
    = sortsAffd(getSorts(U), RS) 
      or-else 
      (opsAffd(getOps(U), RS, M) == none 
       or-else 
       ((not U :: FModule
         and-then
         (rlsAffd(getRls(U), RS) 
          or-else
          (not U :: SModule
           and-then
           (classesAffd(getClasses(U), RS) 
            or-else 
            msgsAffd(getMsgs(U), RS, M) == none))))
        or-else 
        importsAffd(getImports(U), RS, M, DB))) .

  eq importsAffd(((including ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB) 
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(((extending ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB) 
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(((protecting ME .) IL), RS, M, DB)
    = modAffd(ME, RS, M, DB) 
      or-else importsAffd(IL, RS, M, DB) .
  eq importsAffd(nil, RS, M, DB) = false .

  eq rlsAffd(((rl T => T' [label(L) AtS] .) RlS), (label L' to L'')) 
    = (L == L') or-else rlsAffd(RlS, label L' to L'') .
  eq rlsAffd(((rl T => T' [label(L) AtS] .) RlS), 
       ((label L' to L''), RS)) 
    = (L == L') or-else
      (rlsAffd((rl T => T' [label(L) AtS] .), RS) or-else
       rlsAffd(RlS, ((label L' to L''), RS))) .
  eq rlsAffd(((crl T => T' if T'' = T3 [label(L) AtS] .) RlS), 
       (label L' to L''))
    = (L == L') or-else rlsAffd(RlS, (label L' to L'')) .
  eq rlsAffd(((crl T => T' if T'' = T3 [label(L) AtS] .) RlS), 
       ((label L' to L''), RS))
    = (L == L') 
      or-else
      (rlsAffd((crl T => T' if T'' = T3 [label(L) AtS] .), RS) 
      or-else
      rlsAffd(RlS, ((label L' to L''), RS))) .
  eq rlsAffd(RlS, RS) = false [owise] .

  eq classesAffd(((class C | ADS .) CDS), (class C' to C''))
    = (C == C') 
      or-else 
      classesAffd(CDS, (class C' to C'')) .
  eq classesAffd(((class C | ADS .) CDS), ((class C' to C''), RS))
    = (C == C') 
      or-else 
      (classesAffd((class C | ADS .), RS) 
      or-else 
      classesAffd(CDS, ((class C' to C''), RS))) .
  eq classesAffd(((class C | ((attr A : S), ADS) .) CDS), 
       (attr A' . C' to A''))
    = if C == C'
      then (A == A') 
           or-else 
           classesAffd(((class C | ADS .) CDS), (attr A' . C' to A''))
      else classesAffd(CDS, (attr A' . C' to A''))
      fi .
  eq classesAffd(((class C | ((attr A : S), ADS) .) CDS), 
       ((attr A' . C' to A''), RS))
    = if C == C'
      then (A == A') 
           or-else 
           (classesAffd(((class C | ADS .) CDS), 
              ((attr A' . C' to A''), RS))
           or-else 
           classesAffd(CDS, RS))
      else classesAffd((class C | ((attr A : S), ADS) .), RS)
           or-else
           classesAffd(CDS, ((attr A' . C' to A''), RS))
      fi .
  eq classesAffd(CDS, RS) = false [owise] .

  eq msgsAffd(msg F : TyL -> Ty . MDS, msg F to F', M) = msg F to F' .
  eq msgsAffd(MDS, msg F : TyL -> Ty to F', M) 
    = msgsAffdAux(MDS, F, fixKinds(TyL Ty, M), F', M) .
  eq msgsAffd(MDS, RS:[RenamingSet], M) = none [owise] .

  eq msgsAffdAux(msg F : TyL -> Ty . MDS, F, (TyL' Ty') ; TLS, F', M)
    = if sameKind(M, (TyL Ty), (TyL' Ty'))
      then (msg F : TyL' -> Ty' to F',
            msgsAffdAux(MDS, F, TLS, F', M))
      else (msgsAffdAux(MDS, F, (TyL' Ty') ; TLS, F', M),
            msgsAffdAux(msg F : TyL -> Ty . MDS, F, TLS, F', M))
      fi .
  eq msgsAffdAux(MDS, F, TLS, F', M) = none [owise] .

*** The function \texttt{mapsRestrict} returns the subset of the view
*** maps given as second argument that affect the given module.

  op mapsRestrict : Module RenamingSet Module Database -> RenamingSet .
  op mapsRestrict : Header RenamingSet Module Database -> RenamingSet .

  eq mapsRestrict(ME, RS, M, DB)
    = mapsRestrict(getTopModule(ME, DB), RS, M, DB) .

  eq mapsRestrict(U, R, M, DB)
    = if modAffdAux(U, R, M, DB)
      then R
      else none
      fi .
  eq mapsRestrict(U, (R, RS), M, DB)
    = if modAffdAux(U, R, M, DB)
      then (R, mapsRestrict(U, RS, M, DB))
      else mapsRestrict(U, RS, M, DB)
      fi .
  eq mapsRestrict(U, none, M, DB) = none .

*** The definition of the function \texttt{header2QidList} on the renaming
*** module expression has to take care of transforming into a quoted identifier
*** list the set of view maps given in the module expression.

  op maps2QidList : RenamingSet -> QidList .

  op attrSet2QidList : AttrSet -> QidList .
  op hookList2QidList : HookList -> QidList .
  op termList2QidList : TermList -> QidList .
  op intList2QidList : IntList -> QidList .
  op typeList2QidList : TypeList -> QidList .

  eq maps2QidList(((op F to F' [AtS]), RS))
    = if AtS == none 
      then ('op F 'to F' '`, '\s maps2QidList(RS))
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`] '`, '\s 
            maps2QidList(RS))
      fi
    [owise] .
  eq maps2QidList((op F to F' [AtS]))
    = if AtS == none 
      then ('op F 'to F')  
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`]) 
      fi .
  eq maps2QidList(((op F : TyL -> Ty to F' [AtS]), RS))
    = if AtS == none 
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F' '`, 
            '\s maps2QidList(RS))
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F' 
            '`[ attrSet2QidList(AtS) '`] '`, '\s maps2QidList(RS))
      fi 
    [owise] .
  eq maps2QidList((op F : TyL -> Ty to F' [AtS]))
    = if AtS == none 
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F')
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F' 
            '`[ attrSet2QidList(AtS) '`]) 
      fi .
  eq maps2QidList(((sort S to S'), RS))
    = ('sort S 'to S' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((sort S to S')) = ('sort S 'to S') .

  eq maps2QidList(((label L to L'), RS))
    = ('label L 'to L' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((label L to L')) = ('label L 'to L') .

  eq maps2QidList(((msg F to F'), RS))
    = ('msg F 'to F' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((msg F to F')) = ('msg F 'to F') .

  eq maps2QidList(((msg F : TyL  -> Ty to F'), RS))
    = ('msg F ': typeList2QidList(TyL) '-> Ty 'to F' '`, '\s 
       maps2QidList(RS))
    [owise] .
  eq maps2QidList((msg F : TyL -> Ty to F'))
    = ('msg F ': typeList2QidList(TyL) '-> Ty 'to F') .

  eq maps2QidList(((class S to S'), RS))
    = ('class S 'to S' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((class S to S')) = ('class S 'to S') .

  eq maps2QidList(((attr QI . S to QI'), RS))
    = ('attr S '. QI 'to QI' '`, '\s maps2QidList(RS))
    [owise] .
  eq maps2QidList((attr QI . S to QI')) = ('attr S '. QI 'to QI') .

  eq maps2QidList(none) = nil .

  eq attrSet2QidList(none) = nil .
  eq attrSet2QidList((assoc AtS)) = ('assoc attrSet2QidList(AtS)) .
  eq attrSet2QidList((comm AtS))  = ('comm attrSet2QidList(AtS)) .
  eq attrSet2QidList((idem AtS))  = ('idem attrSet2QidList(AtS)) .
  eq attrSet2QidList((iter AtS))  = ('iter attrSet2QidList(AtS)) .
  eq attrSet2QidList((id(T) AtS)) 
    = ('id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((right-id(T) AtS)) 
    = ('right-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((left-id(T) AtS))  
    = ('left-id: termList2QidList(T) attrSet2QidList(AtS)) .
  eq attrSet2QidList((poly(NL) AtS))
    = ('poly '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((strat(NL) AtS))
    = ('strat '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((memo AtS))  = ('memo attrSet2QidList(AtS)) .
  eq attrSet2QidList((prec(N) AtS))  
    = ('prec intList2QidList(N) attrSet2QidList(AtS)) .
  eq attrSet2QidList((gather(QIL) AtS)) 
    = ('gather QIL attrSet2QidList(AtS)) .
  eq attrSet2QidList((format(QIL) AtS)) 
    = ('format QIL attrSet2QidList(AtS)) .
  eq attrSet2QidList((ctor AtS))  = ('ctor attrSet2QidList(AtS)) .
  eq attrSet2QidList((frozen(NL) AtS))
    = ('frozen '`( intList2QidList(NL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((config AtS))  = ('config attrSet2QidList(AtS)) .
  eq attrSet2QidList((object AtS))  = ('object attrSet2QidList(AtS)) .
  eq attrSet2QidList((msg AtS))  = ('msg attrSet2QidList(AtS)) .
  eq attrSet2QidList((special(HkL) AtS))
    = ('special '`( hookList2QidList(HkL) '`) attrSet2QidList(AtS)) .
  eq attrSet2QidList((none).AttrSet) = nil .
  eq attrSet2QidList((metadata(St) AtS)) = (('metadata qid("\"" + St + "\"")) attrSet2QidList(AtS)) .
  eq attrSet2QidList((nonexec AtS))  = ('nonexec attrSet2QidList(AtS)) .
  eq attrSet2QidList((variant AtS))  = ('variant attrSet2QidList(AtS)) .

  eq hookList2QidList((id-hook(QI, QIL) HkL))
    = ('id-hook QI '`, '`( QIL '`) hookList2QidList(HkL)) .
  eq hookList2QidList((op-hook(QI, QI', QIL, QI'') HkL))
    = ('op-hook QI '`( QI' ': QIL '-> QI'' '`) hookList2QidList(HkL)) .
  eq hookList2QidList((term-hook(QI, T) HkL))
    = ('term-hook '`( QI '`, termList2QidList(T) '`) hookList2QidList(HkL)) .

  eq termList2QidList(QI) = QI .
  eq termList2QidList(F[TL]) = (F '`( termList2QidList(TL) '`)) .
  ceq termList2QidList((T, TL)) 
    = (termList2QidList(T) '`, termList2QidList(TL)) 
    if TL =/= empty .

  eq intList2QidList((N NL)) = (qid(string(N, 10)) intList2QidList(NL)) .
  eq intList2QidList(nil) = nil .

  eq typeList2QidList(Ty TyL) = type2qid(Ty) typeList2QidList(TyL) .
  eq typeList2QidList(nil) = nil .

*** Let us now give the equations for \texttt{setUpModExpDeps} on the
*** renaming module expression.  Given a module expression of the form
*** \verb~ME *< RS >~ such that \texttt{ME} is in the database, we just need
*** to add \verb~ME *< RS >~ to the set of names of the modules depending on
*** \texttt{ME}. In this way, if \texttt{ME} is redefined or removed from the 
*** database, \verb~ME *< RS >~ will be removed as well.

  eq setUpModExpDeps(ME * (RS), 
       db(< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DT ; U ; U' ; M ; VDS ; MNS . ME * (RS) ; VES > MIS, 
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  eq setUpModExpDeps(ME * (RS), 
       db(< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, 
          MNS', VIS, VES', MNS'', MNS3, MNS4, QIL))
    = db(< ME ; DM ; U ; U' ; M ; VDS ; MNS . ME * (RS) ; VES > MIS, 
         MNS', VIS, VES', MNS'', MNS3, MNS4, QIL) .
  ceq setUpModExpDeps(ME * (RS), DB)
    = warning(DB, '\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n)
    if not unitInDb(ME, DB) .

*** The definition of the \texttt{prepHeader} function on a renaming module
*** expression must take into account the possibility of having parameterized
*** sorts or parameterized class names in the maps of a renaming module
*** expression.  The preparation of a renaming module expression must take
*** into account this fact and prepare accordingly all parameterized sorts and 
*** classes appearing in it.

  op prepare : RenamingSet Set{Tuple{ViewExp,ViewExp}} -> RenamingSet .

  op prepare : TypeList Set{Tuple{ViewExp,ViewExp}} -> TypeList .

  eq prepModExp(ME * (RS), VEPS)
    = _*`(_`)(prepModExp(ME, VEPS), prepare(RS, VEPS)) .

*** For example, for sort maps the equation is as follows.

  eq prepare((sort S to S'), VEPS)
    = (sort prepSort(S, VEPS) to prepSort(S', VEPS)) .
  eq prepare(((sort S to S'), RS), VEPS)
    = ((sort prepSort(S, VEPS) to prepSort(S', VEPS)), 
       prepare(RS, VEPS)) .


  eq prepare((class S to S'), VEPS)
    = (class prepSort(S, VEPS) to prepSort(S', VEPS)) .
  eq prepare(((class S to S'), RS), VEPS)
    = ((class prepSort(S, VEPS) to prepSort(S', VEPS)), 
       prepare(RS, VEPS)) .
  eq prepare((attr QI . S to QI'), VEPS)
    = (attr QI . prepSort(S, VEPS) to QI') .
  eq prepare(((attr QI . S to QI'), RS), VEPS)
    = ((attr QI . prepSort(S, VEPS) to QI'), prepare(RS, VEPS)) .
  eq prepare((op F to F' [AtS]), VEPS) = (op F to F' [AtS]) .
  eq prepare(((op F to F' [AtS]), RS), VEPS)
    = ((op F to F' [AtS]), prepare(RS, VEPS)) .
  eq prepare((op F : TyL -> Ty to F' [AtS]), VEPS)
    = (op F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F' [AtS]) .
  eq prepare(((op F : TyL -> Ty to F' [AtS]), RS), VEPS)
    = (op F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F' [AtS],
       prepare(RS, VEPS)) .
  eq prepare((label L to L'), VEPS) = (label L to L') .
  eq prepare(((label L to L'), RS), VEPS)
    = ((label L to L'), prepare(RS, VEPS)) .
  eq prepare((msg F to F'), VEPS) = (msg F to F') .
  eq prepare(((msg F to F'), RS), VEPS)
    = ((msg F to F'), prepare(RS, VEPS)) .
  eq prepare((msg F : TyL -> Ty to F'), VEPS)
    = (msg F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F') .
  eq prepare(((msg F : TyL -> Ty to F'), RS), VEPS)
    = ((msg F : prepare(TyL, VEPS) -> prepSort(Ty, VEPS) to F'),
       prepare(RS, VEPS)) .
  eq prepare((none).RenamingSet, VEPS) = none .

  eq prepare((Ty TyL), VEPS) = (prepSort(Ty, VEPS) prepare(TyL, VEPS)) .
  eq prepare(nil, VEPS) = nil .

  eq header2Qid(ME * (RS))
    = qid(string(header2Qid(ME)) 
          + " * (" + string(qidList2Qid(maps2QidList(RS))) + ")") 
    [owise] .

  ceq header2QidList(ME * (RS))
    = (if QI == '\s then QIL QI else QIL QI '\s fi 
       '* '\s '`( maps2QidList(RS) '`))
    if QIL QI := header2QidList(ME) 
    [owise] .

endfm

*******************************************************************************

***
*** The Union Module Expression
***

*** The syntax used for the union of module expressions is

***   op _+_ : ModuleExpression ModuleExpression -> ModuleExpression 
***       [assoc prec 42] .

*** Its evaluation consists in generating a unit importing the two module
*** expressions given as arguments~\cite{Winkler91,OBJ92}.
 
*** As we explained in Sections~\ref{instantiation} and~\ref{renaming} for the
*** cases of the instantiation and the renaming module expressions,
*** respectively, the declaration of any new kind of module expression must
*** come together with the definition of the functions \texttt{evalModExp},
*** \texttt{header2QidList}, and \texttt{setUpModExpDeps} on the new
*** module operator. As discussed in Sections~\ref{instantiation}
*** and~\ref{parsing-unit-declarations}, equations for the \texttt{prepHeader}
*** and \texttt{parseModExp} functions have to be given as well.

fmod UNION-EXPR is
  inc MOD-EXPR .
  pr INST-EXPR-EVALUATION .
  pr RENAMING-EXPR-EVALUATION .
  pr EVALUATION .

  vars QI X : Qid .
  var  PDL : ParameterDeclList .
  vars DB DB' DB'' : Database .
  vars T T' : Term .
  vars DT DT' : Default{Term} .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExp,ViewExp}} .
  vars ME ME' ME'' ME3 : ModuleExpression .
  vars PU PU' U U' U'' U3 DM DM' : Module .
  vars M M' M'' M3 : Module .
  vars MNS MNS' MNS'' MNS3 MNS4 MNS5 : Set{ModuleName} .
  vars VES VES' VES'' : Set{ViewExp} .
  vars PDS PDS' PDS'' : Set{ParameterDecl} .
  vars MIS MIS' : Set{ModuleInfo} .
  var  VIS : Set{ViewInfo} .
  vars QIL QIL' : QidList .
  var  VDS VDS' : OpDeclSet .
  var  B : Bool .
  var  MAPS : RenamingSet .

*** As mentioned above, the evaluation of a union module expression consists
*** in the creation of a new unit, with such a module expression as name,
*** which imports the two module expressions being united. Note, however,
*** that the unit being created has to be of the right type. The new unit
*** will be generated having one type or another, depending on the types of 
*** the arguments of the union module expression.

*** The function \texttt{rightEmptyModule} generates an empty unit of the 
*** lowest of the sorts of its two arguments. In case of having a nonstructured
*** module as argument, the corresponding structured one is considered. If one
*** of the two module expressions corresponds to a theory, then a theory is
*** generated, and the lowest sort is taken between the sort of such a theory
*** and the \texttt{Module} sort immediately above the sort of the other unit; 
*** that is, sorts \texttt{FModule}, \texttt{SModule}, or \texttt{OModule} are 
*** considered to do the comparison.

----  ceq evalModExpAux(ME + ME', PDL, DB)
----    = if unitInDb(ME'' + ME3, DB'') or-else not (unitInDb(ME'', DB'') and-then unitInDb(ME3, DB''))  
----      then < DB'' ; ME'' + ME3 >
----      else < evalModule(
----                    addImports(including ME'' . including ME3 .,
----                      setName(
----                        rightEmptyModule(
----                          getTopModule(ME'', DB''), 
----                          getTopModule(ME3, DB'')),
----                        ME'' +  ME3)), 
----                    none,
----                    DB'') ;
----                  ME'' +  ME3 >
----      fi 
----    if < DB' ; ME3 > := evalModExpAux(ME', PDL, DB)
----    /\ < DB'' ; ME'' > := evalModExpAux(ME, PDL, DB') .

  ceq evalModExp(ME + ME', PDL, DB)
    = if unitInDb(ME'', DB') or-else not summandsInDB(ME'', DB')  
      then < DB' ; ME'' >
      else < evalModule(
               addImports(unfoldSummands(ME''),
                 setName(rightEmptyModule(ME'', DB'), ME'')), 
               none,
               DB') 
             ; ME'' >
      fi 
    if < DB' ; ME'' > := evalModExp+(ME + ME', PDL, DB) .

  op summandsInDB : ModuleExpression Database -> Bool .
  eq summandsInDB(ME + ME', DB) 
    = summandsInDB(ME, DB) and-then summandsInDB(ME', DB) . 
  eq summandsInDB(ME, DB) = unitInDb(ME, DB) [owise] .
  
  op unfoldSummands : ModuleExpression -> ImportList .
  eq unfoldSummands(ME + ME') = unfoldSummands(ME) unfoldSummands(ME') . 
  eq unfoldSummands(ME) = (including ME .) [owise] . 

  op rightEmptyModule : ModuleExpression Database -> Module .
  eq rightEmptyModule(ME, DB) = emptyModule(kindOfModule(ME, DB)) .

  op evalModExp+ : ModuleExpression ParameterDeclList Database -> Tuple{Database, ModuleExpression} . 
  eq evalModExp+(ME + ME', PDL, DB)
    = < database(evalModExp+(ME', PDL, database(evalModExp+(ME, PDL, DB))))
      ; modExp(evalModExp+(ME', PDL, database(evalModExp+(ME, PDL, DB)))) 
        + modExp(evalModExp+(ME, PDL, DB)) > .
  eq evalModExp+(ME, PDL, DB) = evalModExp(ME, PDL, DB) [owise] .

  op kindOfModule : ModuleExpression Database -> Qid .
  eq kindOfModule(ME + ME', DB) = greaterLowest(kindOfModule(ME, DB), kindOfModule(ME', DB)) .
  eq kindOfModule(ME, DB) = kindOfModule(getTopModule(ME, DB)) [owise] .
  
  op kindOfModule : Module -> Qid .
  eq kindOfModule(U:OModule) 
    = if U:OModule :: FModule
      then 'fmod 
      else if U:OModule :: SModule
           then 'mod
           else 'omod
           fi
      fi .
  eq kindOfModule(U:OTheory) 
    = if U:OTheory :: FTheory
      then 'fmod 
      else if U:OTheory :: STheory
           then 'mod
           else 'omod
           fi
      fi .
  eq kindOfModule(unitError(QIL)) = qidError(QIL) . 
  
  op greaterLowest : Qid Qid ~> Qid [comm] .
  eq greaterLowest('fmod, 'fmod) = 'fmod .
  eq greaterLowest('fmod, 'fth) = 'fth .
  eq greaterLowest('fth, 'fth) = 'fth .
  eq greaterLowest('mod, 'fmod) = 'mod .
  eq greaterLowest('mod, 'mod) = 'mod .
  eq greaterLowest('mod, 'fth) = 'th .
  eq greaterLowest('fmod, 'th) = 'th .
  eq greaterLowest('mod, 'th) = 'th .
  eq greaterLowest('th, 'th) = 'th .
  eq greaterLowest('omod, 'fmod) = 'omod .
  eq greaterLowest('omod, 'mod) = 'omod .
  eq greaterLowest('omod, 'omod) = 'omod .
  eq greaterLowest('omod, 'fth) = 'oth .
  eq greaterLowest('omod, 'th) = 'oth .
  eq greaterLowest('omod, 'oth) = 'oth .
  eq greaterLowest('fmod, 'oth) = 'oth .
  eq greaterLowest('mod, 'oth) = 'oth .
  eq greaterLowest('oth, 'th) = 'oth .
  eq greaterLowest('oth, 'fth) = 'oth .
  eq greaterLowest('oth, 'oth) = 'oth .

  op emptyModule : Qid ~> Module .
  eq emptyModule('fmod) = emptyFModule .
  eq emptyModule('fth) = emptyFTheory .
  eq emptyModule('mod) = emptySModule .
  eq emptyModule('th) = emptySTheory .
  eq emptyModule('omod) = emptyOModule .
  eq emptyModule('oth) = emptyOTheory .
  
----  op rightEmptyModule : Module Module -> Module [comm] .
----
----  eq rightEmptyModule(U1:FModule, U2:FModule) = emptyFModule .
----  eq rightEmptyModule(U1:FModule, U2:FTheory) = emptyFTheory .
----  eq rightEmptyModule(U1:FTheory, U2:FModule) = emptyFTheory .
----  eq rightEmptyModule(U1:FTheory, U2:FTheory) = emptyFTheory .
----  ceq rightEmptyModule(U1:SModule, U2:SModule) = emptySModule if not U1:SModule :: FModule or not U2:SModule :: FModule .
----  ceq rightEmptyModule(U1:STheory, U2:SModule) = emptySTheory if not U1:STheory :: FTheory or not U2:SModule :: FModule .
----  ceq rightEmptyModule(U1:SModule, U2:STheory) = emptySTheory if not U1:SModule :: FModule or not U2:STheory :: FTheory .
----  ceq rightEmptyModule(U1:STheory, U2:STheory) = emptySTheory if not U1:STheory :: FTheory or not U2:STheory :: FTheory .
----  ceq rightEmptyModule(U1:OModule, U2:OModule) = emptyOModule if not U1:OModule :: SModule or not U2:OModule :: SModule .
----  ceq rightEmptyModule(U1:OTheory, U2:OModule) = emptyOTheory if not U1:OTheory :: STheory or not U2:OModule :: SModule .
----  ceq rightEmptyModule(U1:OModule, U2:OTheory) = emptyOTheory if not U1:OModule :: SModule or not U2:OTheory :: STheory .
----  ceq rightEmptyModule(U1:OTheory, U2:OTheory) = emptyOTheory if not U1:OTheory :: STheory or not U2:OTheory :: STheory .
----  eq rightEmptyModule(unitError(QIL), U) = unitError(QIL) .
----  eq rightEmptyModule(U, unitError(QIL)) = unitError(QIL) .
----  eq rightEmptyModule(unitError(QIL), unitError(QIL')) = unitError(QIL QIL') .

*** As pointed out in Section~\ref{module-names}, for each new module
*** expression operator being introduced, we need to add equations for the
*** \texttt{header2Qid} function. For the union module expression we only
*** need the following equation:

  eq header2Qid(ME + ME') 
    = qidList2Qid(header2QidList(ME) '+ header2QidList(ME')) .
  eq header2Qid(_*`(_`)(ME + ME', MAPS))
    = qid("(" + string(header2Qid(ME + ME')) + ")"
          + " * (" + string(qidList2Qid(maps2QidList(MAPS))) + ")") .

  eq header2QidList(ME + ME') 
    = (header2QidList(ME) '+ header2QidList(ME')) .
  ceq header2QidList(_*`(_`)(ME + ME', MAPS))
    = (if QI == '\s then '`( QIL '`) QI else '`( QIL QI '`) '\s fi 
       '* '\s '`( maps2QidList(MAPS) '`))
    if QIL QI := header2QidList(ME + ME') .

*** Given a module
*** expression of the form \verb~ME + ME'~ such that \texttt{ME} and
*** \texttt{ME'} are in the database, we need to add \verb~ME + ME'~ to
*** the set of names of the modules depending on \texttt{ME} and \texttt{ME'}. 
*** In this way, if \texttt{ME} or \texttt{ME'} are redefined or removed from 
*** the database, \verb~ME + ME'~ will be removed as well.

  op setUpModExpDepsAux : ModuleExpression ModuleExpression Database -> Database .
  eq setUpModExpDeps(ME + ME', DB) = setUpModExpDepsAux(ME + ME', ME + ME', DB) .

  eq setUpModExpDepsAux(ME, ME' + ME'', DB)
   = setUpModExpDepsAux(ME, ME', setUpModExpDepsAux(ME, ME'', DB)) .
  eq setUpModExpDepsAux(ME, ME',
      db(< ME' ; DT ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db(< ME' ; DT ; U ; U' ; M ; VDS ; MNS . ME ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) 
   [owise] .
  eq setUpModExpDepsAux(ME, ME',
      db(< ME' ; DM ; U ; U' ; M ; VDS ; MNS ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db(< ME' ; DM ; U ; U' ; M ; VDS ; MNS . ME ; VES > MIS, MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL)  
   [owise] .

---(  eq setUpModExpDeps((ME + ME'), 
      db((< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > 
          < ME' ; DT' ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS), 
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DT ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES > 
         < ME' ; DT' ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' > 
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'), 
      db((< ME ; DT ; U ; U' ; M ; VDS ; MNS ; VES > 
          < ME' ; DM ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS), 
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DT ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES > 
         < ME' ; DM ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' > 
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'), 
      db((< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > 
          < ME' ; DT ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS), 
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DM ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES > 
         < ME' ; DT ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' > 
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  eq setUpModExpDeps((ME + ME'), 
      db((< ME ; DM ; U ; U' ; M ; VDS ; MNS ; VES > 
          < ME' ; DM' ; U'' ; U3 ; M' ; VDS' ; MNS' ; VES' > MIS), 
         MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL))
   = db((< ME ; DM ; U ; U' ; M ; VDS ; MNS . (ME + ME') ; VES > 
         < ME' ; DM' ; U'' ; U3 ; M' ; VDS' ; MNS' . (ME + ME') ; VES' > 
         MIS),
        MNS'', VIS, VES'', MNS3, MNS4, MNS5, QIL) .
  ceq setUpModExpDeps((ME + ME'), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME) 'not 'in 'database. '\n))
    if not unitInDb(ME, DB) .
  ceq setUpModExpDeps((ME + ME'), DB)
    = warning(DB, ('\r 'Error: '\o 'Module header2QidList(ME') 'not 'in 'database. '\n))
    if not unitInDb(ME', DB) .
---)

*** The \texttt{prepHeader} function on a union module expression makes
*** recursive calls with each of the module expressions given as arguments.

  eq prepModExp(ME + ME', VEPS) 
    = prepModExp(ME, VEPS) + prepModExp(ME', VEPS) .

*** Finally, the equation for the \texttt{parseModExp} function is as follows:

  eq labelInModExp(X, ME + ME') 
    = labelInModExp(X, ME) or-else labelInModExp(X, ME') .
endfm

*******************************************************************************

***
*** The $n$-tuple Module Expression
***

*** The syntax used for the $n$-tuple module expression is as follows:

***   op TUPLE[_] : Token -> ModuleExpression .

*** Its evaluation consists in the generation of a parameterized functional
*** module with the number of \texttt{TRIV} parameters specified by the
*** argument. A sort for tuples of such size, and the corresponding constructor
*** and selector operators, are also defined. Note that the \texttt{TRIV}
*** theory is predefined in Full Maude (see Sections~\ref{main-module}
*** and~\ref{non-built-in-predefined}). For example, the module expression 
*** \verb~TUPLE[3]~ produces the following module.

*** fmod TUPLE[3][C1 :: TRIV, C2 :: TRIV, C3 :: TRIV] is 
***    sorts 3Tuple . 
***    op (_,_,_) : Elt.C1 Elt.C2 Elt.C3 -> 3Tuple . 
***    op p1_ : 3Tuple -> Elt.C1 . 
***    op p2_ : 3Tuple -> Elt.C2 . 
***    op p3_ : 3Tuple -> Elt.C3 . 
***    var E1 : Elt.C1 . 
***    var E2 : Elt.C2 . 
***    var E3 : Elt.C3 . 
***    eq p1(E1, E2, E3) = E1 . 
***    eq p2(E1, E2, E3) = E2 . 
***    eq p3(E1, E2, E3) = E3 . 
*** endfm

*** Even though the $n$-tuple module expression is in principle of a completely
*** different nature, the way of handling it is the same as the way of handling
*** any other module expression. Its evaluation produces a new unit, a
*** parameterized functional module in this case, wtupleParList(N)ith the module expression as
*** name. New equations defining the semantics of functions
*** \texttt{evalModExp}, \texttt{header2QidList}, 
*** \texttt{setUpModExpDeps}, \texttt{prepHeader}, and 
*** \texttt{parseModExp} are given for this module expression.


fmod N-TUPLE-EXPR is
  inc MOD-EXPR .
  pr INST-EXPR-EVALUATION .
  pr EVALUATION .

  vars N N' : NzNat .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  var  T : Term .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExp,ViewExp}} .
  var  X : Qid .
  var  S : Sort .

*** The equation for the \texttt{evalModExp} is reduced to the creation of a
*** module as indicated above. Some auxiliary functions are defined in order
*** to generate the different declarations in the module.

  op tupleParList : NzNat -> ParameterDeclList .
  op tupleImportList : NzNat -> ImportList .
  op createCopyPars : NzNat Database -> Database .
  op tupleOps : NzNat -> OpDeclSet .
  op tupleOpsCtor : NzNat -> OpDecl .
  op tupleOpsCtorName : NzNat -> String .
  op tupleOpsCtorArity : NzNat -> QidList .
  op tupleOpsSelectors : NzNat NzNat -> OpDeclSet .
  op tupleEqSet : NzNat -> EquationSet .
  op tupleEqSetAux : NzNat Term -> EquationSet .
  op tupleTermArgs : NzNat -> TermList .
  ops tupleSort tupleSortAux : NzNat -> Sort .

  eq evalModExp(TUPLE[N], PDL, DB)
    = if unitInDb(TUPLE[N], DB) 
      then < DB ; TUPLE[N] >
      else < evalModule(
               fmod TUPLE[N]{tupleParList(N)} is
                 nil  ---- tupleImportList(N)
                 sorts tupleSort(N) .
                 none
                 tupleOps(N)
                 none
                 tupleEqSet(N)
               endfm, 
               none,
               createCopyPars(N, DB)) ; 
             TUPLE[N] >
      fi .

  eq createCopyPars(N, DB)
    = if N == 1
      then createCopy((qid("C" + string(N, 10)) :: 'TRIV), DB)
      else createCopyPars(_-_(N, 1), 
             createCopy((qid("C" + string(N, 10)) :: 'TRIV), DB))
      fi .

  eq tupleParList(N)
    = if N == 1
      then (qid("C" + string(N, 10)) :: 'TRIV)
      else (tupleParList(_-_(N, 1)), (qid("C" + string(N, 10)) :: 'TRIV))
      fi .

  eq tupleImportList(N)
    = if N == 1
      then (including pd(qid("C" + string(N, 10)) :: 'TRIV) .)
      else (tupleImportList(_-_(N, 1)) 
            (including pd(qid("C" + string(N, 10)) :: 'TRIV) .))
      fi .

  eq tupleSort(N) = makeSort('Tuple, tupleSortAux(N)) .

  eq tupleSortAux(N)
    = if N == 1
      then qid("C" + string(N, 10))
      else (tupleSortAux(_-_(N, 1)), qid("C" + string(N, 10)))
      fi .

  eq tupleOps(N) 
    = (tupleOpsCtor(N) tupleOpsSelectors(N, N)) .

  eq tupleOpsCtor(N)
    = (op qid("(" + tupleOpsCtorName(N) + ")") : 
            tupleOpsCtorArity(N) -> tupleSort(N) [none] .) .

  eq tupleOpsCtorName(N)
    = if N == 1
      then "_"
      else "_," + tupleOpsCtorName(_-_(N, 1))
      fi .

  eq tupleOpsCtorArity(N)
    = if N == 1
      then qid("C" + string(N, 10) + "$Elt")
      else tupleOpsCtorArity(_-_(N, 1)) qid("C" + string(N, 10) + "$Elt")
      fi .

  eq tupleOpsSelectors(N, N')
    = if N == 1 
      then (op qid("p" + string(N, 10) + "_") : 
                 tupleSort(N') -> qid("C" + string(N, 10) + "$Elt") [none] .)
      else (tupleOpsSelectors(_-_(N, 1), N')
            (op qid("p" + string(N, 10) + "_") : 
                  tupleSort(N') -> qid("C" + string(N, 10) + "$Elt") [none] .))
      fi .

  eq tupleEqSet(N)
    = tupleEqSetAux(N, 
        (qid("(" + tupleOpsCtorName(N) + ")") [ tupleTermArgs(N) ])) .

  eq tupleTermArgs(N)
    = if N == 1  
      then qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt")
      else (tupleTermArgs(_-_(N, 1)), 
            qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt"))
      fi .

  eq tupleEqSetAux(N, T)
    = if N == 1 
      then (eq qid("p" + string(N, 10) + "_")[T] 
              = qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt") 
              [none] .)
      else (tupleEqSetAux(_-_(N, 1), T) 
            (eq qid("p" + string(N, 10) + "_")[T] 
               = qid("V" + string(N, 10) + ":C" + string(N, 10) + "$Elt") 
               [none] .))
      fi .

*** The equations for the \texttt{header2QidList}, 
*** \texttt{parseModExp}, \texttt{prepHeader}, and 
*** \texttt{setUpModExpDeps} functions on the $n$-tuple module
*** expression are as follows:

  eq header2Qid(TUPLE[N]) = qid("TUPLE[" + string(N, 10) + "]") .
  eq header2QidList(TUPLE[N]) = ('TUPLE '`[ qid(string(N, 10)) '`]) .

  eq prepModExp(TUPLE[N], VEPS) = TUPLE[N] .

  eq setUpModExpDeps(TUPLE[N], DB) = DB .

endfm

fmod N-POWER-EXPR is
  inc MOD-EXPR .
  pr INST-EXPR-EVALUATION .
  pr EVALUATION .

  vars N N' : NzNat .
  var  PDL : ParameterDeclList .
  var  DB : Database .
  var  T : Term .
  var  IL : ImportList .
  var  VEPS : Set{Tuple{ViewExp,ViewExp}} .
  var  X : Qid .
  var  S : Sort .

*** As for TUPLE, the equation for the \texttt{evalModExp} is reduced to the 
*** creation of a new module. A module expression POWER[n]{Nat} produces a 
*** module
***
*** fmod POWER[n]{X :: TRIV} is
***   inc TUPLE[n]{X, X, ..., X} .
*** endfm
*** 
*** which is then instantiated by the Nat view.

*** Some auxiliary functions are defined in order
*** to generate the different declarations in the module.

  op powImportList : NzNat -> ImportList .
  op powTupleImportation : NzNat -> ViewExp .

  eq evalModExp(POWER[N], PDL, DB)
    = if unitInDb(POWER[N], DB) 
      then < DB ; POWER[N] >
      else < evalModule(
               fmod POWER[N]{'X :: 'TRIV} is
                 powImportList(N)
                 sorts none .
                 none
                 none
                 none
                 none
               endfm, 
               none,
               createCopy('X :: 'TRIV, DB)) ; 
             POWER[N] >
      fi .

  eq powImportList(N)
    = (including TUPLE[N]{powTupleImportation(N)} .) .

  eq powTupleImportation(N)
    = if N == 1
      then 'X
      else ('X, powTupleImportation(sd(N, 1)))
      fi .

*** The equations for the \texttt{header2QidList}, 
*** \texttt{parseModExp}, \texttt{prepHeader}, and 
*** \texttt{setUpModExpDeps} functions on the $n$-tuple module
*** expression are as follows:

  eq header2Qid(POWER[N]) = qid("POWER[" + string(N, 10) + "]") .
  eq header2QidList(POWER[N]) = ('POWER '`[ qid(string(N, 10)) '`]) .

  eq prepModExp(POWER[N], VEPS) = POWER[N] .

  eq setUpModExpDeps(POWER[N], DB) = DB .

endfm

*******************************************************************************

***
*** 8 Input/Output Processing
***

*** In this section we discuss how the preterm resulting from the call to the
*** function \texttt{metaParse} with the input and the top-level signature of
*** Full Maude is transformed into a term of sort \texttt{Module}, representing
*** a preunit or a term of sort \texttt{PreView}. In the case of commands, 
*** they are evaluated giving the corresponding results in the appropriate 
*** form.

*** 
*** 8.1 Input Parsing
***

*** Let us recall here the example presented in Section~\ref{bubbles}. Calling
*** \texttt{metaParse} with the module \texttt{NAT3} given there and the
*** signature of Full Maude presented in Section~\ref{sec:signature}, we 
*** obtain the following term.

***    'fmod_is_endfm[
***       'token[{''NAT3}'Qid], 
***       '__['sort_.['token[{''Nat3}'Qid]], 
***           '__['op_:_->_.['token[{''s_}'Qid], 
***                          'neTokenList[{''Nat3}'Qid], 
***                          'token[{''Nat3}'Qid]], 
***               '__['op_:`->_.['token[{''0}'Qid], 
***                              'token[{''Nat3}'Qid]], 
***                   'eq_=_.['bubble['__[{''s}'Qid, {''s}'Qid,  
***                                       {''s}'Qid, {''0}'Qid]], 
***                           'bubble[{''0}'Qid]]]]]]

*** Given each one of the subterms representing declarations in terms
*** representing modules as the previous one, the function \texttt{parseDecl}
*** generates the corresponding declaration, with no bubbles in it, and the
*** corresponding predeclaration, with the bubbles appearing in the term. For 
*** example, for the term
***
***   'op_:_->_.['token[{''s_}'Qid], 
***              'neTokenList[{''Nat3}'Qid], 
***              'token[{''Nat3}'Qid]]
***
*** the following operator declaration is generated:
***
***   op 's_ : 'Nat3 -> 'Nat3 [none] .
***
*** Note that in this case, since the operator is declared without identity
*** element (the only place a bubble might appear), the declaration and the
*** predeclaration generated by \texttt{parseDecl} coincide.

*** In the following sections we shall see how this approach is followed for
*** declarations appearing in units and in views.

***
*** 8.1.1 Parsing of Module Declarations
***

*** The \texttt{parseDecl} function takes a term (which corresponds to a
*** declaration to be parsed), a preunit (to which the parsed declaration with
*** its bubbles in it will be added), and a unit (to which the parsed
*** declaration without bubbles will be added to build up the signature). For
*** example, a term corresponding to an unconditional equation, that is, a term
*** of the form \verb~'eq_=_.[T, T']~ will be added to the set of equations of
*** the preunit as \verb~eq T = T' .~, but nothing will be added to the unit.
*** Note that according to the signature used in the call to
*** \texttt{metaParse} (see Sections~\ref{sec:signature}
*** and~\ref{main-module}), \texttt{T} and \texttt{T'} are bubbles.
*** Declarations of sorts, subsort relations, operators, classes, subclass 
*** relations, messages, and variables will be added to both of them. In the 
*** case of operator declarations, identity element attributes, which in 
*** general can be terms, are not included in the added declaration.

*** As in Core Maude, declarations in a module can be given in any order, and
*** therefore we follow a two-step approach consisting in first building the
*** signature to parse the bubbles, and then generating the unit without
*** bubbles in it. It could be different for other languages. For example, in
*** some languages we may be able to assume that each operator and sort has 
*** been defined before being used, allowing then an incremental processing of 
*** the input.

---- fmod MAYBE{X :: TRIV} is
----   sort Maybe{X} .
----   subsort X$Elt < Maybe{X} .
----   op maybe : -> Maybe{X} .
---- endfm

fmod UNIT-DECL-PARSING is
  pr DATABASE .
  pr MOVE-DOWN .
  pr INST-EXPR-EVALUATION .
  pr RENAMING-EXPR-EVALUATION .
  pr UNION-EXPR .
  pr N-TUPLE-EXPR .
  pr N-POWER-EXPR .
  pr DEFAULT-VALUE{Term} .
  pr META-FULL-MAUDE-SIGN .
  pr UNIT-BUBBLE-PARSING .

  vars PU U : Module .
  vars T T' T'' T''' T3 T4 : Term .
  vars QI QI' QI'' L F : Qid .
  vars QIL QIL' : QidList .
  vars S S' : Sort .
  vars SS SS' : TypeSet .
  vars TyL TyL' : TypeList .
  var  TSL : TypeSetList .
  var  AtS : AttrSet .
  vars TL TL' TL'' : TermList .
  var  Ct : Constant .
  var  VDS : OpDeclSet .
  vars Ty Tp : Type .
  var  N : Nat .
  var  DT : Default{Term} .

*** Similarly, auxiliary functions parsing other elements in units 
*** are defined.

  op parsePreAttrs : Term Nat -> AttrSet .
  op parsePreHookList : Term -> HookList .
  op parseVars : QidList [Type] -> OpDeclSet .
  op parseSubsortRel : Term -> TypeListSet .

  op parseAttrDeclList : Term -> AttrDeclSet .
  op unfoldOpDecl : QidList TypeList Sort AttrSet -> OpDeclSet .
  op unfoldMultipleMsgDecl : QidList TypeList Sort -> MsgDeclSet .
  op unfoldSubsortRel : TypeSetList ~> SubsortDeclSet .
  op unfoldSubclassRel : TypeSetList ~> SubclassDeclSet .

  eq parseSubsortRel('_<_[T, T']) 
    = _l_(parseSortSet(T), parseSubsortRel(T')) .
  eq parseSubsortRel('__[T, T']) = parseSortSet('__[T, T']) .
  eq parseSubsortRel('sortToken[T]) = downQid(T) .
  eq parseSubsortRel('_`{_`}['sortToken[T], T']) 
    = makeSort(downQid(T), parseParameterList(T')) .
  eq parseSubsortRel('_`{_`}['_`{_`}[T, T'], T''])
    = makeSort(parseSubsortRel('_`{_`}[T, T']), parseParameterList(T'')) .

  eq unfoldOpDecl((QI QIL), TyL, Ty, AtS)
    = ((op QI : TyL -> Ty [AtS] .) unfoldOpDecl(QIL, TyL, Ty, AtS)) .
  eq unfoldOpDecl(nil, TyL, Ty, AtS) = none .

  eq unfoldMultipleMsgDecl((QI QIL), TyL, Ty)
    = ((msg QI : TyL -> Ty .) unfoldMultipleMsgDecl(QIL, TyL, Ty)) .
  eq unfoldMultipleMsgDecl(nil, TyL, Ty) = none .

  eq unfoldSubsortRel(_l_((S ; SS), (S' ; SS'), TSL))
    = ((subsort S < S' .)
       unfoldSubsortRel(_l_(S, SS'))
       unfoldSubsortRel(_l_(SS, (S' ; SS')))
       unfoldSubsortRel(_l_((S' ; SS'), TSL))) .
  eq unfoldSubsortRel(_l_(SS, none)) = none .
  eq unfoldSubsortRel(_l_(none, SS)) = none .
  eq unfoldSubsortRel(SS) = none .
  eq unfoldSubsortRel(qidError(QIL)) = subsortDeclError(QIL) .

  eq unfoldSubclassRel(_l_((S ; SS), (S' ; SS'), TSL))
    = ((subclass S < S' .)
       unfoldSubclassRel(_l_(S, SS'))
       unfoldSubclassRel(_l_(SS, (S' ; SS')))
       unfoldSubclassRel(_l_((S' ; SS'), TSL))) .
  eq unfoldSubclassRel(_l_(SS, none)) = none .
  eq unfoldSubclassRel(_l_(none, SS)) = none .
  eq unfoldSubclassRel(SS) = none .
  eq unfoldSubclassRel(qidError(QIL)) = subclassDeclError(QIL) .

  eq parseVars((QI QIL), Tp) 
    = ((op QI : nil -> Tp [none] .) parseVars(QIL, Tp)) .
  eq parseVars(nil, Tp) = none .
  eq parseVars(QIL, qidError(QIL')) = opDeclError(QIL') .

  eq parsePreAttrs('__[T, T'], N) 
    = (parsePreAttrs(T, N) parsePreAttrs(T', N)) .
  eq parsePreAttrs('assoc.@Attr@, N) = assoc .
  eq parsePreAttrs('associative.@Attr@, N) = assoc .
  eq parsePreAttrs('comm.@Attr@, N) = comm .
  eq parsePreAttrs('commutative.@Attr@, N) = comm .
  eq parsePreAttrs('idem.@Attr@, N) = idem .
  eq parsePreAttrs('idempotent.@Attr@, N) = idem .
  eq parsePreAttrs('id:_[T], N) = id(T) .
  eq parsePreAttrs('identity:_[T], N) = id(T) .
  eq parsePreAttrs('left`id:_[T], N) = left-id(T) .
  eq parsePreAttrs('left`identity:_[T], N) = left-id(T) .
  eq parsePreAttrs('right`id:_[T], N) = right-id(T) .
  eq parsePreAttrs('right`identity:_[T], N) = right-id(T) .
  eq parsePreAttrs('poly`(_`)[T], N) = poly(parseInt(T)) .
  eq parsePreAttrs('strat`(_`)[T], N) = strat(parseInt(T)) .
  eq parsePreAttrs('strategy`(_`)[T], N) = strat(parseInt(T)) .
  eq parsePreAttrs('frozen.@Attr@, N) 
    = if N == 0 
      then none 
      else frozen(from 1 to N list)
      fi .
  eq parsePreAttrs('frozen`(_`)[T], N) = frozen(parseInt(T)) .
  eq parsePreAttrs('memo.@Attr@, N) = memo .
  eq parsePreAttrs('memoization.@Attr@, N) = memo .
  eq parsePreAttrs('ctor.@Attr@, N) = ctor .
  eq parsePreAttrs('constructor.@Attr@, N) = ctor .
  eq parsePreAttrs('prec_['token[T]], N) = prec(parseNat(T)) .
  eq parsePreAttrs('gather`(_`)['neTokenList[T]], N) = gather(downQidList(T)) .
  eq parsePreAttrs('special`(_`)[T], N) = special(parsePreHookList(T)) .
  eq parsePreAttrs('format`(_`)['neTokenList[T]], N) = format(downQidList(T)) .
  eq parsePreAttrs('iter.@Attr@, N) = iter .
  eq parsePreAttrs('ditto.@Attr@, N) = ditto .
  eq parsePreAttrs('config.@Attr@, N) = config .
  eq parsePreAttrs('object.@Attr@, N) = object .
  eq parsePreAttrs('msg.@Attr@, N) = msg .
  eq parsePreAttrs('message.@Attr@, N) = msg .
  eq parsePreAttrs('metadata_['token[T]], N) = metadata(downString(downQid(T))) .
  eq parsePreAttrs('nonexec.@Attr@, N) = nonexec .
  eq parsePreAttrs('variant.@Attr@, N) = variant .

  eq parsePreHookList('__[T, TL]) = parsePreHookList(T) parsePreHookList(TL) .
  eq parsePreHookList('id-hook_['token[T]]) = id-hook(downQid(T), nil) .
  eq parsePreHookList('id-hook_`(_`)['token[T], 'neTokenList[T']])
    = id-hook(downQid(T), downQidList(T')) .
  eq parsePreHookList(
       'op-hook_`(_:_->_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parsePreHookList('op-hook_`(_:`->_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parsePreHookList(
       'op-hook_`(_:_~>_`)[
          'token[T], 'token[T'], 'neTokenList[T''], 'token[T3]])
    = op-hook(downQid(T), downQid(T'), downTypes(T''), downQid(T3)) .
  eq parsePreHookList('op-hook_`(_:`~>_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parsePreHookList('term-hook_`(_`)['token[T], T']) 
    = term-hook(downQid(T), T') .

  eq parseAttrDeclList('_`,_[T, T']) 
    = (parseAttrDeclList(T), parseAttrDeclList(T')) .
  eq parseAttrDeclList('_:_['token[T], T']) 
    = (attr downQid(T) : parseType(T')) .

*** Given a term representing a declaration or a predeclaration, the function
*** \texttt{parseDecl} must generate and update both the unit and the preunit
*** that it takes as arguments. Note that in the case of rules, for example, 
*** only a prerule is generated.

*** Since the preunit and the unit may be modified, they have to be returned as
*** a pair, which will be used to extract the corresponding arguments for the
*** following calls. Note that the \texttt{parseDecl} functions are in fact
*** partial functions. Each parsing function assumes that it is possible to 
*** parse the given term.

  sort ParseDeclResult .
  op <_;_;_> : Module Module OpDeclSet -> ParseDeclResult .
  op preModule : ParseDeclResult -> Module .
  op unit : ParseDeclResult -> Module .
  op vars : ParseDeclResult -> OpDeclSet .

  eq preModule(< PU ; U ; VDS >) = PU .
  eq preModule(< unitError(QIL) ; V:[Module] ; V:[OpDeclSet] >) = unitError(QIL) .
  eq preModule(< V:[Module] ; unitError(QIL) ; V:[OpDeclSet] >) = unitError(QIL) .
  eq preModule(< V:[Module] ; V':[Module] ; opDeclError(QIL) >) = unitError(QIL) .
  eq unit(< PU ; U ; VDS >) = U .
  eq unit(< unitError(QIL) ; V':[Module] ; V:[OpDeclSet] >) = unitError(QIL) .
  eq unit(< V:[Module] ; unitError(QIL) ; V:[OpDeclSet] >) = unitError(QIL) .
  eq unit(< V:[Module] ; V':[Module] ; opDeclError(QIL) >) = unitError(QIL) .
  eq vars(< PU ; U ; VDS >) = VDS .
  eq vars(< unitError(QIL) ; V:[Module] ; V:[OpDeclSet] >) = opDeclError(QIL) .
  eq vars(< V:[Module] ; unitError(QIL) ; V:[OpDeclSet] >) = opDeclError(QIL) .
  eq vars(< V:[Module] ; V':[Module] ; opDeclError(QIL) >) = opDeclError(QIL) .

  op parseDecl : Term Module Module OpDeclSet -> ParseDeclResult .

*** changed 03/27/02
*** In the case of importation declarations, since internally only the 
*** \texttt{including} mode is handled, all importations are generated in 
*** this mode, independently of the keyword used in the input.

  eq parseDecl('inc_.[T], PU, U, VDS) 
    = parseDecl('including_.[T], PU, U, VDS) .
  eq parseDecl('ex_.[T], PU, U, VDS) 
    = parseDecl('extending_.[T], PU, U, VDS) .
  eq parseDecl('pr_.[T], PU, U, VDS) 
    = parseDecl('protecting_.[T], PU, U, VDS) .
  eq parseDecl('including_.[T], PU, U, VDS) 
    = < addImports((including parseModExp(T) .), PU) ; U ; VDS > .
  eq parseDecl('extending_.[T], PU, U, VDS) 
    = < addImports((extending parseModExp(T) .), PU) ; U ; VDS > .
  eq parseDecl('protecting_.[T], PU, U, VDS) 
    = < addImports((protecting parseModExp(T) .), PU) ; U ; VDS > .

  eq parseDecl('sort_.[T], PU, U, VDS) = parseDecl('sorts_.[T], PU, U, VDS) .
  eq parseDecl('sorts_.[T], PU, U, VDS)
    = < addSorts(parseSortSet(T), PU) ; addSorts(parseSortSet(T), U) ; VDS > .

  eq parseDecl('subsort_.[T], PU, U, VDS) 
    = parseDecl('subsorts_.[T], PU, U, VDS) .
  eq parseDecl('subsorts_.[T], PU, U, VDS) 
    = < addSubsorts(unfoldSubsortRel(parseSubsortRel(T)), PU) ;
        addSubsorts(unfoldSubsortRel(parseSubsortRel(T)), U) ; VDS > .

*** As pointed out in Section~\ref{SyntacticalRequirementsAndCaveats}, the 
*** name of operators in operator declaration has to be given as a single 
*** token identifier (see Section~\ref{order-sorted}). We assume that when 
*** declaring a multitoken operator, its name is given as a single quoted 
*** identifier in which each token is preceded by a backquote. Thus, the name 
*** of an operator \verb~_(_)~, for example, is given as \verb~_`(_`)~.

  eq parseDecl('op_:`->_.['token[T], T'], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> parseType(T') [none] .), PU) ;
        addOps((op downQid(T) : nil -> parseType(T') [none] .), U) ; 
        VDS > .
  eq parseDecl('op_:`->_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addOps(
          (op downQid(T) : nil -> parseType(T') [parsePreAttrs(T'', 0)] .), 
          PU) ;
        addOps(
          (op downQid(T) : nil -> parseType(T') [parseAttrs(T'')] .), 
          U) ; 
        VDS > .
  eq parseDecl('op_:_->_.['token[T], T', T''], PU, U, VDS)
    = < addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') [none] .), 
          PU) ;
        addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') [none] .), 
          U) ; 
        VDS > .
  eq parseDecl('op_:_->_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') 
               [parsePreAttrs(T3, size(parseTypeList(T')))] .), PU) ;
        addOps(
          (op downQid(T) : parseTypeList(T') -> parseType(T'') 
               [parseAttrs(T3)] .), U) ; 
        VDS > .

  ceq parseDecl('op_:`->_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS > 
    if F =/= 'token .
  ceq parseDecl('op_:`->_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS > 
    if F =/= 'token .
  ceq parseDecl('op_:_->_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS > 
    if F =/= 'token .
  ceq parseDecl('op_:_->_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS > 
    if F =/= 'token .

  eq parseDecl('ops_:`->_.['neTokenList[T], T'], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), none), PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), none), U) ; 
        VDS > .
  eq parseDecl('ops_:`->_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), 
            parsePreAttrs(T'', 0)),
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, parseType(T'), 
            parseAttrs(T'')), 
          U) ; 
        VDS > .
  eq parseDecl('ops_:_->_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), 
            parseType(T''), none), 
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), 
            parseType(T''), none), 
          U) ; 
        VDS > .
  eq parseDecl('ops_:_->_`[_`].['neTokenList[T], T', T'', T3], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), parseType(T''),
            parsePreAttrs(T3, size(parseTypeList(T')))), PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), 
            parseTypeList(T'), parseType(T''), parseAttrs(T3)), U) ; 
        VDS > .

  eq parseDecl('op_:`~>_.['token[T], T'], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> kind(parseType(T')) [none] .), PU) ;
        addOps((op downQid(T) : nil -> kind(parseType(T')) [none] .), U) ; 
        VDS > .
  eq parseDecl('op_:`~>_`[_`].['token[T], T', T''], PU, U, VDS)
    = < addOps((op downQid(T) : nil -> kind(parseType(T')) 
                    [parsePreAttrs(T'', 0)] .), PU) ;
        addOps((op downQid(T) : nil -> kind(parseType(T')) 
                    [parseAttrs(T'')] .), U) ; 
        VDS > .
  eq parseDecl('op_:_~>_.['token[T], T', T''], PU, U, VDS)
    = < addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                    [none] .), PU) ;
        addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                    [none] .), U) ; 
        VDS > .
  eq parseDecl('op_:_~>_`[_`].['token[T], T', T'', T3], PU, U, VDS)
    = < addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                   [parsePreAttrs(T3, size(parseTypeList(T')))] .), PU) ;
        addOps((op downQid(T) : kind(parseTypeList(T')) -> kind(parseType(T''))
                   [parseAttrs(T3)] .), U) ; 
        VDS > .

  ceq parseDecl('op_:`~>_.[F[TL], T], PU, U, VDS)
    = < PU ; U ; VDS > 
    if F =/= 'token .
  ceq parseDecl('op_:`~>_`[_`].[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS > 
    if F =/= 'token .
  ceq parseDecl('op_:_~>_.[F[TL], T, T'], PU, U, VDS)
    = < PU ; U ; VDS > 
    if F =/= 'token .
  ceq parseDecl('op_:_~>_`[_`].[F[TL], T, T', T''], PU, U, VDS)
    = < PU ; U ; VDS > 
    if F =/= 'token .

  eq parseDecl('ops_:`~>_.['neTokenList[T], T'], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), none), 
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), none), 
          U) ; 
        VDS > .
  eq parseDecl('ops_:`~>_`[_`].['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), 
            parsePreAttrs(T'', 0)), 
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), nil, kind(parseType(T')), 
            parseAttrs(T'')), U) ;
        VDS > .
  eq parseDecl('ops_:_~>_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), 
            kind(parseType(T'')), none), 
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), 
            kind(parseType(T'')), none), 
          U) ; 
        VDS > .
  eq parseDecl('ops_:_~>_`[_`].['neTokenList[T], T', T'', T3], PU, 
       U, VDS)
    = < addOps(
          unfoldOpDecl(downTypes(T), parseTypeList(T'), parseType(T''), 
            parsePreAttrs(T3, size(parseTypeList(T')))), 
          PU) ;
        addOps(
          unfoldOpDecl(downTypes(T), 
            parseTypeList(T'), parseType(T''), parseAttrs(T3)), U) ; 
        VDS > .

  eq parseDecl('var_:_.['neTokenList[T], T'], PU, U, VDS)
    = parseDecl('vars_:_.['neTokenList[T], T'], PU, U, VDS) .
  eq parseDecl('vars_:_.['neTokenList[T], T'], PU, U, VDS)
    = < PU ; U ; VDS parseVars(downQidList(T), parseType(T')) > .

  eq parseDecl('mb_:_.['bubble['__[''`[.Qid, L, ''`].Qid]], T], PU, U, VDS) 
    = < addMbs((mb getTerm(breakMb(T, VDS)) : getSort(breakMb(T, VDS)) 
                  [label(downQid(L)) getAttrSet(breakMb(T, VDS))] .), PU) ; U ; VDS > .
  eq parseDecl('mb_:_.[T, T'], PU, U, VDS) 
    = < addMbs((mb T : getSort(breakMb(T', VDS)) [getAttrSet(breakMb(T', VDS))] .), PU) ; U ; VDS > 
    [owise] .
  eq parseDecl('cmb_:_if_.[T, T', T''], PU, U, VDS)
    = < addMbs(
          (cmb T : getSort(breakMb(T', VDS)) 
             if term(pullStmtAttrOut(T'', VDS)) = 'true.Bool 
             [attrSet(pullStmtAttrOut(T'', VDS))] .), PU) ; U ; VDS > .
  eq parseDecl('cmb`[_`]:_:_if_.['token[T'''], T, T', T''], PU, U, VDS)
    = < addMbs(
          (cmb T : getSort(breakMb(T', VDS)) 
             if term(pullStmtAttrOut(T'', VDS)) = 'true.Bool 
             [attrSet(pullStmtAttrOut(T'', VDS)) label(downQid(T'''))] .), PU) ; U ; VDS > . 

  sort Tuple{Default{Term},Sort,AttrSet} .

  op breakMb : Term OpDeclSet -> [Tuple{Default{Term},Sort,AttrSet}] .
  op breakMbAux : Term TermList AttrSet OpDeclSet -> [Tuple{Default{Term},Sort,AttrSet}] .
  op {_,_,_} : Default{Term} Sort AttrSet -> Tuple{Default{Term},Sort,AttrSet} .
  op getTerm : Tuple{Default{Term},Sort,AttrSet} -> Default{Term} .
  op getSort : Tuple{Default{Term},Sort,AttrSet} -> Sort .
  op getAttrSet : Tuple{Default{Term},Sort,AttrSet} -> AttrSet .
  eq getTerm({DT, S, AtS}) = DT .
  eq getTerm({DT, qidError(QIL), AtS}) = DT .
  eq getSort({DT, S, AtS}) = S .
  eq getSort({DT, qidError(QIL), AtS}) = qidError(QIL) .
  eq getAttrSet({DT, S, AtS}) = AtS .
  eq getAttrSet({DT, qidError(QIL), AtS}) = AtS .

----  eq breakMb('bubble[QI]) = {maybe, downQidList(QI), none} .
----  eq breakMb('bubble['__[QI, QI']]) 
----    = {maybe, getType(parseTypeMb('bubble['__[QI, QI']])), none} .
----  eq breakMb('bubble['__[QI, QI', QI'']]) 
----    = {getTerm(parseTypeMb('bubble['__[QI, QI', QI'']])), 
----       getType(parseTypeMb('bubble['__[QI, QI', QI'']])), 
----       none} .
  eq breakMb('bubble['__[QI, QI', TL, QI'']], VDS) 
    = if QI'' =/= ''`].Qid 
      then {getTerm(parseTypeMb('bubble['__[QI, QI', TL, QI'']])), 
            getType(parseTypeMb('bubble['__[QI, QI', TL, QI'']])), 
            none}
      else breakMbAux('bubble['__[QI, QI', TL, QI'']], (QI, QI', TL), none, VDS) 
      fi .
  eq breakMb('sortToken[T], VDS) = {null, parseType('sortToken[T]), none} [owise] .
  eq breakMb('_`{_`}[T, T'], VDS) = {null, parseType('_`{_`}[T, T']), none} [owise] .
  eq breakMb(T, VDS) = {null, getType(parseTypeMb(T)), none} [owise] .

  eq breakMbAux(T, (TL, ''`[.Qid), AtS, VDS) 
    = if AtS =/= none 
      then {null, getType(parseTypeMb('bubble[TL])), AtS}
      else {null, T, none}
      fi . 
  eq breakMbAux(T, (TL, QI, QI', ''`[.Qid), AtS, VDS) 
    = if AtS =/= none 
      then {getTerm(parseTypeMb('bubble['__[TL, QI, QI']])), 
            getType(parseTypeMb('bubble['__[TL, QI, QI']])), AtS}
      else {getTerm(parseTypeMb(T)), getType(parseTypeMb(T)), none}
      fi . 
  eq breakMbAux(T, (TL, QI, ''nonexec.Qid), AtS, VDS) 
    = breakMbAux(T, (TL, QI), AtS nonexec, VDS) .
  eq breakMbAux(T, (TL, QI, ''variant.Qid), AtS, VDS) 
    = breakMbAux(T, (TL, QI), AtS variant, VDS) .
  eq breakMbAux(T, (TL, QI, ''owise.Qid), AtS, VDS) 
    = breakMbAux(T, (TL, QI), AtS owise, VDS) .
  eq breakMbAux(T, (TL, QI, ''otherwise.Qid), AtS, VDS) 
    = breakMbAux(T, (TL, QI), AtS owise, VDS) .
  eq breakMbAux(T, (TL, QI, ''label.Qid, QI'), AtS, VDS) 
    = if downQid(QI') :: Qid
      then breakMbAux(T, (TL, QI), AtS label(downQid(QI')), VDS)
      else {null, T, none}
      fi .
  eq breakMbAux(T, (TL, QI, ''metadata.Qid, QI'), AtS, VDS) 
    = if downString(downQid(QI')) :: String
      then breakMbAux(T, (TL, QI), AtS metadata(downString(downQid(QI'))), VDS)
      else {null, T, none}
      fi .
  ceq breakMbAux(T, (TL, QI, ''`[.Qid, TL',  ''print.Qid, TL''), AtS, VDS) 
    = breakMbAux(T, (TL, QI, ''`[.Qid, TL'), AtS print(printArg(TL'', VDS)), VDS) 
    if printArg(TL'', VDS) : QidList .
  eq breakMbAux(T, TL, AtS, VDS)  = {null, T, none} [owise] .

  op parseTypeMb : Term ~> ResultPair .
----  eq parseTypeMb('bubble[T])
----    = parseType(getTerm(metaParse(upModule('EXTENDED-SORTS, false), downQidList(T), '@Sort@))) .
  eq parseTypeMb('bubble[TL])
    = if metaParse(
           addOps(
             op '_:_ : '@Bubble@ '@Sort@ -> '@TermSort@ [none] .,
             addSorts('@TermSort@, GRAMMAR)), 
           downQidList(TL), '@TermSort@) :: ResultPair
      then breakTermSort(
             getTerm(  
               metaParse(
                 addOps(
                   op '_:_ : '@Bubble@ '@Sort@ -> '@TermSort@ [none] .,
                   addSorts('@TermSort@, GRAMMAR)), 
                 downQidList(TL), '@TermSort@)))
      else {null, parseType(getTerm(metaParse(GRAMMAR, downQidList(TL), '@Sort@)))}
      fi .
      
  op breakTermSort : Term ~> ResultPair .
  eq breakTermSort('_:_[T, T']) = {T, parseType(T')} .

  eq parseDecl('eq_=_.[T, T'], PU, U, VDS) 
    = < addEqs((eq T = T' [none] .), PU) ; U ; VDS > .
  eq parseDecl('ceq_=_if_.[T, T', T''], PU, U, VDS)
    = < addEqs((ceq T = T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .
  eq parseDecl('cq_=_if_.[T, T', T''], PU, U, VDS)
    = < addEqs((ceq T = T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .

  eq parseDecl('rl_=>_.[T, T'], PU, U, VDS)
    = < addRls((rl T => T' [none] .), PU) ; U ; VDS > .
  eq parseDecl('crl_=>_if_.[T, T', T''], PU, U, VDS)
    = < addRls((crl T => T' if T'' = 'true.Bool [none] .), PU) ; U ; VDS > .

  eq parseDecl('class_|`.[T], PU, U, VDS)
    = parseDecl('class_.[T], PU, U, VDS) .
  eq parseDecl('class_.[T], PU, U, VDS)
    = < addClasses((class parseType(T) | none .), PU) ; 
        addClasses((class parseType(T) | none .), U) ; VDS > .
  eq parseDecl('class_|_.[T, T'], PU, U, VDS)
    = < addClasses((class parseType(T) | parseAttrDeclList(T') .), PU) ; 
        addClasses((class parseType(T) | parseAttrDeclList(T') .), U) ; VDS > .

  eq parseDecl('subclass_.[T], PU, U, VDS)
    = < addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), U) ; VDS > .
  eq parseDecl('subclasses_.[T], PU, U, VDS)
    = < addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclasses(unfoldSubclassRel(parseSubsortRel(T)), U) ; VDS > .

  eq parseDecl('msg_:_->_.['token[T], T', T''], PU, U, VDS)
    = < addMsgs((msg downQid(T) : parseTypeList(T') -> parseType(T'') .), PU) 
        ;
        addMsgs((msg downQid(T) : parseTypeList(T') -> parseType(T'') .), U) 
        ;
        VDS > .
  eq parseDecl('msg_:`->_.['token[T], T'], PU, U, VDS)
    = < addMsgs((msg downQid(T) : nil -> parseType(T') .), PU) ;
        addMsgs((msg downQid(T) : nil -> parseType(T') .), U) ; VDS > .
  eq parseDecl('msgs_:_->_.['neTokenList[T], T', T''], PU, U, VDS)
    = < addMsgs(unfoldMultipleMsgDecl(downQidList(T), parseTypeList(T'), parseType(T'')), PU) ;
        addMsgs(unfoldMultipleMsgDecl(downQidList(T), parseTypeList(T'), parseType(T'')), U) ; 
        VDS > .
  eq parseDecl('msgs_:`->_.['neTokenList[T], T'], PU, U, VDS)
    = < addMsgs(unfoldMultipleMsgDecl(downQidList(T), nil, parseType(T')), PU) ;
        addMsgs(unfoldMultipleMsgDecl(downQidList(T), nil, parseType(T')), U) ; VDS > .

endfm

*******************************************************************************

***
*** 8.1.2 Parsing of View Declarations
***

*** A similar approach is followed for the parsing of declarations in views.

fmod VIEW-DECL-PARSING is
  pr PRE-VIEW .
  pr VIEW .
  pr UNIT .
  pr UNIT-DECL-PARSING .

  vars T T' : Term .
  var  OPDS : OpDeclSet .
  var  MDS : MsgDeclSet .
  var  M : Module .
  vars F F' : Qid .
  vars S S' : Sort .
  vars Ty Ty' : Type .
  vars TyL TyL' : TypeList .
  vars T'' T3 : Term .
  var  PV : PreView .
  var  OPD : OpDecl .
  var  OPDS' : OpDeclSet .
  var  AtS : AttrSet .
  var  MD : MsgDecl .
  var  MDS' : MsgDeclSet .
  var  VDS : OpDeclSet .

*** Operator and message name maps of the form \verb~F to F'~ are substituted
*** by an equivalent set of maps of the form \verb~F : TyL -> S to F'~. One
*** of these maps is added for each family of subsort-overloaded operators in 
*** the source theory of the view.

*** The following functions \texttt{genOpMaps} and \texttt{genMsgMaps}
*** take, respectively, an operator and a message map of the form
*** \verb~F to F'~, a set of operator or message declarations, and a term of
*** sort \texttt{Module}, and return, respectively, a set of operator maps and
*** a set of message maps, with each of the members of those sTS having the
*** general form \verb~F : TyL -> S to F'~. One of these maps is generated 
*** for each family of subsort-overloaded operators or messages with name 
*** \texttt{F} in the module given as argument.

  op genOpMaps : OpMapping OpDeclSet Module -> OpMappingSet .
  op genMsgMaps : OpMapping MsgDeclSet Module -> OpMappingSet .

  op genOpMapsAux : OpDeclSet Qid -> OpMappingSet .
  op genMsgMapsAux : MsgDeclSet Qid -> OpMappingSet .

  op getOpDeclSet : Qid Module -> OpDeclSet .
  op getOpDeclSetAux : Qid OpDeclSet -> OpDeclSet .
  *** getOpDeclSet(F, U) returns the set of declarations of operators with 
  *** name F in the unit U
  op getMsgDeclSet : Qid Module -> MsgDeclSet .
  op getMsgDeclSetAux : Qid MsgDeclSet -> MsgDeclSet .
  *** getMsgDeclSet(F, U) returns the set of declarations of messages with 
  *** name F in the unit U
  op gTSubsortOverloadedFamilies : OpDeclSet OpDeclSet Module -> OpDeclSet .
  op gTSubsortOverloadedFamilies : MsgDeclSet MsgDeclSet Module -> MsgDeclSet .
  *** gTSubsortOverloadedFamilies returns a declaration of operator or
  *** message for each family of subsort-overloaded operators or messages. 
  op selectOpDeclSet : Qid OpDeclSet -> OpDeclSet .
  op selectMsgDeclSet : Qid MsgDeclSet -> MsgDeclSet .
  *** selectOpDeclSet and selectMsgDeclSet returns, respectively, the subset
  *** of those declarations  of ops and msgs which name coincides with the 
  *** qid given ar argument.
  op opFamilyIn : OpDecl OpDeclSet Module -> Bool .
  op msgFamilyIn : MsgDecl MsgDeclSet Module -> Bool .
  *** Check whether the family of the subsort-overloaded operator given as
  *** argument has already a  representative in the set of declarations given.

  eq genOpMaps(op F to F' ., OPDS, M)
    = genOpMapsAux(
         gTSubsortOverloadedFamilies(selectOpDeclSet(F, OPDS), none, M), 
         F') .

  eq genMsgMaps(msg F to F' ., MDS, M)
    = genMsgMapsAux(
         gTSubsortOverloadedFamilies(selectMsgDeclSet(F, MDS), none, M), 
         F') .

  eq selectOpDeclSet(F, ((op F' : TyL -> Ty [AtS] .) OPDS))
    = ((if F == F' 
        then (op F' : TyL -> Ty [AtS] .)
        else none 
        fi)
       selectOpDeclSet(F, OPDS)) .
  eq selectOpDeclSet(F, none) = none .

  eq selectMsgDeclSet(F, ((msg F' : TyL -> Ty .) MDS))
    = ((if F == F' 
        then (msg F' : TyL -> Ty .)
        else none 
        fi)
       selectMsgDeclSet(F, MDS)) .
  eq selectMsgDeclSet(F, none) = none .

  eq genOpMapsAux(op F : TyL -> Ty [AtS] . OPDS, F')
    = (op F : TyL -> Ty to F' . genOpMapsAux(OPDS, F')) .
  eq genOpMapsAux(none, F') = none .

  eq genMsgMapsAux(((msg F : TyL -> Ty .) MDS), F')
    = (msg F : TyL -> Ty to F' . genMsgMapsAux(MDS, F')) .
  eq genMsgMapsAux(none, F') = none .

  eq gTSubsortOverloadedFamilies((OPD OPDS), OPDS', M)
    = if opFamilyIn(OPD, OPDS', M)
      then gTSubsortOverloadedFamilies(OPDS, OPDS', M)
      else gTSubsortOverloadedFamilies(OPDS, (OPD OPDS'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, OPDS, M) = OPDS .

  eq gTSubsortOverloadedFamilies((MD MDS), MDS', M)
    = if msgFamilyIn(MD, MDS', M)
      then gTSubsortOverloadedFamilies(MDS, MDS', M)
      else gTSubsortOverloadedFamilies(MDS, (MD MDS'), M)
      fi .
  eq gTSubsortOverloadedFamilies(none, MDS, M) = MDS .

  eq opFamilyIn(
       (op F : TyL -> Ty [AtS] .), ((op F' : TyL' -> Ty' [AtS] .) OPDS), M)
    = ((F == F') and-then sameKind(M, TyL, TyL')) or-else
      opFamilyIn((op F : TyL -> Ty [AtS] .), OPDS, M) .
  eq opFamilyIn((op F : TyL -> Ty [AtS] .), none, M) = false .

  eq msgFamilyIn((msg F : TyL -> Ty .), ((msg F' : TyL' -> Ty' .) MDS), M)
    = ((F == F') and-then sameKind(M, TyL, TyL')) 
      or-else
      msgFamilyIn((msg F : TyL -> Ty .), MDS, M) .
  eq msgFamilyIn((msg F : TyL -> Ty .), none, M) = false .

*** In the case of views, the \texttt{parseDecl} function takes the term
*** representing the corresponding declaration and a preview in which the
*** declarations are introduced. Note that in the case of views, the approach
*** followed in the evaluation is somewhat different. The only predeclarations
*** in a preview correspond to the term premaps of sort \texttt{PreTermMap},
*** for which, in addition to solving the bubbles in them, we have to convert
*** them into term maps of sort \texttt{TermMap} associating to them the set 
*** of declarations of variables in the view which are used in them (see 
*** Section~\ref{view-processing}).

*** The function \texttt{parseDecl} for declarations in views takes then the
*** term representing such declaration and a preview in which the result of
*** adding the declaration will be returned. To be able to generate the sTS
*** of equivalent operator and message maps as indicated above, the function
*** takes also as parameters the sTS of declarations of operators and messages
*** in the theory part of the source theory of the view in question, and the 
*** signature of such theory to make the necessary sort comparisons.

  op parseDecl : Term PreView OpDeclSet MsgDeclSet Module -> PreView .

  eq parseDecl('sort_to_.[T, T'], PV, OPDS, MDS, M)
    = addMaps(sort parseType(T) to parseType(T') ., PV) .

  eq parseDecl('class_to_.[T, T'], PV, OPDS, MDS, M)
    = addMaps(class parseType(T) to parseType(T') ., PV) .

  eq parseDecl('vars_:_.['neTokenList[T], T'], PV, OPDS, MDS, M)
    = addVars(parseVars(downQidList(T), parseType(T')), PV).
  eq parseDecl('var_:_.['neTokenList[T], T'], PV, OPDS, MDS, M)
    = addVars(parseVars(downQidList(T), parseType(T')), PV).

  eq parseDecl('op_to`term_.[T, T'], PV, OPDS, MDS, M) 
    = addMaps(op_to`term_.(T, T'), PV) .

  eq parseDecl('op_to_.['token[T], 'token[T']], PV, OPDS, MDS, M)
    = addMaps(genOpMaps(op downQid(T) to downQid(T') ., OPDS, M), PV) .
  eq parseDecl('op_:_->_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, M)
    = addMaps(op downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) ., PV) .
  eq parseDecl('op_:`->_to_.['token[T], T', 'token[T'']], PV, OPDS, MDS, M)
    = addMaps(op downQid(T) : nil -> parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('msg_to_.['token[T], 'token[T']], PV, OPDS, MDS, M)
    = addMaps(genMsgMaps(msg downQid(T) to downQid(T') ., MDS, M), PV) .
  eq parseDecl('msg_:_->_to_.['token[T], T', T'', 'token[T3]], PV, OPDS, MDS, M)
    = addMaps(msg downQid(T) : parseTypeList(T') -> parseType(T'') to downQid(T3) ., PV) .
  eq parseDecl('msg_:`->_to_.['token[T], T', 'token[T'']], PV, OPDS, MDS, M)
    = addMaps(msg downQid(T) : nil -> parseType(T') to downQid(T'') ., PV) .

  eq parseDecl('attr_._to_.[T', 'token[T], 'token[T'']], PV, OPDS, MDS, M)
    = addMaps(attr downQid(T) . parseType(T') to downQid(T'') ., PV) .

  eq parseDecl(T, PV, OPDS, MDS, M) = PV [owise] .
endfm

*******************************************************************************

***
*** 8.2 Meta Pretty Printing
***

*** To be able to show to the user the modules, theories, views, and terms
*** resulting from the different commands, the built-in function
*** \texttt{meta-pretty-print} is extended in the modules in this section to 
*** deal with units and views.

***
*** 8.2.1 Meta Pretty Printing of Declarations
***

*** The predefined function \texttt{meta-pretty-print} is extended in the
*** following module \texttt{DECL-META-PRETTY-PRINT} to handle any declaration
*** that can appear in a unit. Note that the following
*** \texttt{meta-pretty-print} functions, as the built-in one, return a list
*** terms---such as equations, rules,* operator declarations with an identity
*** attribute, etc.---they have been defined with a term of operator 
*** declarations with an identity attribute, etc.---they have been defined 
*** with a term of sort \texttt{Module} as argument. In the other cases the 
*** module is not necessary.

fmod DECL-META-PRETTY-PRINT is
  pr EXT-DECL .
  pr O-O-DECL .
  pr UNIT .
  pr CONVERSION .
  pr INT-LIST .
  pr VIEW-EXPR-TO-QID .

  op eMetaPrettyPrint : Sort -> QidList .
  op eMetaPrettyPrint : SortSet -> QidList .
  op eMetaPrettyPrint : TypeList -> QidList .
  op eMetaPrettyPrint : SubsortDeclSet -> QidList .
  op eMetaPrettyPrint : ClassDeclSet -> QidList .
  op eMetaPrettyPrint : SubclassDeclSet -> QidList .
  op eMetaPrettyPrint : Module OpDeclSet -> QidList .
  op eMetaPrettyPrintVars : OpDeclSet -> QidList .
  op eMetaPrettyPrint : MsgDeclSet -> QidList .
  op eMetaPrettyPrint : Module MembAxSet -> QidList .
  op eMetaPrettyPrint : Module EquationSet -> QidList .
  op eMetaPrettyPrint : Module RuleSet -> QidList .
  op eMetaPrettyPrint : Module Condition -> QidList .
  op eMetaPrettyPrint : Module Term -> QidList .

  ---- error handling
---(
  eq metaPrettyPrint(M, T, POS:PrintOptionSet) 
    = 'Module getName(M) 'contains 'errors. .
---)

  eq eMetaPrettyPrint(U, T) = metaPrettyPrint(U, T) . ----, mixfix flat format) .
  eq eMetaPrettyPrint(U, qidError(QIL)) = QIL .
  eq eMetaPrettyPrint(qidError(QIL)) = QIL .
 
  op eMetaPrettyPrint : Module AttrSet -> QidList .
  op eMetaPrettyPrint : IntList -> QidList .
  op eMetaPrettyPrint : AttrDeclSet -> QidList .
  op eMetaPrettyPrint : Module HookList -> QidList .

  vars QI QI' QI'' F V L : Qid .
  var  QIL : QidList .
  var  St : String .
  var  M : Module .
  var  U : Module .
  vars VE VE' : ViewExp .
  vars SS : SortSet .
  vars S S' : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  AtS : AttrSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  Hk : Hook .
  var  HkL : HookList .
  var  I : Int .
  var  NL : IntList .
  vars T T' T'' T3 : Term .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  ADS : AttrDeclSet .
  var  Cond : Condition .
  var  K : Kind .

  --- eq eMetaPrettyPrint(Ty) = Ty .

  eq eMetaPrettyPrint(S)
    = if getPars(S) == empty
      then S
      else getName(S) '`{ parameterList2QidList(getPars(S)) '`}
      fi .
  eq eMetaPrettyPrint(K) = '`[ eMetaPrettyPrint(getSort(K)) '`] . 

  eq eMetaPrettyPrint((S ; SS)) 
    = (eMetaPrettyPrint(S) eMetaPrettyPrint(SS))
    [owise] .
  eq eMetaPrettyPrint((none).SortSet) = nil .

  eq eMetaPrettyPrint(Ty TyL) 
    = eMetaPrettyPrint(Ty) eMetaPrettyPrint(TyL) 
    [owise] .
  eq eMetaPrettyPrint((nil).TypeList) = nil .

  eq eMetaPrettyPrint(((subsort S < S' .) SSDS))
    = ('\s '\s '\b 
       'subsort '\o eMetaPrettyPrint(S) '\b 
           '< '\o eMetaPrettyPrint(S') '\b '. '\o '\n 
       eMetaPrettyPrint(SSDS)) .
  eq eMetaPrettyPrint((none).SubsortDeclSet) = nil .

  eq eMetaPrettyPrint(M, ((op F : TyL -> Ty [none] .) OPDS))
    = ('\s '\s 
       '\b 'op '\o F '\b ': '\o eMetaPrettyPrint(TyL) 
       '\b '-> '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n 
       eMetaPrettyPrint(M, OPDS)) .
  eq eMetaPrettyPrint(M, ((op F : TyL -> Ty [AtS] .) OPDS))
    = ('\s '\s 
       '\b 'op '\o F '\b ': '\o eMetaPrettyPrint(TyL) 
       '\b '-> '\o eMetaPrettyPrint(Ty) '\n 
       '\s '\s '\s '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n 
       eMetaPrettyPrint(M, OPDS))
    [owise] .
  eq eMetaPrettyPrint(M, (none).OpDeclSet)  = nil .

  eq eMetaPrettyPrintVars((op F : nil -> Ty [none] .) OPDS)
    = ('\s '\s '\b 'var '\o F '\b ': '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n 
       eMetaPrettyPrintVars(OPDS)) .
  eq eMetaPrettyPrintVars((none).OpDeclSet)  = nil .

  eq eMetaPrettyPrint(M, (mb T : S [none] .) MAS)
    = ('\s '\s '\b 'mb '\o eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S) '\b '. '\o '\n 
       eMetaPrettyPrint(M, MAS)) .
  eq eMetaPrettyPrint(M, (mb T : S [AtS] .) MAS)
    = ('\s '\s '\b 'mb '\o eMetaPrettyPrint(M, T) 
                   '\b ': '\o eMetaPrettyPrint(S) 
               '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n 
       eMetaPrettyPrint(M, MAS)) 
    [owise] .
  eq eMetaPrettyPrint(M, (cmb T : S if Cond [none] .) MAS)
    = ('\s '\s '\b 'cmb '\o eMetaPrettyPrint(M, T) 
                   '\b ': '\o eMetaPrettyPrint(S) '\n 
       '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cond) '\b '. '\o '\n 
       eMetaPrettyPrint(M, MAS)) .
  eq eMetaPrettyPrint(M, (cmb T : S if Cond [AtS] .) MAS)
    = ('\s '\s '\b 'cmb '\o eMetaPrettyPrint(M, T) 
                   '\b ': '\o eMetaPrettyPrint(S) '\n 
       '\s '\s '\s '\s '\b 'if '\o eMetaPrettyPrint(M, Cond) 
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n 
       eMetaPrettyPrint(M, MAS)) 
    [owise] .
  eq eMetaPrettyPrint(M, (none).MembAxSet) = nil .

  eq eMetaPrettyPrint(M, ((eq T = T' [none] .) EqS))
    = ('\s '\s '\b 'eq '\s '\o eMetaPrettyPrint(M, T) '\n 
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\b '\s '. '\n 
       '\o 
       eMetaPrettyPrint(M, EqS)) .
  eq eMetaPrettyPrint(M, ((eq T = T' [AtS] .) EqS))
    = ('\s '\s '\b 'eq '\s '\o eMetaPrettyPrint(M, T) '\n 
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') 
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n 
       eMetaPrettyPrint(M, EqS)) 
    [owise] .
  eq eMetaPrettyPrint(M, ((ceq T = T' if Cond [none] .) EqS))
    = ('\s '\s '\b 'ceq '\s '\o eMetaPrettyPrint(M, T) '\n 
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\n 
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n 
       eMetaPrettyPrint(M, EqS)) .
  eq eMetaPrettyPrint(M, ((ceq T = T' if Cond [AtS] .) EqS))
    = ('\s '\s '\b 'ceq '\s '\o eMetaPrettyPrint(M, T) '\n 
       '\s '\s '\s '\s '\b '= '\s '\o eMetaPrettyPrint(M, T') '\n 
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) 
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n 
       eMetaPrettyPrint(M, EqS)) 
    [owise] .
  eq eMetaPrettyPrint(M, (none).EquationSet) = nil .

  eq eMetaPrettyPrint(M, ((rl T => T' [none] .) RlS))
    = ('\s '\s '\b 'rl '\s '\o eMetaPrettyPrint(M, T) '\n 
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\b '\s '. '\n '\o
       eMetaPrettyPrint(M, RlS)) .
  eq eMetaPrettyPrint(M, ((rl T => T' [AtS] .) RlS))
    = ('\s '\s '\b 'rl '\s '\o eMetaPrettyPrint(M, T) '\n  
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') 
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n 
       eMetaPrettyPrint(M, RlS)) 
    [owise] .
  eq eMetaPrettyPrint(M, ((crl T => T' if Cond [none] .) RlS))
    = ('\s '\s '\b 'crl '\s '\o eMetaPrettyPrint(M, T) '\n  
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\n  
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) '\b '\s '. '\o '\n 
       eMetaPrettyPrint(M, RlS)) .
  eq eMetaPrettyPrint(M, ((crl T => T' if Cond [AtS] .) RlS))
    = ('\s '\s '\b 'crl '\s '\o eMetaPrettyPrint(M, T) '\n 
       '\s '\s '\s '\s '\b '=> '\o '\s eMetaPrettyPrint(M, T') '\n 
       '\s '\s '\s '\s '\b 'if '\o '\s eMetaPrettyPrint(M, Cond) 
           '\s '\b '`[ '\o eMetaPrettyPrint(M, AtS) '\b '`] '\s '. '\o '\n
       eMetaPrettyPrint(M, RlS)) 
    [owise] .
  eq eMetaPrettyPrint(M, (none).RuleSet) = nil .

  eq eMetaPrettyPrint(M, T = T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b '= '\o eMetaPrettyPrint(M, T') '\b 
      '/\ '\o eMetaPrettyPrint(M, Cond)) 
    [owise] .
  eq eMetaPrettyPrint(M, T : S /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S) '\b 
      '/\ '\o eMetaPrettyPrint(M, Cond)) 
    [owise] .
  eq eMetaPrettyPrint(M, T := T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b ':= '\o eMetaPrettyPrint(M, T') '\b 
      '/\ '\o eMetaPrettyPrint(M, Cond)) 
    [owise] .
  eq eMetaPrettyPrint(M, T => T' /\ Cond)
    = (eMetaPrettyPrint(M, T) '\b '=> '\o eMetaPrettyPrint(M, T') '\b 
      '/\ '\o eMetaPrettyPrint(M, Cond)) 
    [owise] .
  eq eMetaPrettyPrint(M, T = T') 
    = (eMetaPrettyPrint(M, T) '\b '= '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, T : S) 
    = (eMetaPrettyPrint(M, T) '\b ': '\o eMetaPrettyPrint(S)) .
  eq eMetaPrettyPrint(M, T := T') 
    = (eMetaPrettyPrint(M, T) '\b ':= '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, T => T') 
    = (eMetaPrettyPrint(M, T) '\b '=> '\o eMetaPrettyPrint(M, T')) .
  eq eMetaPrettyPrint(M, (nil).EqCondition) = nil .

  eq eMetaPrettyPrint(M, (assoc AtS))  
    = ('\b 'assoc '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (comm AtS))   
    = ('\b 'comm '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (memo AtS))   
    = ('\b 'memo '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (idem AtS))   
    = ('\b 'idem '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (id(T) AtS))
    = ('\b 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (right-id(T) AtS))
    = ('\b 'right 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (left-id(T) AtS))
    = ('\b 'left 'id: '\o eMetaPrettyPrint(M, T) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (poly(NL) AtS))
    = ('\b 'poly '`( '\o eMetaPrettyPrint(NL) '\b '`) 
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (strat(NL) AtS))
    = ('\b 'strat '`( '\o eMetaPrettyPrint(NL) '\b '`) 
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (memo AtS))   
    = ('\b 'memo '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (prec(I) AtS))
    = ('\b 'prec '\o eMetaPrettyPrint(I) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (gather(QIL) AtS))
    = ('\b 'gather '\o '`( QIL '`) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (format(QIL) AtS))
    = ('\b 'format '\o '`( QIL '`) eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (ctor AtS))   
    = ('\b 'ctor '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (frozen(NL) AtS)) 
    = ('\b 'frozen '`( '\o eMetaPrettyPrint(NL) '\b '`) 
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (iter AtS))   
    = ('\b 'iter '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (special(HkL) AtS))
    = ('\b 'special '`( '\o eMetaPrettyPrint(M, HkL) '\b '`) 
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (config AtS))   
    = ('\b 'config '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (object AtS))   
    = ('\b 'object '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (msg AtS))   
    = ('\b 'msg '\o eMetaPrettyPrint(M, AtS)) .

  eq eMetaPrettyPrint(M, (label(QI) AtS))
    = ('\b 'label '\o QI '\b '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (metadata(St) AtS))
    = ('\b 'metadata '\o qid("\"" + St + "\"") '\b 
       '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (nonexec AtS))
    = ('\b 'nonexec '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (variant AtS))
    = ('\b 'variant '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (owise AtS))
    = ('\b 'owise '\o eMetaPrettyPrint(M, AtS)) .
  eq eMetaPrettyPrint(M, (print(QIL) AtS))
    = ('\b 'print QIL '\o eMetaPrettyPrint(M, AtS)) .

  eq eMetaPrettyPrint(M, (none).AttrSet) = nil .

  ceq eMetaPrettyPrint(M, (Hk HkL)) 
    = (eMetaPrettyPrint(M, Hk) eMetaPrettyPrint(M, HkL)) 
    if HkL =/= nil .
  eq eMetaPrettyPrint(M, id-hook(QI, nil)) = ('\b 'id-hook '\o QI) .
  eq eMetaPrettyPrint(M, id-hook(QI, QIL))
    = ('\b 'id-hook '\o QI '\b '`( '\o QIL '\b '`) '\o ) 
    [owise] .
  eq eMetaPrettyPrint(M, op-hook(QI, QI', nil, QI''))
    = ('\b 'op-hook '\o QI '\b '`( '\o QI' ': '~> QI'' '\b '`) '\o) .
  eq eMetaPrettyPrint(M, op-hook(QI, QI', QIL, QI''))
    = ('\b 'op-hook '\o QI '\b '`( '\o QI' ': QIL '~> QI'' '\b '`) '\o) 
    [owise] .
  eq eMetaPrettyPrint(M, term-hook(QI, T))
    = ('\b 'term-hook '\o QI '\b '`( '\o eMetaPrettyPrint(M, T) '\b '`) '\o) .

  eq eMetaPrettyPrint((I NL)) = (qid(string(I, 10)) eMetaPrettyPrint(NL)) .
  eq eMetaPrettyPrint((nil).NatList) = nil .

  eq eMetaPrettyPrint((class S | ADS .) CDS)
    = ((if ADS == none
        then ('\s '\s '\b 'class '\o eMetaPrettyPrint(S) '\b '. '\o '\n)
        else ('\s '\s '\b 'class '\o eMetaPrettyPrint(S) '\b '| '\o eMetaPrettyPrint(ADS) '\b '. '\o '\n)
        fi)
       eMetaPrettyPrint(CDS)) .
  eq eMetaPrettyPrint((none).ClassDeclSet) = nil .

  eq eMetaPrettyPrint((subclass S < S' .) SCDS)
    = ('\s '\s '\b 'subclass '\o eMetaPrettyPrint(S) '\b 
           '< '\o eMetaPrettyPrint(S') '\b '. '\o '\n 
       eMetaPrettyPrint(SCDS)) .
  eq eMetaPrettyPrint((none).SubclassDeclSet) = nil .

  eq eMetaPrettyPrint((msg F : TyL -> Ty .) MDS)
    = ('\s '\s '\b 'msg '\o F '\b ': '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty) '\b '. '\o '\n 
       eMetaPrettyPrint(MDS)) .
  eq eMetaPrettyPrint((none).MsgDeclSet) = nil .

  eq eMetaPrettyPrint(((attr F : S), ADS))
    = (F '\b ': '\o eMetaPrettyPrint(S) '\b '`, '\o '\s eMetaPrettyPrint(ADS))
    [owise] .
  eq eMetaPrettyPrint((attr F : S)) = (F '\b ': '\o eMetaPrettyPrint(S)) .
  eq eMetaPrettyPrint((none).AttrDeclSet) = nil .

endfm

*******************************************************************************

***
*** 8.2.2 Meta Pretty Printing of Modules
***

*** In the following module, the \texttt{meta-pretty-print} function is
*** defined on sort \texttt{Module}.

fmod UNIT-META-PRETTY-PRINT is
  pr UNIT .
  pr RENAMING-EXPR-EVALUATION .
  pr DECL-META-PRETTY-PRINT .

  op eMetaPrettyPrint : Module Module -> QidList .

  op eMetaPrettyPrint : Module Module -> QidList .
  op eMetaPrettyPrint : Header -> QidList .
  op eMetaPrettyPrint : ParameterDeclList -> QidList .
  op eMetaPrettyPrint : ImportList -> QidList .

  var  M : Module .
  vars QI F F' L L' : Qid .
  var  QIL : QidList .
  var  ME : ModuleExpression .
  vars S S' : Sort .
  var  Ty : Type .
  var  TyL : TypeList .
  var  SS : SortSet .
  var  PD : ParameterDecl .
  var  PDL : ParameterDeclList .
  vars IL IL' : ImportList .
  var  SSDS : SubsortDeclSet .
  var  OPDS : OpDeclSet .
  var  MAS : MembAxSet .
  var  EqS : EquationSet .
  var  RlS : RuleSet .
  var  CDS : ClassDeclSet .
  var  SCDS : SubclassDeclSet .
  var  MDS : MsgDeclSet .
  var  U : Module .
  var  AtS : AttrSet .
  var  MN : ModuleName .

  ceq eMetaPrettyPrint(ME) 
    = if QI == '`) or QI == '`] or QI == '`} 
      then QIL QI '\s
      else QIL QI 
      fi
    if QIL QI := header2QidList(ME) .

  eq eMetaPrettyPrint(W:[Module], unitError(QIL)) = QIL .
  eq eMetaPrettyPrint(unitError(QIL), noModule) = QIL .
  eq eMetaPrettyPrint(noModule, noModule) = nil .
  eq eMetaPrettyPrint(M, mod ME is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\b          
       'mod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n  
          eMetaPrettyPrint(IL) 
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)
          eMetaPrettyPrint(SSDS) 
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS) 
          eMetaPrettyPrint(M, EqS) 
          eMetaPrettyPrint(M, RlS) 
       '\b 'endm '\o '\n) .
  eq eMetaPrettyPrint(M, mod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS RlS endm)
    = ('\b 
       'mod '\o eMetaPrettyPrint(ME) (if PDL == nil 
                                      then nil
                                      else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                      fi) '\b 'is '\o '\n
          eMetaPrettyPrint(IL) 
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi) 
          eMetaPrettyPrint(SSDS) 
          eMetaPrettyPrint(M, OPDS) 
          eMetaPrettyPrint(M, MAS) 
          eMetaPrettyPrint(M, EqS) 
          eMetaPrettyPrint(M, RlS) 
       '\b 'endm '\o '\n) .
  eq eMetaPrettyPrint(M, th MN is IL sorts SS . SSDS OPDS MAS EqS RlS endth)
    = ('\b 
       'th '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n 
          eMetaPrettyPrint(IL) 
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi) 
          eMetaPrettyPrint(SSDS) 
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS) 
          eMetaPrettyPrint(M, EqS) 
          eMetaPrettyPrint(M, RlS) 
       '\b 'endth '\o '\n) .
  eq eMetaPrettyPrint(M, fmod ME is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\b 
       'fmod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n  
           eMetaPrettyPrint(IL) 
           (if SS == none
            then nil
            else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
            fi)  
           eMetaPrettyPrint(SSDS) 
           eMetaPrettyPrint(M, OPDS)
           eMetaPrettyPrint(M, MAS) 
           eMetaPrettyPrint(M, EqS) 
       '\b 'endfm '\o '\n) .
  eq eMetaPrettyPrint(M, fmod ME{PDL} is IL sorts SS . SSDS OPDS MAS EqS endfm)
    = ('\b 
       'fmod '\o eMetaPrettyPrint(ME) (if PDL == nil 
                                       then nil
                                       else '`{ eMetaPrettyPrint(PDL) '`} '\s
                                       fi) '\b 'is '\o '\n  
           eMetaPrettyPrint(IL) 
           (if SS == none
            then nil
            else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
            fi)  
           eMetaPrettyPrint(SSDS)          
           eMetaPrettyPrint(M, OPDS)
           eMetaPrettyPrint(M, MAS)          
           eMetaPrettyPrint(M, EqS) 
       '\b 'endfm '\o '\n) .
  eq eMetaPrettyPrint(M, fth MN is IL sorts SS . SSDS OPDS MAS EqS endfth)
    = ('\b 
       'fth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n  
          eMetaPrettyPrint(IL)
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n)
           fi)  
          eMetaPrettyPrint(SSDS) 
          eMetaPrettyPrint(M, OPDS)
          eMetaPrettyPrint(M, MAS) 
          eMetaPrettyPrint(M, EqS) 
       '\b 'endfth '\o '\n) .
  eq eMetaPrettyPrint(M, 
       omod ME is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ('\b 
       'omod '\o eMetaPrettyPrint(ME) '\b 'is '\o '\n  
          eMetaPrettyPrint(IL) 
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)   
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS) 
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS) 
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS) 
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS) 
       '\b 'endom '\o '\n) .
  eq eMetaPrettyPrint(M, omod ME{PDL} is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endom)
    = ('\b 
       'omod '\o eMetaPrettyPrint(ME) (if PDL == nil
                                       then nil
                                       else ('`{ eMetaPrettyPrint(PDL) '`} '\s)
                                       fi) '\b 'is '\o '\n  
          eMetaPrettyPrint(IL) 
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)   
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS) 
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS) 
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS) 
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS) 
       '\b 'endom '\o '\n) .
  eq eMetaPrettyPrint(M, oth MN is IL sorts SS . SSDS CDS SCDS OPDS MDS MAS EqS RlS endoth)
    = ('\b 
       'oth '\o eMetaPrettyPrint(MN) '\b 'is '\o '\n  
          eMetaPrettyPrint(IL) 
          (if SS == none
           then nil
           else ('\s '\s '\b 'sorts '\o eMetaPrettyPrint(SS) '\b '. '\o '\n )
           fi)   
          eMetaPrettyPrint(SSDS) eMetaPrettyPrint(CDS) 
          eMetaPrettyPrint(SCDS) eMetaPrettyPrint(M, OPDS) 
          eMetaPrettyPrint(MDS) eMetaPrettyPrint(M, MAS) 
          eMetaPrettyPrint(M, EqS) eMetaPrettyPrint(M, RlS) '\n '\b 
       'endoth '\o '\n) .

  eq eMetaPrettyPrint((including ME .) IL)
    = ('\s '\s '\b 'including '\o eMetaPrettyPrint(ME) '\b '. '\o '\n  
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((extending ME .) IL)
    = ('\s '\s '\b 'extending '\o eMetaPrettyPrint(ME) '\b '. '\o '\n  
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((protecting ME .) IL)
    = ('\s '\s '\b 'protecting '\o eMetaPrettyPrint(ME) '\b '. '\o '\n 
       eMetaPrettyPrint(IL)) .
  eq eMetaPrettyPrint((protecting pd(QI :: ME) .) IL)
    = eMetaPrettyPrint(IL) .
  eq eMetaPrettyPrint((nil).ImportList) = nil .

  eq eMetaPrettyPrint((QI :: ME, PDL))
    = (QI '::  eMetaPrettyPrint(ME) '`, eMetaPrettyPrint(PDL))
    [owise] .
  eq eMetaPrettyPrint((QI :: ME)) = (QI '::  eMetaPrettyPrint(ME)) .
  eq eMetaPrettyPrint((nil).ParameterDeclList) = (nil).QidList .

  op eMetaPrettyPrint : ModuleExpression -> QidList .
  eq eMetaPrettyPrint(QI + ME:ModuleExpression)
    = QI '+ eMetaPrettyPrint(ME:ModuleExpression) .
  eq eMetaPrettyPrint(QI * (RnS:RenamingSet))
    = QI '* '\s '`( renamingSet2QidList(RnS:RenamingSet) '`) .
  eq eMetaPrettyPrint(pd(PD)) = eMetaPrettyPrint(PD) .

  op renamingSet2QidList : RenamingSet -> QidList .
  eq renamingSet2QidList(((op F to F' [AtS]), RS:RenamingSet))
    = if AtS == none 
      then ('op F 'to F' '`, '\s renamingSet2QidList(RS:RenamingSet))
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`] '`, '\s 
            renamingSet2QidList(RS:RenamingSet))
      fi
    [owise] .
  eq renamingSet2QidList((op F to F' [AtS]))
    = if AtS == none 
      then ('op F 'to F')  
      else ('op F 'to F' '\s '`[ attrSet2QidList(AtS) '`]) 
      fi .
  eq renamingSet2QidList(((op F : TyL -> Ty to F' [AtS]), RS:RenamingSet))
    = if AtS == none 
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F' '`, 
            '\s renamingSet2QidList(RS:RenamingSet))
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F' 
            '`[ attrSet2QidList(AtS) '`] '`, 
            '\s renamingSet2QidList(RS:RenamingSet))
      fi 
    [owise] .
  eq renamingSet2QidList((op F : TyL -> Ty to F' [AtS]))
    = if AtS == none 
      then ('op F ': typeList2QidList(TyL) '-> Ty 'to F')
      else ('op F ': typeList2QidList(TyL) '-> Ty 'to F' 
            '`[ attrSet2QidList(AtS) '`]) 
      fi .
  eq renamingSet2QidList(((sort S to S'), RS:RenamingSet))
    = ('sort S 'to S' '`, '\s 
       renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((sort S to S')) = ('sort S 'to S') .

  eq renamingSet2QidList(((label L to L'), RS:RenamingSet))
    = ('label L 'to L' '`, '\s renamingSet2QidList(RS:RenamingSet))
    [owise] .
  eq renamingSet2QidList((label L to L')) = ('label L 'to L') .
endfm

*******************************************************************************

*** The function \texttt{meta-pretty-print} on units is defined recursively,
*** calling the \texttt{meta-pretty-print} functions for the different
*** declarations in the unit defined in module \texttt{DECL-META-PRETTY-PRINT}.

***
*** 8.2.3 Meta Pretty Printing of Maps and Views
***

*** We define in the following module the function \texttt{meta-pretty-print} 
*** on maps.

fmod MAP-SET-META-PRETTY-PRINT is
  pr DECL-META-PRETTY-PRINT .
  pr FMAP .
  pr UNIT .

  op eMetaPrettyPrint : RenamingSet -> QidList .

  var  MAP : Renaming .
  var  MAPS : RenamingSet .
  vars QI QI' F F' L L' : Qid .
  var  AtS : AttrSet .
  vars S S' : Sort .
  var  Ty : Type .
  var  TyL : TypeList .

  eq eMetaPrettyPrint((MAP, MAPS))
    = (eMetaPrettyPrint(MAP) '`, '\s '\s eMetaPrettyPrint(MAPS))
    [owise] .
  eq eMetaPrettyPrint((none).RenamingSet) = nil .

  eq eMetaPrettyPrint(op F to F' [AtS])
    = if AtS == none
      then ('\b 'op '\o F '\b 'to '\o F') 
      else ('\b 'op F '\b 'to '\o F' '\b 
            '`[ '\o eMetaPrettyPrint(noModule, AtS) '\b '`] '\o) 
           *** In a map there should not be attributes requiring a module 
      fi .
  eq eMetaPrettyPrint(op F : TyL -> Ty to F' [AtS])
    = if AtS == none
      then ('\b 'op '\o F '\b ': 
            '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty) 
            '\b 'to '\o F') 
      else ('\b 'op '\o F '\b ': 
            '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty) 
            '\b 'to '\o F' 
            '\b '`[ '\o eMetaPrettyPrint(noModule, AtS) '\b '`] '\o) 
           *** In a map there should not be attributes requiring a module 
      fi .
  eq eMetaPrettyPrint(sort S to S') 
    = ('\b 'sort '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S')) .
  eq eMetaPrettyPrint(label L to L') = ('\b 'label '\o L '\b 'to '\o L') .
  eq eMetaPrettyPrint(class S to S')
    = ('\b 'class '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S')) .
  eq eMetaPrettyPrint(attr QI . S to QI') 
    = ('\b 'attr '\o eMetaPrettyPrint(S) '\b '. '\o QI '\b 'to '\o QI') .
  eq eMetaPrettyPrint(msg F to F') = ('\b 'msg '\o F '\b 'to '\o F') .
  eq eMetaPrettyPrint(msg F : TyL -> Ty to F')
    = ('\b 'msg '\o F '\b ': 
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty) 
       '\b 'to '\o F') .

endfm

*******************************************************************************

*** Finally, in the \texttt{VIEW-META-PRETTY-PRINT} module, the
*** \texttt{meta-pretty-print} function is defined on views.


fmod VIEW-META-PRETTY-PRINT is
  pr DATABASE .
  pr MAP-SET-META-PRETTY-PRINT .
  pr RENAMING-SET-APPL-ON-UNIT .
  pr UNIT-META-PRETTY-PRINT .

  op eMetaPrettyPrint : Database View -> QidList .
  op eMetaPrettyPrint : ViewExp -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database SortMappingSet SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint : ModuleExpression ModuleExpression Database OpMappingSet SortMappingSet OpMappingSet -> QidList .
  op eMetaPrettyPrint : SortMapping -> QidList .
  op eMetaPrettyPrint : OpMapping -> QidList .

  vars QI QI' F F' : Qid .
  vars S S' : Sort .
  var  TyL : TypeList .
  var  Ty : Type .
  var  QIL : QidList .
  var  DB : Database .
  vars ME ME' : ModuleExpression .
  var  SM : SortMapping .
  var  OM : OpMapping .
  vars SMS SMS' : SortMappingSet .
  vars OMS OMS' : OpMappingSet .
  vars T T' : Term .
  var  PDL : ParameterDeclList .
  vars VE VE' : ViewExp .
  var  DT : Default{Term} .

  ceq eMetaPrettyPrint(DB, view VE from ME to ME' is SMS OMS endv)
    = ('\b 'view '\o 
                 QIL QI 
                 if QI == '`) then '\s else nil fi
              '\b 'from '\o eMetaPrettyPrint(ME) 
              '\b 'to '\o eMetaPrettyPrint(ME') '\b 'is '\o '\n 
       if SMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, SMS, SMS, OMS) else nil fi 
       if OMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, OMS, SMS, OMS) else nil fi 
       '\b 'endv '\o '\n) 
    if QIL QI := eMetaPrettyPrint(VE) .
  ceq eMetaPrettyPrint(DB, view VE{PDL} from ME to ME' is SMS OMS endv)
    = ('\b 'view '\o 
                 QIL QI 
                 (if PDL == nil 
                  then if QI == '`) then '\s else nil fi
                  else '`{ eMetaPrettyPrint(PDL) '`} '\s
                  fi) 
              '\b 'from '\o eMetaPrettyPrint(ME) 
              '\b 'to '\o eMetaPrettyPrint(ME') '\b 'is '\o '\n 
       if OMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, SMS, SMS, OMS) else nil fi 
       if OMS =/= none then '\s '\s eMetaPrettyPrint(ME, ME', DB, OMS, SMS, OMS) else nil fi 
       '\b 'endv '\o '\n ) 
    if QIL QI := eMetaPrettyPrint(VE) .
  eq eMetaPrettyPrint(DB, viewError(QIL)) = QIL .

  ceq eMetaPrettyPrint(QI) = QI if not QI :: Type .
  ceq eMetaPrettyPrint(((VE, VE'))) 
    = eMetaPrettyPrint(VE) '`, '\s eMetaPrettyPrint(VE') 
    if VE =/= nil /\ VE' =/= nil .
  eq eMetaPrettyPrint(QI{VE}) = QI '`{ eMetaPrettyPrint(VE) '`} '\s .

 ceq eMetaPrettyPrint(ME, ME', DB, SM SMS, SMS', OMS')
    = (eMetaPrettyPrint(ME, ME', DB, SM, SMS', OMS') '\n 
       '\s '\s eMetaPrettyPrint(ME, ME', DB, SMS, SMS', OMS'))
    if SMS =/= none .     
 ceq eMetaPrettyPrint(ME, ME', DB, OM OMS, SMS', OMS')
    = (eMetaPrettyPrint(ME, ME', DB, OM, SMS', OMS') '\n 
       '\s '\s eMetaPrettyPrint(ME, ME', DB, OMS, SMS', OMS'))
    if OMS =/= none .     
  eq eMetaPrettyPrint(ME, ME', DB, (none).SortMappingSet, SMS, OMS) = nil .
  eq eMetaPrettyPrint(ME, ME', DB, (none).OpMappingSet, SMS, OMS) = nil .

  eq eMetaPrettyPrint(ME, ME', DB, op_to`term_.(T, T'), SMS, OMS)
    = ('\b 'op '\o eMetaPrettyPrint(getFlatModule(ME, DB), T) '\b 'to 
               'term '\o eMetaPrettyPrint(getFlatModule(ME', DB), T') '\b '. '\o) .

  eq eMetaPrettyPrint(ME, ME', DB, op_to`term_.(T, T'), SMS, OMS) 
    = ('op eMetaPrettyPrint(T) '\b 'to 'term '\o eMetaPrettyPrint(T') '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, op F to F' ., SMS, OMS)
    = ('\b 'op '\o F '\b 'to '\o F' '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, op F : TyL -> Ty to F' ., SMS, OMS)
    = ('\b 'op '\o F '\b ': 
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty) 
       '\b 'to '\o F' '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, sort S to S' ., SMS, OMS) 
    = ('\b 'sort '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S') '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, class S to S' ., SMS, OMS)
    = ('\b 'class '\o eMetaPrettyPrint(S) '\b 'to '\o eMetaPrettyPrint(S') '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, attr QI . S to QI' ., SMS, OMS) 
    = ('\b 'attr '\o eMetaPrettyPrint(S) '\b '. '\o QI '\b 'to '\o QI' '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, msg F to F' ., SMS, OMS) 
    = ('\b 'msg '\o F '\b 'to '\o F' '. '\n) .
  eq eMetaPrettyPrint(ME, ME', DB, msg F : TyL -> Ty to F' ., SMS, OMS)
    = ('\b 'msg '\o F '\b ': 
       '\o eMetaPrettyPrint(TyL) '\b '-> '\o eMetaPrettyPrint(Ty) 
       '\b 'to '\o F' '. '\n) .
endfm
