
fmod MYMOD is
    protecting FUNCTIONS+{Int, Bool, String, Nat, Qid, Maybe{Int}} .
endfm

fmod FUN{X :: TRIV, Y :: TRIV} is
    sort =>{X,Y} .
    op __ : =>{X,Y} X$Elt -> Y$Elt .

    sort =>{X,Y,Y} .
    op ___ : =>{X,Y,Y} X$Elt Y$Elt -> Y$Elt .

    sort =>{X,Y,X} .
    op ___ : =>{X,Y,X} X$Elt Y$Elt -> X$Elt .
endfm

fmod MAYBE{X :: TRIV} is
    sort Maybe{X} .
    op Nothing : -> Maybe{X} .
    op Just_ : X$Elt -> Maybe{X} .
endfm

fmod MAP{X :: TRIV, Y :: TRIV} is
    protecting FUN{X, Y} .
    protecting LIST{X} .
    protecting LIST{Y} .
    protecting MAYBE{X} .
    protecting MAYBE{Y} .

    op map__ : =>{X,Y} List{X} -> List{Y} .
    op map__ : =>{X,Y} Maybe{X} -> Maybe{Y} .

    var XS  : List{X} .
    var X   : X$Elt .
    var f   : =>{X,Y} .

    eq map f (X XS) = (f X) (map f XS) .
    eq map f nil    = nil .

    eq map f (Just X)   = Just (f X) .
    eq map f Nothing    = Nothing .
endfm

fmod FOLD{X :: TRIV, Y :: TRIV} is
    protecting FUN{X, Y} .
    protecting LIST{X} .
    protecting LIST{Y} .

    op foldr___ : =>{X,Y,Y} Y$Elt List{X} -> Y$Elt .
    op foldl___ : =>{X,Y,X} X$Elt List{Y} -> X$Elt .

    var Y   : Y$Elt .
    var YS  : List{Y} .
    var X   : X$Elt .
    var XS  : List{X} .
    var f   : =>{X,Y,Y} .
    var g   : =>{X,Y,X} .

    --- fold right : (x -> y -> y) -> y -> [x] -> y
    eq foldr f Y nil    = Y .
    eq foldr f Y (X XS) = f X (foldr f Y XS) .

    --- fold left : (x -> y -> x) -> x -> [y] -> x
    eq foldl g X nil    = X .
    eq foldl g X (Y YS) = foldl g (g X Y) YS .
endfm

fmod COMP{X :: TRIV, Y :: TRIV, Z :: TRIV} is
    protecting FUN{X, Y} .
    protecting FUN{Y, Z} .
    protecting FUN{X, Z} .

    op _._ : =>{Y,Z} =>{X,Y} -> =>{X,Z} .

    var F : =>{X,Y} .
    var G : =>{Y,Z} .
    var X : X$Elt .

    eq (G . F) X = G (F X) .
endfm

fmod MYMOD is
    protecting MAP{Nat, Bool} .
    protecting MAP{Bool, Nat} .
    protecting MAP{Bool, Bool} .
    protecting MAP{Nat, Nat} .
    protecting FOLD{Nat, Nat} .
    protecting COMP{Nat, Bool, Nat} .

    op toNat : -> =>{Bool, Nat} .
    eq toNat false      = 0 .
    eq toNat true       = 1 .

    vars N M : Nat .

    op even : -> =>{Nat, Bool} .
    eq even 0           = true .
    eq even 1           = false .
    eq even (s(s(N)))   = even N .

    op odd : -> =>{Nat, Bool} .
    eq odd 0            = false .
    eq odd 1            = true .
    eq odd (s(s(N)))    = odd N .

    op plus : -> =>{Nat, Nat, Nat} .
    eq plus 0 M         = M .
    eq plus s(N) M      = s(plus N M) .
endfm
