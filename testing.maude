--- Core Maude
--- ----------

fmod FUNCTION{X :: TRIV, Y :: TRIV} is
    sorts =>{X,Y} .
    op __ : =>{X,Y} X$Elt -> Y$Elt .
endfm

fmod FUNCTION-ID{X :: TRIV} is
    protecting FUNCTION{X,X} .
    op id : -> =>{X,X} .
    var x : X$Elt .
    eq id x = x .
endfm

fmod FUNCTIONS-BETWEEN{X :: TRIV, Y :: TRIV} is
    protecting FUNCTION{X,Y} .
    protecting FUNCTION{Y,X} .
    protecting FUNCTION-ID{X} .
    protecting FUNCTION-ID{Y} .
endfm

fmod FUNCTIONS{X :: TRIV, Y :: TRIV, Z :: TRIV} is
    protecting FUNCTIONS-BETWEEN{X,Y} .
    protecting FUNCTIONS-BETWEEN{X,Z} .
    protecting FUNCTIONS-BETWEEN{Y,Z} .

    op _._ : =>{Y,Z} =>{X,Y} -> =>{X,Z} .

    var f : =>{X,Y} .
    var g : =>{Y,Z} .
    var x : X$Elt .
    eq (g . f) x = g (f x) .
endfm

fmod DATA-MAYBE{a :: TRIV} is
    sort Maybe{a} .
    op Nothing : -> Maybe{a} .
    op Just_ : a$Elt -> Maybe{a} .
endfm

fmod DATA-CONS{a :: TRIV} is
    sort Cons{a} .
    op [] : -> Cons{a} .
    op _:_ : a$Elt Cons{a} -> Cons{a} .
endfm

--- Full Maude
--- ----------

load fm27.maude .

(
view Maybe{a :: TRIV} from TRIV to DATA-MAYBE{a} is
    sort Elt to Maybe{a} .
endv
)

(
view Cons{a :: TRIV} from TRIV to DATA-CONS{a} is
    sort Elt to Cons{a} .
endv
)

(
view =>{X :: TRIV, Y :: TRIV} from TRIV to FUNCTION{X,Y} is
    sort Elt to =>{X,Y} .
endv
)

(
fmod INSTANCE-FUNCTOR-MAYBE{a :: TRIV, b :: TRIV} is
    protecting FUNCTION{a, b} .
    protecting FUNCTION{Maybe{a}, Maybe{b}} .
    extending FUNCTION{=>{a,b}, =>{Maybe{a},Maybe{b}}} .
    op fmap : -> =>{=>{a,b}, =>{Maybe{a},Maybe{b}}} .

    var f : =>{a,b} .
    var a : a$Elt .
    eq fmap f Nothing = Nothing .
    eq fmap f (Just a) = Just (f a) .
endfm
)

(
fmod INSTANCE-FUNCTOR-CONS{a :: TRIV, b :: TRIV} is
    protecting FUNCTION{a, b} .
    protecting FUNCTION{Cons{a}, Cons{b}} .
    extending FUNCTION{=>{a,b}, =>{Cons{a},Cons{b}}} .
    op fmap : -> =>{=>{a,b}, =>{Cons{a},Cons{b}}} .

    var f   : =>{a,b} .
    var a   : a$Elt .
    var as  : Cons{a} .
    eq fmap f [] = [] .
    eq fmap f (a : as) = (f a) : fmap f as .
endfm
)

--- Testing
--- -------

(
fmod TESTING is
    extending INSTANCE-FUNCTOR-MAYBE{Nat, Bool} .
    extending INSTANCE-FUNCTOR-CONS{Nat, Bool} .

    op even : -> =>{Nat,Bool} .
    op odd : -> =>{Nat,Bool} .

    var N : Nat .

    eq even 0 = true .
    eq even s(0) = false .
    eq even s(s(N)) = even N .

    eq odd 0 = false .
    eq odd s(0) = true .
    eq odd s(s(N)) = odd N .
endfm
)

(reduce fmap even Nothing .)

(reduce fmap odd (Just 3) .)

(reduce fmap odd (3 : 5 : 8 : 2 : []) .)

(reduce fmap even (4 : 2 : 3 : 9 : 12 : []) . )
